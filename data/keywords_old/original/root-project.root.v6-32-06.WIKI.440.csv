id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html602/TBranchElement.html:32231,Deployability,Release,Release,32231,"ch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:38479,Deployability,Update,UpdateFile,38479," splitting. Note: The above rules imply that the branch heirarchy increases; in depth only for base classes of cl (unless we are inside; of a TClonesArray or STL container, in which case the depth; does *not* increase, the base class is elided) and for; TClonesArray or STL container data members (which have one; additional level of sub-branches). The only other way the; depth increases is when the top-level branch has a split; class data member, in that case the constructor will create; a sub-branch for it. In other words, the interior nodes of; the branch tree are all either: base class nodes; split; class nodes which are direct sub-branches of top-level nodes; (created by TClass::Bronch usually); or TClonesArray or STL; container master nodes. Note: The exception to the above is for the top-level branches,; Tree::Bronch creates nodes for everything in that case,; except for a TObject base class of a class which has the; can ignore tobject streamer flag set. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. co",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:38690,Deployability,update,update,38690,"oes *not* increase, the base class is elided) and for; TClonesArray or STL container data members (which have one; additional level of sub-branches). The only other way the; depth increases is when the top-level branch has a split; class data member, in that case the constructor will create; a sub-branch for it. In other words, the interior nodes of; the branch tree are all either: base class nodes; split; class nodes which are direct sub-branches of top-level nodes; (created by TClass::Bronch usually); or TClonesArray or STL; container master nodes. Note: The exception to the above is for the top-level branches,; Tree::Bronch creates nodes for everything in that case,; except for a TObject base class of a class which has the; can ignore tobject streamer flag set. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. const char * GetParentName() const; { return fParentName.Data(); }. Int_t GetNdata() const; { return fNdata; }. Int_t GetType() const; { return fType; }. Int_t GetStreamerType() const; { return fStrea",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:31845,Energy Efficiency,allocate,allocated,31845," within a TClonesArray (fType == 31). void ReadLeavesMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are not a counter. void ReadLeavesMemberBranchCount(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObje",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:32184,Energy Efficiency,allocate,allocated,32184,"s into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->S",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:32256,Energy Efficiency,allocate,allocated,32256,"ch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:32361,Energy Efficiency,allocate,allocated,32361,"counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:32588,Energy Efficiency,allocate,allocate,32588,"/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), ",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:32660,Energy Efficiency,allocate,allocated,32660,"/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), ",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:32934,Energy Efficiency,allocate,allocate,32934,"xisting i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1-",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:33003,Energy Efficiency,allocate,allocated,33003,"xisting i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1-",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:33042,Energy Efficiency,allocate,allocated,33042,"erge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 =",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:33318,Energy Efficiency,allocate,allocated,33318," added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branc",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:33754,Energy Efficiency,allocate,allocated,33754,"branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate""",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:34115,Energy Efficiency,allocate,allocated,34115,"eeded. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted a",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:34661,Energy Efficiency,allocate,allocated,34661," as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set ",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:16364,Integrability,interface,interface,16364,"cted:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TClassReffBranchClass! Reference to class definition in fClassName; TBranchElement*fBranchCountpointer to primary branchcount branch; TBranchElement*fBranchCount2pointer to secondary branchcount branch; Int_tfBranchID! ID number assigned by a TRefTable.; Int_t*fBranchOffset! Sub-Branch offsets with respect to current transient class; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); UInt_tfCheckSumCheckSum of class; TStringfClassNameClass name of referenced object; Version_tfClassVersionVersion number of class; TClassReffClonesClass! Reference to class definition in fClonesName; TStringfClonesNameName of class in TClonesArray (if any); TVirtualCollectionProxy*fCollProxy! collection interface (if any); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TClassReffCurrentClass! Reference to current (transient) class definition; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); TStreamerInfoActions::TActionSequence*fFillActionSequence! Set of actions to be executed ",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:27690,Integrability,depend,depending,27690,"volution. TVirtualCollectionProxy* GetCollectionProxy(); -- Return the collection proxy describing the branch content, if any. TClass* GetCurrentClass(); -- Return a pointer to the current type of the data member corresponding to branch element. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches of a BranchElement and return total number of bytes. If entry = 0, then use current entry number + 1.; If entry < 0, then reset entry number to 0. Returns the number of bytes read from the input buffer.; If entry does not exist, then returns 0.; If an I/O error occurs, then returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. const char* GetIconName() const; -- Return icon name depending on type of branch element. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). Int_t GetMaximum() const; -- Return maximum count value of the branchcount if any. char* GetObject() const; -- Return a pointer to our object. TClass* GetParentClass(); -- Return a pointer to the parent class of the branch element. const char* GetTypeName() const; -- Return type name of element in the branch. void* GetValuePointer() const; -- Returns pointer to first data element of this branch.; Currently used only for members of type character. void InitializeOffsets(); -- Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a container sub-branch. Note: The offsets are zero for data members so that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the add",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:32286,Integrability,interface,interface,32286,"counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:33682,Integrability,rout,routines,33682,"the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An exam",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:5685,Modifiability,Inherit,InheritsFrom,5685,"TBranch* br) const; virtual TClass*GetTargetClass(); virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; Int_tGetType() const; doubleGetTypedValue<double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; long doubleGetTypedValue<long double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; Long64_tGetTypedValue<long long>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual void*GetValuePointer() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; Bool_tIsBranchFolder() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tIsObjectOwner() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidT",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:5751,Modifiability,Inherit,InheritsFrom,5751," char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; Int_tGetType() const; doubleGetTypedValue<double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; long doubleGetTypedValue<long double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; Long64_tGetTypedValue<long long>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual void*GetValuePointer() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; Bool_tIsBranchFolder() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tIsObjectOwner() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:15220,Modifiability,variab,variable,15220,p; static TObject::EStatusBitsTObject::kIsReferenced; static TBranchElement::EBranchElementTypekLeafNode; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TBranchElement::EBranchElementTypekObjectNode; static TObject::(anonymous)TObject::kOverwrite; static TBranchElement::EBranchElementTypekSTLMemberNode; static TBranchElement::EBranchElementTypekSTLNode; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TClassReffBranchClass! Reference to class definition in fClassName; TBranchElement*fBranchCountpointer to primary branchcount branch; TBranchElement*fBranchCount2pointer to secondary branchcount branch; Int_tfBranchID! ID number assigned by a TRefTable.; Int_t*fBranchOffset! Sub-Branch offsets with respect to current transient class; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); UInt_tfCheckSumCheckSum of class; TStringfClassNameClass name of referenced object; Version_tfClassVersionVersion number of class; TClassReffClonesClass! Reference to class definition in fClonesName; TStringfClonesNameName of class in TClonesArray (if any); TVirtualCollectionProxy*fCollProxy! collection interface (if any); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.;,MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:18089,Modifiability,variab,variable,18089, in same file as Tree header); TStreamerInfoActions::TActionSequence*fFillActionSequence! Set of actions to be executed to write the data to the basket.; Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use.; Style_tTAttFill::fFillStylefill area style; Long64_tTBranch::fFirstBasketEntry! First entry in the current basket.; Long64_tTBranch::fFirstEntryNumber of the first entry in this branch; Int_tfIDelement serial number in fInfo; vector<Int_t>fIDs! List of the serial number of all the StreamerInfo to be used.; TStreamerInfo*fInfo! Pointer to StreamerInfo; Bool_tfInit! Initialization flag for branch assignment; Bool_tfInitOffsets! Initialization flag to not endlessly recalculate offsets; TVirtualCollectionIterators*fIterators! holds the iterators when the branch is of fType==4.; TObjArrayTBranch::fLeaves-> List of leaves of this branch; Int_tTBranch::fMaxBasketsMaximum number of Baskets so far; Int_tfMaximumMaximum entries for a TClonesArray or variable array; TBranch*TBranch::fMother! Pointer to top-level parent branch in the tree.; Int_tTBranch::fNBaskets! Number of baskets in memory; TStringTNamed::fNameobject identifier; Int_tfNdata! Number of data in this branch; Long64_tTBranch::fNextBasketEntry! Next entry that will requires us to go to the next basket; Int_tTBranch::fNleaves! Number of leaves; char*fObject! Pointer to object at *fAddress; Int_tTBranch::fOffsetOffset of this branch; TVirtualArray*fOnfileObject! Place holder for the onfile representation of data members.; TBranch*TBranch::fParent! Pointer to parent branch.; TClassReffParentClass! Reference to class definition in fParentName; TStringfParentNameName of parent class; TVirtualCollectionPtrIterators*fPtrIterators! holds the iterators when the branch is of fType==4 and it is a split collection of pointers.; TStreamerInfoActions::TActionSequence*fReadActionSequence! Set of actions to be executed to extract the data from,MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:20504,Modifiability,Inherit,Inheritance,20504,"emory class; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tfTypebranch type; Int_tTBranch::fWriteBasketLast basket number written; TVirtualCollectionIterators*fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranchElement::(anonymous)kAddressSet; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranchElement::(anonymous)kBranchFolder; static TBranchElement::(anonymous)kCache; static TBranchElement::(anonymous)kDecomposedObj; static TBranchElement::(anonymous)kDeleteObject; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchElement::(anonymous)kMakeClass; static TBranchElement::(anonymous)kOwnOnfileObj. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SwitchContainer(TObjArray* ); -- Modify the container type of the branches. TBranchElement(); -- Default and I/O constructor. TBranchElement(TTree* tree, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. TBranchElement(TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. void Init(TTree* tree, TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Init when the branch objec",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:20517,Modifiability,Inherit,Inherited,20517,"emory class; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tfTypebranch type; Int_tTBranch::fWriteBasketLast basket number written; TVirtualCollectionIterators*fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranchElement::(anonymous)kAddressSet; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranchElement::(anonymous)kBranchFolder; static TBranchElement::(anonymous)kCache; static TBranchElement::(anonymous)kDecomposedObj; static TBranchElement::(anonymous)kDeleteObject; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchElement::(anonymous)kMakeClass; static TBranchElement::(anonymous)kOwnOnfileObj. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SwitchContainer(TObjArray* ); -- Modify the container type of the branches. TBranchElement(); -- Default and I/O constructor. TBranchElement(TTree* tree, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. TBranchElement(TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. void Init(TTree* tree, TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Init when the branch objec",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:6321,Performance,Load,LoadBaskets,6321,"_t len, Bool_t subarr = kFALSE) const; virtual void*GetValuePointer() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; Bool_tIsBranchFolder() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tIsObjectOwner() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; voidPrintValue(Int_t i) const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voidReset(Opt",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:36348,Performance,load,loaded,36348,"anch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to which the data member represented by this; branch belongs) inside its containing object (if any). void SetReadActionSequence(); Set the sequence of actions needed to read the data out of the buffer. void SetReadLeavesPtr(); Set the ReadLeaves pointer to execute the expected operations. void SetFillActionSequence(); Set the sequence of actions needed to write the data out from the buffer. void SetFillLeavesPtr(); Set the FillLeaves pointer to execute the expected operations. void SetTargetClass(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void SetupAddressesImpl(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void Streamer(TBuffer& ); -- Stream an object of class TBranchElement. Int_t Unroll(const char* name, TClass* cltop, TClass* cl, char* ptr, Int_t basketsize, Int_t splitlevel, Int_t btype); -- Split class cl into sub-branches of this branch. Create a sub-branch of this branch for each non-empty,; non-abstract base class of cl (unless we are a sub-branch; of a TClonesArray or an STL container, in which case we; do *not* create a sub-branch), and for each non-split data; member of cl. Note: We do *n",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:29239,Safety,Detect,Detect,29239,"his branch.; Currently used only for members of type character. void InitializeOffsets(); -- Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a container sub-branch. Note: The offsets are zero for data members so that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeavesImpl(TBuffer& b); -- Unconfiguration Read Leave function. void ReadLeavesMakeClass(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void ReadLeavesCollection(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void ReadLeavesCollectionSplitPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member withi",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:29517,Safety,detect,detect,29517,"o that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeavesImpl(TBuffer& b); -- Unconfiguration Read Leave function. void ReadLeavesMakeClass(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void ReadLeavesCollection(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void ReadLeavesCollectionSplitPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionSplitVectorPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionMember(TBuffer& b); -- Read lea",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:5575,Security,Hash,Hash,5575,"nt_t row); Int_tTBranch::GetSplitLevel() const; Int_tGetStreamerType() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual TClass*GetTargetClass(); virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; Int_tGetType() const; doubleGetTypedValue<double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; long doubleGetTypedValue<long double>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; Long64_tGetTypedValue<long long>(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; virtual void*GetValuePointer() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; Bool_tIsBranchFolder() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tIsObjectOwner() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removed",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:38759,Security,Validat,ValidateAddress,38759,"have one; additional level of sub-branches). The only other way the; depth increases is when the top-level branch has a split; class data member, in that case the constructor will create; a sub-branch for it. In other words, the interior nodes of; the branch tree are all either: base class nodes; split; class nodes which are direct sub-branches of top-level nodes; (created by TClass::Bronch usually); or TClonesArray or STL; container master nodes. Note: The exception to the above is for the top-level branches,; Tree::Bronch creates nodes for everything in that case,; except for a TObject base class of a class which has the; can ignore tobject streamer flag set. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. const char * GetParentName() const; { return fParentName.Data(); }. Int_t GetNdata() const; { return fNdata; }. Int_t GetType() const; { return fType; }. Int_t GetStreamerType() const; { return fStreamerType; }. TClass * GetTargetClass(); { return fTargetClass; }. Double_t GetValue(Int_t i, Int_t len, Bo",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:10923,Testability,Test,TestBit,10923,"ntClass(TClass* clparent); virtual voidSetParentName(const char* name); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidSetTargetClass(const char* name); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidSetType(Int_t btype); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchElement(); TBranchElement(TTree* tree, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); TBranchElement(TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:10962,Testability,Test,TestBits,10962,"ntClass(TClass* clparent); virtual voidSetParentName(const char* name); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidSetTargetClass(const char* name); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidSetType(Int_t btype); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchElement(); TBranchElement(TTree* tree, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TClonesArray* clones, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TBranch* parent, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); TBranchElement(TTree* tree, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); TBranchElement(TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidUpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:34238,Testability,test,test,34238,"ent = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSiz",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:34777,Testability,test,test,34777,"ocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to whi",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:39978,Testability,Test,TestBit,39978,"nless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. const char * GetParentName() const; { return fParentName.Data(); }. Int_t GetNdata() const; { return fNdata; }. Int_t GetType() const; { return fType; }. Int_t GetStreamerType() const; { return fStreamerType; }. TClass * GetTargetClass(); { return fTargetClass; }. Double_t GetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; { return GetTypedValue<Double_t>(i, len, subarr); }. Int_t GetClassVersion(); { return fClassVersion; }. Bool_t IsBranchFolder() const; { return TestBit(kBranchFolder); }. Bool_t IsObjectOwner() const; { return TestBit(kDeleteObject); }. Bool_t Notify(). void SetBranchFolder(); { SetBit(kBranchFolder); }. void SetClassName(const char* name); { fClassName = name; }. void SetParentName(const char* name); { fParentName = name; }. void SetType(Int_t btype); { fType = btype; }.  Author: Rene Brun 14/01/2001  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:40044,Testability,Test,TestBit,40044,"nless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. const char * GetParentName() const; { return fParentName.Data(); }. Int_t GetNdata() const; { return fNdata; }. Int_t GetType() const; { return fType; }. Int_t GetStreamerType() const; { return fStreamerType; }. TClass * GetTargetClass(); { return fTargetClass; }. Double_t GetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; { return GetTypedValue<Double_t>(i, len, subarr); }. Int_t GetClassVersion(); { return fClassVersion; }. Bool_t IsBranchFolder() const; { return TestBit(kBranchFolder); }. Bool_t IsObjectOwner() const; { return TestBit(kDeleteObject); }. Bool_t Notify(). void SetBranchFolder(); { SetBit(kBranchFolder); }. void SetClassName(const char* name); { fClassName = name; }. void SetParentName(const char* name); { fParentName = name; }. void SetType(Int_t btype); { fType = btype; }.  Author: Rene Brun 14/01/2001  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchElement.html:788,Usability,Clear,Clear,788," virtual~TBranchElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* nam",MatchSource.WIKI,root/html602/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchElement.html
https://root.cern/root/html602/TBranchObject.html:1442,Availability,Error,Error,1442,"t char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virt",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:1571,Availability,error,error,1571,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTB",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:1655,Availability,error,error,1655,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel() const; I",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:15379,Availability,error,error,15379,"reate a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() const; Return TRUE if more than one leaf or if fBrowsables, FALSE otherwise. void Print(Option_t* option = """") const; Print TBranch parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new ",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:15715,Availability,failure,failure,15715,"ool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() const; Return TRUE if more than one leaf or if fBrowsables, FALSE otherwise. void Print(Option_t* option = """") const; Print TBranch parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer call",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:7600,Deployability,update,updateSubBranches,7600,"oidTBranch::ResetCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addobj); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& ",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:9370,Deployability,Update,UpdateFile,9370,"ual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchObject(); TBranchObject(const TBranchObject&); TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:17594,Deployability,Update,UpdateAddress,17594," SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& ); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. TBranchObject(). const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }.  Author: Rene Brun 11/02/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:17611,Deployability,Update,Update,17611," SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& ); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. TBranchObject(). const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }.  Author: Rene Brun 11/02/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:16974,Energy Efficiency,efficient,efficient,16974,"re reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& ); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. TBranchObject(). const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }.  Author: Rene Brun 11/02/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:40; This page has been automat",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:14798,Integrability,rout,routine,14798,"nt_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchObject::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchObject(); Default constructor for BranchObject. TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() co",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:4805,Modifiability,Inherit,InheritsFrom,4805,"e() const; Int_tTBranch::GetNleaves() const; virtual const char*GetObjClassName(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operato",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:4871,Modifiability,Inherit,InheritsFrom,4871,"tObjClassName(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:11181,Modifiability,variab,variable,11181,"TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); TStringfClassNameClass name of referenced object; Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use.; Sty",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:14082,Modifiability,Inherit,Inheritance,14082,"anch::fOffsetOffset of this branch; TObject*fOldObject!Pointer to old object; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchObject::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchObject(); Default constructor for BranchObject. TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all b",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:14095,Modifiability,Inherit,Inherited,14095,"anch::fOffsetOffset of this branch; TObject*fOldObject!Pointer to old object; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap; static TBranchObject::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchObject(); Default constructor for BranchObject. TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all b",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:5374,Performance,Load,LoadBaskets,5374,") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBranchObject&operator=(const TBranchObject&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* ",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:4695,Security,Hash,Hash,4695," const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual const char*GetObjClassName(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); ",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:9255,Testability,Test,TestBit,9255,"ual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchObject(); TBranchObject(const TBranchObject&); TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:9294,Testability,Test,TestBits,9294,"ual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchObject(); TBranchObject(const TBranchObject&); TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchObject.html:783,Usability,Clear,Clear,783," virtual~TBranchObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(co",MatchSource.WIKI,root/html602/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchObject.html
https://root.cern/root/html602/TBranchRef.html:2201,Availability,Error,Error,2201," char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virt",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:2330,Availability,error,error,2330,"tBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*TBranch::GetClassName() const",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:2414,Availability,error,error,2414," virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*TBranch::GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel()",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:8397,Deployability,update,updateSubBranches,8397,"; virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTBranch::SetAddress(void* add); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voi",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:9912,Deployability,Update,UpdateAddress,9912,"ect::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchRef(); TBranchRef(TTree* tree); TBranchRef(const TBranchRef&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:9950,Deployability,Update,UpdateFile,9950,"ect::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchRef(); TBranchRef(TTree* tree); TBranchRef(const TBranchRef&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:5584,Modifiability,Inherit,InheritsFrom,5584,":GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; TRefTable*GetRefTable() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operato",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:5650,Modifiability,Inherit,InheritsFrom,5650,"Object::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; TRefTable*GetRefTable() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:11654,Modifiability,variab,variable,11654,"ject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use.; Style_tTAttFill::fFillStylef",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:14553,Modifiability,Inherit,Inheritance,14553,"nch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:14566,Modifiability,Inherit,Inherited,14566,"nch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:362,Performance,load,loads,362,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() ",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:516,Performance,load,load,516,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() ",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:993,Performance,load,loading,993,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() ",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:6162,Performance,Load,LoadBaskets,6162,"Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBranchRef&operator=(const TBranchRef&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voi",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:5474,Security,Hash,Hash,5474,"Class() const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; TRefTable*GetRefTable() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); ",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:9826,Testability,Test,TestBit,9826,"ect::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchRef(); TBranchRef(TTree* tree); TBranchRef(const TBranchRef&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:9865,Testability,Test,TestBits,9865,"ect::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchRef(); TBranchRef(TTree* tree); TBranchRef(const TBranchRef&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:14775,Usability,Clear,Clear,14775,"e ReadLeaves implementation to use.; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when r",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:14805,Usability,Clear,Clear,14805,"e ReadLeaves implementation to use.; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when r",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:15481,Usability,clear,cleared,15481,"anch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TBranchRef(). TRefTable * GetRefTable() const; {return fRefTable;}. void SetRequestedEntry(Long64_t entry); {fRequestedEntry = entry;}.  Author: Rene Brun 19/08/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchRef.html:15619,Usability,clear,cleared,15619,"anch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TBranchRef(). TRefTable * GetRefTable() const; {return fRefTable;}. void SetRequestedEntry(Long64_t entry); {fRequestedEntry = entry;}.  Author: Rene Brun 19/08/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchRef.html
https://root.cern/root/html602/TBranchSTL.html:1516,Availability,Error,Error,1516,"t char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virt",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:1645,Availability,error,error,1645,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTB",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:1729,Availability,error,error,1729,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel() const; I",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:15455,Availability,failure,failure,15455,"lectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TStreamerInfo* GetInfo() const. Check if we don't have the streamer info. Bool_t IsFolder() const; branch declared folder if at least one entry. void Print(Option_t* ) const; Print the branch parameters. void ReadLeavesImpl(TBuffer& b); TO BE DOCUMENTED. void FillLeavesImpl(TBuffer& b); TO BE DOCUMENTED. void SetAddress(void* addr). We are the top level branch. TBranchSTL(). const char * GetClassName() const; { return fClassName.Data(); }.  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:7691,Deployability,update,updateSubBranches,7691,"tCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addr); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberIn",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:9335,Deployability,Update,UpdateAddress,9335," Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchSTL(); TBranchSTL(const TBranchSTL&); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:9373,Deployability,Update,UpdateFile,9373," Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchSTL(); TBranchSTL(const TBranchSTL&); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:4880,Modifiability,Inherit,InheritsFrom,4880,"nst; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operato",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:4946,Modifiability,Inherit,InheritsFrom,4946,"Nleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:11087,Modifiability,variab,variable,11087,"ject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in each basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; TBranch::FillLeaves_tTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use.; Style_tTAttFill::fFillStylef",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:14487,Modifiability,Inherit,Inheritance,14487,"ree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. TBranchSTL::BranchMap_tfBranchMap! Branch map; vector<TBranchSTL::ElementBranchHelper_t>fBranchVector! Branch vector; UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TStreamerInfo* GetInfo() const. Check if we don't",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:14500,Modifiability,Inherit,Inherited,14500,"ree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. TBranchSTL::BranchMap_tfBranchMap! Branch map; vector<TBranchSTL::ElementBranchHelper_t>fBranchVector! Branch vector; UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TStreamerInfo* GetInfo() const. Check if we don't",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:365,Performance,queue,queues,365,". TBranchSTL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TBranchSTL. class TBranchSTL: public TBranch. TBranchSTL. A Branch handling STL collection of pointers (vectors, lists, queues,; sets and multisets) while storing them in split mode. Function Members (Methods); public:. virtual~TBranchSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:5449,Performance,Load,LoadBaskets,5449,") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBranchSTL&operator=(const TBranchSTL&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t*) const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voidTB",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:4770,Security,Hash,Hash,4770," virtual Bool_tTBranch::GetMakeClass() const; Int_tTBranch::GetMaxBaskets() const; TBranch*TBranch::GetMother() const; virtual const char*TNamed::GetName() const; Int_tTBranch::GetNleaves() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTBranch::GetOffset() const; virtual Option_t*TObject::GetOption() const; Int_tTBranch::GetReadBasket() const; Long64_tTBranch::GetReadEntry() const; virtual Int_tTBranch::GetRow(Int_t row); Int_tTBranch::GetSplitLevel() const; TBranch*TBranch::GetSubBranch(const TBranch* br) const; virtual const char*TNamed::GetTitle() const; Long64_tTBranch::GetTotalSize(Option_t* option = """") const; Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); ",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:13993,Security,checksum,checksum,13993,"ber when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. TBranchSTL::BranchMap_tfBranchMap! Branch map; vector<TBranchSTL::ElementBranchHelper_t>fBranchVector! Branch vector; UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:9249,Testability,Test,TestBit,9249," Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchSTL(); TBranchSTL(const TBranchSTL&); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:9288,Testability,Test,TestBits,9288," Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBranchSTL(); TBranchSTL(const TBranchSTL&); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTBranch::UpdateAddress(); virtual voidTBranch::UpdateFile(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBranchSTL.html:857,Usability,Clear,Clear,857," virtual~TBranchSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch",MatchSource.WIKI,root/html602/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBranchSTL.html
https://root.cern/root/html602/TBRIK.html:1504,Availability,Error,Error,1504," virtual~TBRIK(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObjec",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:1633,Availability,error,error,1633,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_t",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:1717,Availability,error,error,1717,"ion = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) c",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:3119,Modifiability,Inherit,InheritsFrom,3119,"ect::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); ",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:3185,Modifiability,Inherit,InheritsFrom,3185,"loat_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator ne",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:8551,Modifiability,Inherit,Inheritance,8551,"TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tfDxhalf length in x; Float_tfDyhalf length in y; Float_tfDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTShape::fNumberShape number; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBRIK(); BRIK shape default constructor. TBRIK(const char* name, const char* title, const char* material, Float_t dx, Float_t dy, Float_t dz); BRIK shape normal constructor. ~TBRIK(); BRIK shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a BRIK. Compute the closest distance of approach from point px,py to each corner; point of the BRIK. void SetPoints(Double_t* points) const; Create BRIK points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3D. TBRIK(). Float_t GetDx() const; {return fDx;}. Float_t GetDy() const; {return fDy;}. Float_t GetDz() const; {return fDz;}.  Author: Nenad Buncic 17/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/g3d:$Id$  Last generated: 2015-06-30 14:39; This page has been automatically generated. F",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:8564,Modifiability,Inherit,Inherited,8564,"TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tfDxhalf length in x; Float_tfDyhalf length in y; Float_tfDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTShape::fNumberShape number; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBRIK(); BRIK shape default constructor. TBRIK(const char* name, const char* title, const char* material, Float_t dx, Float_t dy, Float_t dz); BRIK shape normal constructor. ~TBRIK(); BRIK shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a BRIK. Compute the closest distance of approach from point px,py to each corner; point of the BRIK. void SetPoints(Double_t* points) const; Create BRIK points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3D. TBRIK(). Float_t GetDx() const; {return fDx;}. Float_t GetDy() const; {return fDy;}. Float_t GetDz() const; {return fDz;}.  Author: Nenad Buncic 17/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/g3d:$Id$  Last generated: 2015-06-30 14:39; This page has been automatically generated. F",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:3009,Security,Hash,Hash,3009,"ect(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delet",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:6480,Testability,Test,TestBit,6480,"nt_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBRIK(); TBRIK(const TBRIK&); TBRIK(const char* name, const char* title, const char* material, Float_t dx, Float_t dy, Float_t dz); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:6519,Testability,Test,TestBits,6519,"nt_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBRIK(); TBRIK(const TBRIK&); TBRIK(const char* name, const char* title, const char* material, Float_t dx, Float_t dy, Float_t dz); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBRIK.html:863,Usability,Clear,Clear,863," virtual~TBRIK(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObjec",MatchSource.WIKI,root/html602/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBRIK.html
https://root.cern/root/html602/TBrowser.html:1872,Availability,Error,Error,1872," obj, TClass* cl, const char* name = 0, Int_t check = -1); voidAddCheckBox(TObject* obj, Bool_t check = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBrowseObject(TObject* obj); voidCheckObjectItem(TObject* obj, Bool_t check = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDestructor(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; st",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:2119,Availability,error,error,2119,"heckObjectItem(TObject* obj, Bool_t check = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDestructor(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTOb",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:2203,Availability,error,error,2203,"const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDestructor(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIconify()",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:9024,Integrability,depend,depending,9024,"Browser::(anonymous)kNoHidden; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TContextMenu*fContextMenu!Context menu pointer; TBrowserImp*fImp!Window system specific browser implementation; TStringTNamed::fNameobject identifier; Bool_tfNeedRefreshTrue if the browser needs refresh; TBrowserTimer*fTimer!Browser's timer; TStringTNamed::fTitleobject title. private:. TObject*fLastSelectedObject!The last TObject selected by user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title. Width and height are by; default set to 640x400 and (optionally) adjusted by the screen factor; (depending on Rint.Canvas.UseScreenFactor to be true or false, default; is true). TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, width and height. TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, position, width and height. TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObject* obj, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObject* obj, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """,MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:3304,Modifiability,Inherit,InheritsFrom,3304,", Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:3370,Modifiability,Inherit,InheritsFrom,3370,"char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); vi",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:8681,Modifiability,Inherit,Inheritance,8681,"Object::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TBrowser::(anonymous)kNoHidden; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TContextMenu*fContextMenu!Context menu pointer; TBrowserImp*fImp!Window system specific browser implementation; TStringTNamed::fNameobject identifier; Bool_tfNeedRefreshTrue if the browser needs refresh; TBrowserTimer*fTimer!Browser's timer; TStringTNamed::fTitleobject title. private:. TObject*fLastSelectedObject!The last TObject selected by user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title. Width and height are by; default set to 640x400 and (optionally) adjusted by the screen factor; (depending on Rint.Canvas.UseScreenFactor to be true or false, default; is true). TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, width and height. TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, position, width and height. TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObjec",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:8694,Modifiability,Inherit,Inherited,8694,"Object::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TBrowser::(anonymous)kNoHidden; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TContextMenu*fContextMenu!Context menu pointer; TBrowserImp*fImp!Window system specific browser implementation; TStringTNamed::fNameobject identifier; Bool_tfNeedRefreshTrue if the browser needs refresh; TBrowserTimer*fTimer!Browser's timer; TStringTNamed::fTitleobject title. private:. TObject*fLastSelectedObject!The last TObject selected by user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title. Width and height are by; default set to 640x400 and (optionally) adjusted by the screen factor; (depending on Rint.Canvas.UseScreenFactor to be true or false, default; is true). TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, width and height. TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, position, width and height. TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObjec",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:3179,Security,Hash,Hash,3179,"Array* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz);",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:6938,Testability,Test,TestBit,6938,"dTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; voidStartEmbedding(Int_t pos, Int_t subpos); voidStopEmbedding(const char* name = """"); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname = """", const char* title = ""ROOT Foreign Browser"", Option_t* opt = """"); TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:6977,Testability,Test,TestBits,6977,"dTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; voidStartEmbedding(Int_t pos, Int_t subpos); voidStopEmbedding(const char* name = """"); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname = """", const char* title = ""ROOT Foreign Browser"", Option_t* opt = """"); TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); TBrowser(const char* name, TObject* obj, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowser(const char* name, void* obj, TClass* cl, const char* objname, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowser.html:1265,Usability,Clear,Clear,1265," virtual~TBrowser(); voidTObject::AbstractMethod(const char* method) const; voidAdd(TObject* obj, const char* name = 0, Int_t check = -1); voidAdd(void* obj, TClass* cl, const char* name = 0, Int_t check = -1); voidAddCheckBox(TObject* obj, Bool_t check = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBrowseObject(TObject* obj); voidCheckObjectItem(TObject* obj, Bool_t check = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDestructor(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cm",MatchSource.WIKI,root/html602/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowser.html
https://root.cern/root/html602/TBrowserImp.html:345,Integrability,protocol,protocol,345,". TBrowserImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TBrowserImp. class TBrowserImp. TBrowserImp. ABC describing GUI independent browser implementation protocol. Function Members (Methods); public:. virtual~TBrowserImp(); virtual voidAdd(TObject*, const char*, Int_t); virtual voidAddCheckBox(TObject*, Bool_t = kFALSE); virtual voidBrowseObj(TObject*); TBrowser*Browser() const; virtual voidCheckObjectItem(TObject*, Bool_t = kFALSE); static TClass*Class(); virtual voidCloseTabs(); virtual Long_tExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidExecuteDefaultAction(TObject*); virtual TBrowser*GetBrowser() const; virtual Option_t*GetDrawOption() const; virtual TGMainFrame*GetMainFrame() const; virtual voidIconify(); virtual TClass*IsA() const; virtual voidRecursiveRemove(TObject*); virtual voidRefresh(Bool_t = kFALSE); virtual voidRemoveCheckBox(TObject*); virtual voidSetBrowser(TBrowser* b); virtual voidSetDrawOption(Option_t* option = """"); virtual voidSetStatusText(const char*, Int_t); virtual voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartEmbedding(Int_t, Int_t); virtual voidStopEmbedding(const char*); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBrowserImp(TBrowser* b = 0); TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"). protected:. TBrowserImp&operator=(const TBrowserImp& br); TBrowserImp(const TBrowserImp& br). Data Members; protected:. TBrowser*fBrowserTBrowser associated with this implementation; Bool_tfShowCyclesShow object cycle numbers in browser. Class Charts. Inheritance; Inherited Members; Includes; Lib",MatchSource.WIKI,root/html602/TBrowserImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserImp.html
https://root.cern/root/html602/TBrowserImp.html:1956,Modifiability,Inherit,Inheritance,1956,"dRecursiveRemove(TObject*); virtual voidRefresh(Bool_t = kFALSE); virtual voidRemoveCheckBox(TObject*); virtual voidSetBrowser(TBrowser* b); virtual voidSetDrawOption(Option_t* option = """"); virtual voidSetStatusText(const char*, Int_t); virtual voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartEmbedding(Int_t, Int_t); virtual voidStopEmbedding(const char*); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBrowserImp(TBrowser* b = 0); TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"). protected:. TBrowserImp&operator=(const TBrowserImp& br); TBrowserImp(const TBrowserImp& br). Data Members; protected:. TBrowser*fBrowserTBrowser associated with this implementation; Bool_tfShowCyclesShow object cycle numbers in browser. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDrawOption(Option_t* option = """"); {}. inline TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); { }. inline TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); { }. TBrowserImp(const TBrowserImp& br); { }. TBrowserImp& operator=(const TBrowserImp& br). TBrowserImp(TBrowser* b = 0); { }. virtual ~TBrowserImp(); { }. void Add(TObject* , const char* , Int_t ); { }. void AddCheckBox(TObject* , Bool_t = kFALSE); { }. void CheckObjectItem(TObject* , Bool_t = kFALSE); { }. void RemoveCheckBox(TObject* ); { }. void BrowseObj(TObject* ); { }. void CloseTabs(); { }. void ExecuteDefaultAction(TObject* ); { }. void Iconify(); { }. void RecursiveRemove(TObject* ); { }. void Refresh(Bool_t = kFALSE); { }. void Show(); { }. Option_t * GetDrawOption() const; { return 0; }. Long_t ExecPlugin(const char* , const char* , const char* , Int_t , I",MatchSource.WIKI,root/html602/TBrowserImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserImp.html
https://root.cern/root/html602/TBrowserImp.html:1969,Modifiability,Inherit,Inherited,1969,"dRecursiveRemove(TObject*); virtual voidRefresh(Bool_t = kFALSE); virtual voidRemoveCheckBox(TObject*); virtual voidSetBrowser(TBrowser* b); virtual voidSetDrawOption(Option_t* option = """"); virtual voidSetStatusText(const char*, Int_t); virtual voidShow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartEmbedding(Int_t, Int_t); virtual voidStopEmbedding(const char*); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBrowserImp(TBrowser* b = 0); TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"). protected:. TBrowserImp&operator=(const TBrowserImp& br); TBrowserImp(const TBrowserImp& br). Data Members; protected:. TBrowser*fBrowserTBrowser associated with this implementation; Bool_tfShowCyclesShow object cycle numbers in browser. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDrawOption(Option_t* option = """"); {}. inline TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); { }. inline TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); { }. TBrowserImp(const TBrowserImp& br); { }. TBrowserImp& operator=(const TBrowserImp& br). TBrowserImp(TBrowser* b = 0); { }. virtual ~TBrowserImp(); { }. void Add(TObject* , const char* , Int_t ); { }. void AddCheckBox(TObject* , Bool_t = kFALSE); { }. void CheckObjectItem(TObject* , Bool_t = kFALSE); { }. void RemoveCheckBox(TObject* ); { }. void BrowseObj(TObject* ); { }. void CloseTabs(); { }. void ExecuteDefaultAction(TObject* ); { }. void Iconify(); { }. void RecursiveRemove(TObject* ); { }. void Refresh(Bool_t = kFALSE); { }. void Show(); { }. Option_t * GetDrawOption() const; { return 0; }. Long_t ExecPlugin(const char* , const char* , const char* , Int_t , I",MatchSource.WIKI,root/html602/TBrowserImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserImp.html
https://root.cern/root/html602/TBrowserPlugin.html:1487,Availability,avail,available,1487,"= 0, Int_t pos = kRight,; Int_t subpos = -1); allowing to select plugins (can be a macro or a command); to be executed, and where to embed the frame created by; the plugin (tab and tab element). Examples:. create a new browser:; TBrowser b;. create a new TCanvas in a new top right tab element:; b.ExecPlugin(""Canvas"", 0, ""new TCanvas()"");. create a new top right tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"");. create a new bottom tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"", 0, TRootBrowser::kBottom);. this browser implementation can be selected via the env; 'Browser.Name' in .rootrc, (TRootBrowser or TRootBrowserLite); the default being TRootBrowserLite (old browser); a list of options (plugins) for the new TRootBrowser is also; specified via the env 'Browser.Options' in .rootrc, the default; being: FECI; Here is the list of available options:; F: File browser E: Text Editor H: HTML browser C: Canvas I: I/O; redirection P: Proof G: GL viewer. Function Members (Methods); public:. virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual void",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:2455,Availability,Error,Error,2455," virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:2584,Availability,error,error,2584," virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:2668,Availability,error,error,2668,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:584,Modifiability,plugin,plugins,584,". TBrowserPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TBrowserPlugin. class TBrowserPlugin: public TNamed. TRootBrowser. This class creates a ROOT object browser, constitued by three main; tabs. All tabs can 'swallow' frames, thanks to the new method:; ExecPlugin(const char *name = 0, const char *fname = 0,; const char *cmd = 0, Int_t pos = kRight,; Int_t subpos = -1); allowing to select plugins (can be a macro or a command); to be executed, and where to embed the frame created by; the plugin (tab and tab element). Examples:. create a new browser:; TBrowser b;. create a new TCanvas in a new top right tab element:; b.ExecPlugin(""Canvas"", 0, ""new TCanvas()"");. create a new top right tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"");. create a new bottom tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"", 0, TRootBrowser::kBottom);. this browser implementation can be selected via the env; 'Browser.Name' in .rootrc, (TRootBrowser or TRootBrowserLite); the default being TRootBrowserLite (old browser); a list of options (plugins) for the new TRootBrowser is also; specified via the env 'Browser.Options' in .rootrc, the default; being: FECI; Here is the list of available options:; F: File browser E: Text Editor H: HTML browser C: Canvas I: I/O; redirection P: Proof G: GL viewer. Function Members (Methods); public:. virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:684,Modifiability,plugin,plugin,684,". TBrowserPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TBrowserPlugin. class TBrowserPlugin: public TNamed. TRootBrowser. This class creates a ROOT object browser, constitued by three main; tabs. All tabs can 'swallow' frames, thanks to the new method:; ExecPlugin(const char *name = 0, const char *fname = 0,; const char *cmd = 0, Int_t pos = kRight,; Int_t subpos = -1); allowing to select plugins (can be a macro or a command); to be executed, and where to embed the frame created by; the plugin (tab and tab element). Examples:. create a new browser:; TBrowser b;. create a new TCanvas in a new top right tab element:; b.ExecPlugin(""Canvas"", 0, ""new TCanvas()"");. create a new top right tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"");. create a new bottom tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"", 0, TRootBrowser::kBottom);. this browser implementation can be selected via the env; 'Browser.Name' in .rootrc, (TRootBrowser or TRootBrowserLite); the default being TRootBrowserLite (old browser); a list of options (plugins) for the new TRootBrowser is also; specified via the env 'Browser.Options' in .rootrc, the default; being: FECI; Here is the list of available options:; F: File browser E: Text Editor H: HTML browser C: Canvas I: I/O; redirection P: Proof G: GL viewer. Function Members (Methods); public:. virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:1346,Modifiability,plugin,plugins,1346,"reates a ROOT object browser, constitued by three main; tabs. All tabs can 'swallow' frames, thanks to the new method:; ExecPlugin(const char *name = 0, const char *fname = 0,; const char *cmd = 0, Int_t pos = kRight,; Int_t subpos = -1); allowing to select plugins (can be a macro or a command); to be executed, and where to embed the frame created by; the plugin (tab and tab element). Examples:. create a new browser:; TBrowser b;. create a new TCanvas in a new top right tab element:; b.ExecPlugin(""Canvas"", 0, ""new TCanvas()"");. create a new top right tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"");. create a new bottom tab element embedding the; TGMainFrame created by the macro 'myMacro.C':; b.ExecPlugin(""MyPlugin"", ""myMacro.C"", 0, TRootBrowser::kBottom);. this browser implementation can be selected via the env; 'Browser.Name' in .rootrc, (TRootBrowser or TRootBrowserLite); the default being TRootBrowserLite (old browser); a list of options (plugins) for the new TRootBrowser is also; specified via the env 'Browser.Options' in .rootrc, the default; being: FECI; Here is the list of available options:; F: File browser E: Text Editor H: HTML browser C: Canvas I: I/O; redirection P: Proof G: GL viewer. Function Members (Methods); public:. virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; vir",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:3592,Modifiability,Inherit,InheritsFrom,3592,"rtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:3658,Modifiability,Inherit,InheritsFrom,3658,"_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBrowserPlugin&operator=(const TBrowserPlugin&); virt",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:7478,Modifiability,Inherit,Inheritance,7478,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. TStringfCommandCommand to be executed; Int_tfSubTabTab element number; Int_tfTabTab number; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); { }. virtual ~TBrowserPlugin(); {}. void SetTab(Int_t tab); { fTab = tab; }. void SetSubTab(Int_t sub); { fSubTab = sub; }. void SetCommand(const char* cmd); { fCommand = cmd; }. TRootBrowser& operator=(const TBrowserPlugin& ).  Author: Bertrand Bellenot 26/09/2007  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: 7cf312b9bc9940a03d7c0cee95eea0085dc9898c $  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:7491,Modifiability,Inherit,Inherited,7491,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. TStringfCommandCommand to be executed; Int_tfSubTabTab element number; Int_tfTabTab number; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); { }. virtual ~TBrowserPlugin(); {}. void SetTab(Int_t tab); { fTab = tab; }. void SetSubTab(Int_t sub); { fSubTab = sub; }. void SetCommand(const char* cmd); { fCommand = cmd; }. TRootBrowser& operator=(const TBrowserPlugin& ).  Author: Bertrand Bellenot 26/09/2007  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: 7cf312b9bc9940a03d7c0cee95eea0085dc9898c $  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:3482,Security,Hash,Hash,3482,"st char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:6032,Testability,Test,TestBit,6032,"perator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBrowserPlugin&operator=(const TBrowserPlugin&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCommand(const char* cmd); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetSubTab(Int_t sub); voidSetTab(Int_t tab); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBrowserPlugin(const TBrowserPlugin&); TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:6071,Testability,Test,TestBits,6071,"perator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBrowserPlugin&operator=(const TBrowserPlugin&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCommand(const char* cmd); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetSubTab(Int_t sub); voidSetTab(Int_t tab); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBrowserPlugin(const TBrowserPlugin&); TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBrowserPlugin.html:1912,Usability,Clear,Clear,1912," virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") con",MatchSource.WIKI,root/html602/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBrowserPlugin.html
https://root.cern/root/html602/TBtree.html:9204,Availability,Error,Error,9204,"nt_t idx) const; virtual TObject*Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) cons",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:9333,Availability,error,error,9333,"se(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const;",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:9417,Availability,error,error,9417,"const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() ",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:504,Energy Efficiency,adapt,adapt,504,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:3813,Energy Efficiency,allocate,allocated,3813,"d here. However,; if the order is kept small (< 6?) any inefficiency is negligible for; in-memory sorting. Knuth points out that balanced trees are actually; preferable for memory sorting. I'm not sure that I believe this, but; it's interesting. Also, deleting elements from balanced binary trees, being; beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees; are good enough. A B-tree is declared to be of a certain ORDER (3 by default). This number; determines the number of keys contained in any interior node of the tree.; Each interior node will contain ORDER keys, and therefore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array of pointers and keys is allocated as ORDER+1; pairs of keys and nodes, meaning that one key field (key[0]) is not used; and therefore wasted. Given that the number of interior nodes is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (ea",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:4435,Energy Efficiency,allocate,allocate,4435,"efore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array of pointers and keys is allocated as ORDER+1; pairs of keys and nodes, meaning that one key field (key[0]) is not used; and therefore wasted. Given that the number of interior nodes is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (each tree at run-time can be of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; P",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:315,Modifiability,inherit,inherits,315,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:504,Modifiability,adapt,adapt,504,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:636,Modifiability,enhance,enhancement,636,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:990,Modifiability,enhance,enhancement,990,"omepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. InnerLowWaterMark = ceiling(Or",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:4908,Modifiability,variab,variable,4908,"des is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (each tree at run-time can be of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element h",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:5037,Modifiability,variab,variable,5037," nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (each tree at run-time can be of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element has (physical) index 0 in the array,; and in LeafNodes, the hidden element has (virtual) index -1 in the array.; Therefore, there are two 'size' primitives for nodes:; >; Psize - the physical size: how many elements are contained in the; array in the node",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:10733,Modifiability,Inherit,InheritsFrom,10733,"Collect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tTSeqCollection::IndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; virtual Bool_tTCollection::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*Last() const; Int_tTSeqCollection::LastIndex() const; virtual voidTCollection::ls(Option_t* option = """") const; virtual TIterator*MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*TCollection::MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; Long64_tTSeqCollection::Merge(TCollection* list); virtual Bool_tTObject::Not",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:10799,Modifiability,Inherit,InheritsFrom,10799,"ollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tTSeqCollection::IndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; virtual Bool_tTCollection::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*Last() const; Int_tTSeqCollection::LastIndex() const; virtual voidTCollection::ls(Option_t* option = """") const; virtual TIterator*MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*TCollection::MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; Long64_tTSeqCollection::Merge(TCollection* list); virtual Bool_tTObject::Notify(); static Int_tTSeqCollection::ObjCompare(TObject* a, TObject*",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:16963,Modifiability,Inherit,Inheritance,16963,"Referenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()). Requires sequential; search of complete tree till object is found. TObject * FindObject(const TObject* obj) const; Find object using the objects Compare() member function. Int_t IdxAdd(const TObj",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:16976,Modifiability,Inherit,Inherited,16976,"Referenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()). Requires sequential; search of complete tree till object is found. TObject * FindObject(const TObject* obj) const; Find object using the objects Compare() member function. Int_t IdxAdd(const TObj",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:5862,Performance,perform,perform,5862,"e of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element has (physical) index 0 in the array,; and in LeafNodes, the hidden element has (virtual) index -1 in the array.; Therefore, there are two 'size' primitives for nodes:; >; Psize - the physical size: how many elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - mo",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:2774,Security,access,access,2774,"ains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. InnerLowWaterMark = ceiling(Order/2); LeafLowWaterMark = Order - 1. If the tree is only filled, then all the nodes will be at least 2/3 full.; They will almost all be exactly 2/3 full if the elements are added to the; tree in order (either increasing or decreasing). [Knuth says McCreight's; experiments showed almost 100% memory utilization. I don't see how that; can be given the algorithms that Knuth gives. McCreight must have used; a different scheme for balancing. [No, he used a different scheme for; splitting: he did a two-way split instead of the three way split as we do; here. Which means that McCreight does better on insertion of ordered data,; but we should do better on insertion of random data.]]. It must also be noted that B-trees were designed for DISK access algorithms,; not necessarily in-memory sorting, as we intend it to be used here. However,; if the order is kept small (< 6?) any inefficiency is negligible for; in-memory sorting. Knuth points out that balanced trees are actually; preferable for memory sorting. I'm not sure that I believe this, but; it's interesting. Also, deleting elements from balanced binary trees, being; beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees; are good enough. A B-tree is declared to be of a certain ORDER (3 by default). This number; determines the number of keys contained in any interior node of the tree.; Each interior node will contain ORDER keys, and therefore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:7205,Security,access,access,7205,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TCla",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:10559,Security,Hash,Hash,10559,"t) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tTSeqCollection::IndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; virtual Bool_tTCollection::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*Last() const; Int_tTSeqCollection::LastIndex() const; virtual voidTCollection::ls(Option_t* option = """") const; virtual TIterator*MakeIterator(Bool_t dir = kIterForward) const; virtual ",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:16905,Security,access,access,16905,"lection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()).",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:7198,Testability,log,log,7198,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TCla",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:8156,Testability,Assert,AssertClass,8156,,MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:14545,Testability,Test,TestBit,14545,"ject** b, Int_t first, Int_t last); static voidTSeqCollection::QSort(TObject** a, Int_t nBs, TObject*** b, Int_t first, Int_t last); Int_tRank(const TObject* obj) const; virtual Int_tTObject::Read(const char* name); virtual voidTCollection::RecursiveRemove(TObject* obj); virtual TObject*Remove(TObject* obj); virtual voidTSeqCollection::RemoveAfter(TObject* after); voidTCollection::RemoveAll(); virtual voidTCollection::RemoveAll(TCollection* col); virtual TObject*TSeqCollection::RemoveAt(Int_t idx); virtual voidTSeqCollection::RemoveBefore(TObject* before); virtual voidTSeqCollection::RemoveFirst(); virtual voidTSeqCollection::RemoveLast(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTCollection::SetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTCollection::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTCollection::SetOwner(Bool_t enable = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; static voidTCollection::StartGarbageCollection(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBtree(Int_t ordern = 3); TBtree(const TBtree&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTSeqCollection::UnSort(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:14584,Testability,Test,TestBits,14584,"ject** b, Int_t first, Int_t last); static voidTSeqCollection::QSort(TObject** a, Int_t nBs, TObject*** b, Int_t first, Int_t last); Int_tRank(const TObject* obj) const; virtual Int_tTObject::Read(const char* name); virtual voidTCollection::RecursiveRemove(TObject* obj); virtual TObject*Remove(TObject* obj); virtual voidTSeqCollection::RemoveAfter(TObject* after); voidTCollection::RemoveAll(); virtual voidTCollection::RemoveAll(TCollection* col); virtual TObject*TSeqCollection::RemoveAt(Int_t idx); virtual voidTSeqCollection::RemoveBefore(TObject* before); virtual voidTSeqCollection::RemoveFirst(); virtual voidTSeqCollection::RemoveLast(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTCollection::SetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTCollection::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTCollection::SetOwner(Bool_t enable = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; static voidTCollection::StartGarbageCollection(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBtree(Int_t ordern = 3); TBtree(const TBtree&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTSeqCollection::UnSort(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtree.html:17453,Usability,Clear,Clear,17453,"er of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()). Requires sequential; search of complete tree till object is found. TObject * FindObject(const TObject* obj) const; Find object using the objects Compare() member function. Int_t IdxAdd(const TObject& obj); Add object and return its index in the tree. void Init(Int_t i); Initialize a B-tree. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a B-tree iterator. Int_t Rank(const TObject* obj) const; Returns the rank of the object in the tree. TObject * Remove(TObject* obj); Remove an object from the tree. void RootIsFull(); The root of the tree is full. Create an InnerNode that; points to it, and then inform the InnerNode that it is full. void RootIsEmpty(); If root",MatchSource.WIKI,root/html602/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtree.html
https://root.cern/root/html602/TBtreeIter.html:1450,Modifiability,Inherit,Inheritance,1450,"tatic TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator& aIter) const; Bool_toperator!=(const TBtreeIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TBtreeIter&operator=(const TBtreeIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBtreeIter(const TBtreeIter& iter); TBtreeIter(const TBtree* t, Bool_t dir = kIterForward). private:. TBtreeIter(). Data Members; private:. Int_tfCurCursorcurrent position in btree; Int_tfCursornext position in btree; Bool_tfDirectioniteration direction; const TBtree*fTreebtree being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtreeIter(const TBtree* t, Bool_t dir = kIterForward); Create a B-tree iterator. TBtreeIter(const TBtreeIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. TBtreeIter & operator=(const TBtreeIter& rhs); Overloaded assignment operator. void Reset(); Reset the B-tree iterator. TObject * Next(); Get next object from B-tree. Returns 0 when no more objects in tree. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const TBtreeIter& aIter) const; This operator compares two TBtreeIter objects. TObject* operator*() const; Return current object or nullptr. TBtreeIter(); { }. ~TBtreeIter(); { }. const TCollection * GetCollection() const; { return fTree; }.  Author: Fons Rademakers 10/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 2015-06-30 14:40; This page has been",MatchSource.WIKI,root/html602/TBtreeIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtreeIter.html
https://root.cern/root/html602/TBtreeIter.html:1463,Modifiability,Inherit,Inherited,1463,"tatic TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator& aIter) const; Bool_toperator!=(const TBtreeIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TBtreeIter&operator=(const TBtreeIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TBtreeIter(const TBtreeIter& iter); TBtreeIter(const TBtree* t, Bool_t dir = kIterForward). private:. TBtreeIter(). Data Members; private:. Int_tfCurCursorcurrent position in btree; Int_tfCursornext position in btree; Bool_tfDirectioniteration direction; const TBtree*fTreebtree being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtreeIter(const TBtree* t, Bool_t dir = kIterForward); Create a B-tree iterator. TBtreeIter(const TBtreeIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. TBtreeIter & operator=(const TBtreeIter& rhs); Overloaded assignment operator. void Reset(); Reset the B-tree iterator. TObject * Next(); Get next object from B-tree. Returns 0 when no more objects in tree. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const TBtreeIter& aIter) const; This operator compares two TBtreeIter objects. TObject* operator*() const; Return current object or nullptr. TBtreeIter(); { }. ~TBtreeIter(); { }. const TCollection * GetCollection() const; { return fTree; }.  Author: Fons Rademakers 10/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 2015-06-30 14:40; This page has been",MatchSource.WIKI,root/html602/TBtreeIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBtreeIter.html
https://root.cern/root/html602/TBuffer.html:473,Availability,avail,available,473,". TBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TBuffer. class TBuffer: public TObject. TBuffer. Buffer base class used for serializing objects. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TBuffer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidAutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*Buffer() const; Int_tBufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject:",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:2269,Availability,Error,Error,2269,"ssname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tGetBufferVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInf",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:2398,Availability,error,error,2398,"c TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tGetBufferVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObjec",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:2482,Availability,error,error,2482,"dClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tGetBufferVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetN",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:18561,Availability,error,error,18561,"cCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer ",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:19615,Availability,error,error,19615,"attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass()",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:20005,Availability,down,down,20005,"icy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members.",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:18531,Integrability,rout,routine,18531,"cCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer ",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:19585,Integrability,rout,routine,19585,"attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass()",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:4150,Modifiability,Inherit,InheritsFrom,4150,"c Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tGetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsWriting() const; Bool_tTObject::IsZombie() const; Int_tLength() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:4216,Modifiability,Inherit,InheritsFrom,4216,"nName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tGetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsWriting() const; Bool_tTObject::IsZombie() const; Int_tLength() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp)",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:17599,Modifiability,extend,extending,17599,"ick; static TObject::EStatusBitsTObject::kHasUUID; static TBuffer::(anonymous)kInitialSize; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TBuffer::(anonymous)kIsOwner; static TObject::EStatusBitsTObject::kIsReferenced; static TBuffer::(anonymous)kMinimalSize; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModekRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModekWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; TBuffer::CacheList_tfCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf arg",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:17672,Modifiability,Inherit,Inheritance,17672,"nonymous)kMinimalSize; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModekRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModekWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; TBuffer::CacheList_tfCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Auto",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:17685,Modifiability,Inherit,Inherited,17685,"nonymous)kMinimalSize; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModekRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModekWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; TBuffer::CacheList_tfCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Auto",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:17375,Performance,cache,cache,17375,"ick; static TObject::EStatusBitsTObject::kHasUUID; static TBuffer::(anonymous)kInitialSize; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TBuffer::(anonymous)kIsOwner; static TObject::EStatusBitsTObject::kIsReferenced; static TBuffer::(anonymous)kMinimalSize; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModekRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModekWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; TBuffer::CacheList_tfCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer(EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf arg",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:20876,Performance,cache,cache,20876," out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TBuffer(); Default ctor. {}. TBuffer(const TBuffer& ); TBuffer objects cannot be copied or assigned. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:21032,Performance,cache,cache,21032,"etParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TBuffer(); Default ctor. {}. TBuffer(const TBuffer& ); TBuffer objects cannot be copied or assigned. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() const; { return fBufSize; }. void DetachBuffer(); { f",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:21189,Performance,cache,cache,21189," const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TBuffer(); Default ctor. {}. TBuffer(const TBuffer& ); TBuffer objects cannot be copied or assigned. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() const; { return fBufSize; }. void DetachBuffer(); { fBuffer = 0; }. Int_t Length() const; { return (Int_t)(fBufCur - fBuffer); }. Bool_t CheckObject(const TObject* obj). Bool_t CheckObject(const void* obj, cons",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:18871,Safety,avoid,avoiding,18871,"Buffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:19912,Safety,avoid,avoid,19912,"icy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members.",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:3984,Security,Hash,Hash,3984,"rVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tGetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsWriting() const; Bool_tTObject::IsZombie() const; Int_tLength() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const ch",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:12376,Testability,Test,TestBit,12376," Int_t comp_type); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetWriteMode(); virtual voidSetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); TBuffer(TBuffer::EMode mode); TBuffer(TBuffer::EMode mode, Int_t bufsiz); TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:12415,Testability,Test,TestBits,12415,":SetUniqueID(UInt_t uid); voidSetWriteMode(); virtual voidSetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); TBuffer(TBuffer::EMode mode); TBuffer(TBuffer::EMode mode, Int_t bufsiz); TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer.html:1658,Usability,Clear,Clear,1658,"e(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidAutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*Buffer() const; Int_tBufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, cons",MatchSource.WIKI,root/html602/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer.html
https://root.cern/root/html602/TBuffer3D.html:9911,Availability,Error,Error,9911,,MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:10040,Availability,error,error,10040,,MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:10124,Availability,error,error,10124,"t; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearSectionsValid(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static UInt_tDecCSLevel(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classnam",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:10781,Availability,mask,mask,10781,"tual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; UInt_tNbPnts() const; UInt_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:12639,Availability,mask,mask,12639,"_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Bool_tTObject::TestBit(UInt_t f) const; ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:13158,Availability,mask,mask,13158,"vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tType() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:17777,Availability,mask,mask,17777,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }.  Author: Olivier Couet 05/05/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TBuffer3D.h,v 1.00  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:17823,Availability,mask,mask,17823,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }.  Author: Olivier Couet 05/05/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TBuffer3D.h,v 1.00  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:17867,Availability,mask,mask,17867,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }.  Author: Olivier Couet 05/05/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TBuffer3D.h,v 1.00  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:17911,Availability,mask,mask,17911,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }.  Author: Olivier Couet 05/05/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TBuffer3D.h,v 1.00  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:17920,Availability,mask,mask,17920,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }.  Author: Olivier Couet 05/05/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TBuffer3D.h,v 1.00  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:17956,Availability,mask,mask,17956,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }.  Author: Olivier Couet 05/05/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TBuffer3D.h,v 1.00  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:18000,Availability,mask,mask,18000,"herited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }.  Author: Olivier Couet 05/05/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TBuffer3D.h,v 1.00  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:8261,Energy Efficiency,efficient,efficient,8261,"s required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:464,Integrability,interface,interface,464,". TBuffer3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this b",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5699,Integrability,interface,interface,5699,"is object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicatin",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:11094,Modifiability,Inherit,InheritsFrom,11094,"bjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; UInt_tNbPnts() const; UInt_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObjec",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:11160,Modifiability,Inherit,InheritsFrom,11160,"ent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; UInt_tNbPnts() const; UInt_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:16517,Modifiability,Inherit,Inheritance,16517,"::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TBuffer3D::ESectionkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer3D::ESectionkRaw; static TBuffer3D::ESectionkRawSizes; static TBuffer3D::ESectionkShapeSpecific; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. UInt_tfNbPntsNumber of points describing the shape; UInt_tfNbPolsNumber of polygons describing the shape; UInt_tfNbSegsNumber of segments describing the shape; UInt_tfPntsCapacityCurrent capacity of fPnts space; UInt_tfPolsCapacityCurrent capacity of fSegs space; UInt_tfSectionsSection validity flags; UInt_tfSegsCapacityCurrent capacity of fSegs space; const Int_tfTypePrimitive type - predefined ones in TBuffer3DTypes.h; static UInt_tfgCSLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetC",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:16530,Modifiability,Inherit,Inherited,16530,"::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TBuffer3D::ESectionkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer3D::ESectionkRaw; static TBuffer3D::ESectionkRawSizes; static TBuffer3D::ESectionkShapeSpecific; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. UInt_tfNbPntsNumber of points describing the shape; UInt_tfNbPolsNumber of polygons describing the shape; UInt_tfNbSegsNumber of segments describing the shape; UInt_tfPntsCapacityCurrent capacity of fPnts space; UInt_tfPolsCapacityCurrent capacity of fSegs space; UInt_tfSectionsSection validity flags; UInt_tfSegsCapacityCurrent capacity of fSegs space; const Int_tfTypePrimitive type - predefined ones in TBuffer3DTypes.h; static UInt_tfgCSLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetC",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:821,Performance,perform,performance,821,". TBuffer3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this b",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:1627,Performance,perform,performance,1627,"ire a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) AddObject(); will return flags indicating which ones, otherwise it returns kNone. You must; fill the buffer and mark these sections valid, and pass the buffer again. A; typical code snippet would be:; TBuffer3DSphere sphereBuffer;; Fill out kCore...; Fill out kBoundingBox...; Fill out kShapeSpecific for TBuffer3DSphere; Try first add to viewer; Int_t reqSections = viewer->AddObject(buffer);; if (reqSections != TBuffer3D::kNone) {; if (reqSections & TBuffer3D::kRawSizes) {",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5315,Performance,cache,cached,5315,"er (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5414,Performance,perform,perform,5414,"n matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5469,Performance,perform,performance,5469,"n matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:6544,Performance,cache,cached,6544,"ly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publish",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:8283,Performance,cache,cache,8283,"and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """");",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:7726,Safety,detect,detect,7726," drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); ",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:10959,Security,Hash,Hash,10959,"t; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; UInt_tNbPnts() const; UInt_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:1169,Testability,test,test,1169,"e. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:4695,Testability,Log,Logical,4695,"do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocal",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:4884,Testability,log,logical,4884,"tated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For v",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5071,Testability,log,logical,5071,"o provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalM",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5193,Testability,log,logical,5193,"on of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be cap",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5221,Testability,log,logical,5221,"on of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be cap",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5536,Testability,log,logical,5536,"d contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; s",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5907,Testability,log,logical,5907,"re we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:5984,Testability,log,logical,5984,"re we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:7146,Testability,log,logical,7146,"s, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(T",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:8033,Testability,log,logical,8033," viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:8294,Testability,log,logical,8294,"and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """");",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:13617,Testability,Test,TestBit,13617,"vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tType() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:13656,Testability,Test,TestBits,13656,"vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tType() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:1114,Usability,Clear,ClearSectionsValid,1114,"e. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:1178,Usability,clear,clear,1178,"e. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:3422,Usability,clear,clear,3422,"apeSpecific for TBuffer3DSphere; Try first add to viewer; Int_t reqSections = viewer->AddObject(buffer);; if (reqSections != TBuffer3D::kNone) {; if (reqSections & TBuffer3D::kRawSizes) {; Fill out kRawSizes...; }; if (reqSections & TBuffer3D::kRaw) {; Fill out kRaw...; }; Add second time to viewer - ignore return cannot do more; viewer->AddObject(buffer);; }; }>; ShapeSpecific: If the viewer can directly display the buffer without; filling of the kRaw/kRawSizes section it will not need to request client side; tessellation.; Currently we provide the following various shape specific classes, which the; OpenGL viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. *OpenGL only supports solid spheres at present - cut/hollow ones will be; requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the; viewers require updating to be able to take advantage of them. The number of; native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer; requiring one internally (OpenGL) will build one for you if you do not provide.; However; to do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a stand",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:4075,Usability,simpl,simpler,4075,"ge of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. *OpenGL only supports solid spheres at present - cut/hollow ones will be; requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the; viewers require updating to be able to take advantage of them. The number of; native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer; requiring one internally (OpenGL) will build one for you if you do not provide.; However; to do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively fe",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:6755,Usability,simpl,simply,6755,"you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualVie",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:8005,Usability,simpl,simple,8005," viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:9318,Usability,Clear,Clear,9318,,MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:16886,Usability,Clear,ClearSectionsValid,16886,"bject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. UInt_tfNbPntsNumber of points describing the shape; UInt_tfNbPolsNumber of polygons describing the shape; UInt_tfNbSegsNumber of segments describing the shape; UInt_tfPntsCapacityCurrent capacity of fPnts space; UInt_tfPolsCapacityCurrent capacity of fSegs space; UInt_tfSectionsSection validity flags; UInt_tfSegsCapacityCurrent capacity of fSegs space; const Int_tfTypePrimitive type - predefined ones in TBuffer3DTypes.h; static UInt_tfgCSLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBuffer3D.html:16908,Usability,Clear,Clear,16908,"bject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. UInt_tfNbPntsNumber of points describing the shape; UInt_tfNbPolsNumber of polygons describing the shape; UInt_tfNbSegsNumber of segments describing the shape; UInt_tfPntsCapacityCurrent capacity of fPnts space; UInt_tfPolsCapacityCurrent capacity of fSegs space; UInt_tfSectionsSection validity flags; UInt_tfSegsCapacityCurrent capacity of fSegs space; const Int_tfTypePrimitive type - predefined ones in TBuffer3DTypes.h; static UInt_tfgCSLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections",MatchSource.WIKI,root/html602/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBuffer3D.html
https://root.cern/root/html602/TBufferFile.html:2233,Availability,Error,Error,2233,"virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGe",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:2362,Availability,error,error,2362,"Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:2446,Availability,error,error,2446,"(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtu",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:20195,Availability,error,error,20195,":fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersionOwner() const; Return the version number of the owner file. void TagStreamerInfo(TVirtualStreamerInfo* info); Mark the classindex of the current file as using this TStreamerInfo. void IncrementLevel(TVirtualStreamerInfo* info); Increment level. void DecrementLevel(TVirtualStreamerInfo* ); Decrement level. void ReadLong(Long_t& l); Read Long from TBuffer. void ReadTString(TString& s); Read string from TBuffer. void WriteTString(const TString& s); Write string to TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); Set byte count at position cntpos in the buffer. Generate warning if; count larger than kMaxMapCount. The count is excluded its own size. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss, const char* classname); Check byte count with current buffer position. They should; match. If not print warning and ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:39255,Availability,failure,failure,39255,"st); Read object from I/O buffer.; A typical use for this function is:; MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());; I.e. clCast should point to a TClass object describing the class pointed; to by your pointer.; In case of multiple inheritance, the return value might not be the; real beginning of the object in memory. You will need to use a; dynamic_cast later if you need to retrieve it. void WriteObject(const TObject* obj); Write object to I/O buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to I/O buffer.; This function assumes that the value of 'actualObjectStart' is the actual start of; the object of class 'actualClass'. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionNoCheckSum(UInt_t* start = 0, UInt_t* bcnt = 0); Read class version from I/O buffer, when the caller knows for sure that; there is no checksum written/involved. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:28232,Energy Efficiency,allocate,allocated,28232,"its. IMPORTANT NOTEs. --NOTE 1; Lets assume an original variable double x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:28419,Energy Efficiency,allocate,allocated,28419,"ading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:28598,Energy Efficiency,allocate,allocated,28598," (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:28772,Energy Efficiency,allocate,allocated,28772,"d the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for th",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:28949,Energy Efficiency,allocate,allocated,28949,"0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:29139,Energy Efficiency,allocate,allocated,29139,"s from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferF",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:29318,Energy Efficiency,allocate,allocated,29318,"ers from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of ch",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:29501,Energy Efficiency,allocate,allocated,29501,"orts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:29745,Energy Efficiency,allocate,allocated,29745,"ment is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. Int_t ReadStaticArray(Int_t* i); Read array of ints from the I/O buffer. Returns the number of ints; read. Int_t ReadStaticArray(Long_t* l); Read array of longs from the I/O buffer. Returns the number of longs; read. Int_t ReadStaticArray(Long",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:30051,Energy Efficiency,allocate,allocated,30051," I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. Int_t ReadStaticArray(Int_t* i); Read array of ints from the I/O buffer. Returns the number of ints; read. Int_t ReadStaticArray(Long_t* l); Read array of longs from the I/O buffer. Returns the number of longs; read. Int_t ReadStaticArray(Long64_t* l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. Int_t ReadStaticArray(Float_t* f); Read array of floats from the I/O buffer. Returns the number of floats; read. Int_t ReadStaticArray(Double_t* d); Read array of doubles from the I/O buffer. Returns the number",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:45310,Energy Efficiency,allocate,allocated,45310,"e benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcessID(TRefTable* reftable) const; Return the last TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVir",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:20165,Integrability,rout,routine,20165,":fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersionOwner() const; Return the version number of the owner file. void TagStreamerInfo(TVirtualStreamerInfo* info); Mark the classindex of the current file as using this TStreamerInfo. void IncrementLevel(TVirtualStreamerInfo* info); Increment level. void DecrementLevel(TVirtualStreamerInfo* ); Decrement level. void ReadLong(Long_t& l); Read Long from TBuffer. void ReadTString(TString& s); Read string from TBuffer. void WriteTString(const TString& s); Write string to TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); Set byte count at position cntpos in the buffer. Generate warning if; count larger than kMaxMapCount. The count is excluded its own size. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss, const char* classname); Check byte count with current buffer position. They should; match. If not print warning and ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:23653,Integrability,depend,depending,23653,"d; see comments about Double32_t encoding at TBufferFile::WriteDouble32(). void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16(). void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32(). void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32(). void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer.; The following cases are supported for streaming a Float16_t type; depending on the range declaration in the comment field of the data member:; A- Float16_t fNormal;; B- Float16_t fTemperature; //[0,100]; C- Float16_t fCharge; //[-1,1,2]; D- Float16_t fVertex[3]; //[-30,30,10]; E- Float16_t fChi2; //[0,0,6]; F- Int_t fNsp;; Float16_t* fPointValue; //[fNsp][0,3]. In case A fNormal is converted from a Float_t to a Float_t with mantissa truncated to 12 bits; In case B fTemperature is converted to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specifie",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:25943,Integrability,depend,depending,25943,"t the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a float to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Float16_t data type in tutorial double32.C. /*; ; */. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer.; The following cases are supported for streaming a Double32_t type; depending on the range declaration in the comment field of the data member:; A- Double32_t fNormal;; B- Double32_t fTemperature; //[0,100]; C- Double32_t fCharge; //[-1,1,2]; D- Double32_t fVertex[3]; //[-30,30,10]; E- Double32_t fChi2; //[0,0,6]; F- Int_t fNsp;; Double32_t* fPointValue; //[fNsp][0,3]. In case A fNormal is converted from a Double_t to a Float_t; In case B fTemperature is converted to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with mantissa truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specified, or nbits <2 or nbi",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:46732,Integrability,Interface,Interface,46732,"m file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadClassBuffer(const TClass* cl, void* pointer, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in r",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:46830,Integrability,Interface,Interface,46830,"n the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadClassBuffer(const TClass* cl, void* pointer, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries. Int_t WriteClassBuffer(const TClass* cl, void* pointer); Function called by ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:4237,Modifiability,Inherit,InheritsFrom,4237,"WriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); v",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:4303,Modifiability,Inherit,InheritsFrom,4303,"tual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator de",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:19140,Modifiability,extend,extending,19140,"onymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tfInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the ne",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:19285,Modifiability,Inherit,Inheritance,19285,"store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tfInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersio",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:19298,Modifiability,Inherit,Inherited,19298,"store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tfInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersio",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:24980,Modifiability,variab,variable,24980," In case B fTemperature is converted to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specified, or nbits <2 or nbits>16 it is set to 16; if (xmin==0 and xmax==0 and nbits <=14) the float word will have; its mantissa truncated to nbits significative bits. IMPORTANT NOTE. --NOTE 1; Lets assume an original variable float x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a float to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Float16_t data type in tutorial double32.C. /*; ; */. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer.; The following cases are supported for streaming a Double32_t type; depending on the range declaration in the comment field of the data member:; A- Double32_t fNormal;; B",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:27276,Modifiability,variab,variable,27276,"ed to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with mantissa truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specified, or nbits <2 or nbits>32 it is set to 32; if (xmin==0 and xmax==0 and nbits <=14) the double word will be converted; to a float and its mantissa truncated to nbits significative bits. IMPORTANT NOTEs. --NOTE 1; Lets assume an original variable double x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns th",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:37938,Modifiability,inherit,inherit,37938,"ent* ele = 0); Write array of n doubles (as float) into the I/O buffer.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Write an array of object starting at the address 'start' and of length 'n'; the objects in the array are assumed to be of class 'cl'. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Write an array of object starting at the address '*start' and of length 'n'; the objects in the array are of class 'cl'; 'isPreAlloc' indicates whether the data member is marked with '->'; Return:; 0: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TObject * ReadObject(const TClass* cl); Read object from I/O buffer. clReq is NOT used.; The value returned is the address of the actual start in memory of; the object. Note that if the actual class of the object does not; inherit first from TObject, the type of the pointer is NOT 'TObject*'.; [More accurately, the class needs to start with the TObject part, for; the pointer to be a real TObject*].; We recommend using ReadObjectAny instead of ReadObject. void SkipObjectAny(); Skip any kind of object from buffer. void * ReadObjectAny(const TClass* cast); Read object from I/O buffer.; A typical use for this function is:; MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());; I.e. clCast should point to a TClass object describing the class pointed; to by your pointer.; In case of multiple inheritance, the return value might not be the; real beginning of the object in memory. You will need to use a; dynamic_cast later if you need to retrieve it. void WriteObject(const TObject* obj); Write object to I/O buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to I/O buffer.; This function assumes that the value of 'actualObjectStart' is the actual start of; the object o",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:38518,Modifiability,inherit,inheritance,38518,"; 'isPreAlloc' indicates whether the data member is marked with '->'; Return:; 0: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TObject * ReadObject(const TClass* cl); Read object from I/O buffer. clReq is NOT used.; The value returned is the address of the actual start in memory of; the object. Note that if the actual class of the object does not; inherit first from TObject, the type of the pointer is NOT 'TObject*'.; [More accurately, the class needs to start with the TObject part, for; the pointer to be a real TObject*].; We recommend using ReadObjectAny instead of ReadObject. void SkipObjectAny(); Skip any kind of object from buffer. void * ReadObjectAny(const TClass* cast); Read object from I/O buffer.; A typical use for this function is:; MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());; I.e. clCast should point to a TClass object describing the class pointed; to by your pointer.; In case of multiple inheritance, the return value might not be the; real beginning of the object in memory. You will need to use a; dynamic_cast later if you need to retrieve it. void WriteObject(const TObject* obj); Write object to I/O buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to I/O buffer.; This function assumes that the value of 'actualObjectStart' is the actual start of; the object of class 'actualClass'. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:41104,Modifiability,inherit,inheriting,41104,"(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); Stream an object given a pointer to its actual class. void StreamObject(TObject* obj); Stream an object inheriting from TObject using its streamer. void CheckCount(UInt_t offset); Check if offset is not too large (< kMaxMapCount) when writing. UInt_t CheckObject(UInt_t offset, const TClass* cl, Bool_t readClass = kFALSE); Check for object in the read map. If the object is 0 it still has to be; read. Try to read it from the buffer starting at location offset. If the; object is -1 then it really does not exist and we return 0. If the object; exists just return the offset. Bool_t CheckObject(const TObject* obj); Check if the specified object is already in the buffer.; Returns kTRUE if object already in the buffer, kFALSE otherwise; (also if obj is 0 or TBuffer not in writing mode). Bool_t CheckObject(const void* obj, const TClass* ptrClass); Check if the specified object of the specified class is already in; the buffer. Returns kTRUE if object already in the buffer,; kFALSE otherwise (also if obj is 0 ). void SetPidOffset(UShort_t offset); This offset is used when a key (or basket) is t",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:18390,Performance,cache,cache,18390," TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBufferFile::(anonymous)kStreamedMemberWise; static TBufferFile::(anonymous)kTextBasedStreaming; static TBufferFile::(anonymous)kUser1; static TBufferFile::(anonymous)kUser2; static TBufferFile::(anonymous)kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tfInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:44519,Performance,perform,performance,44519,"erence of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 c",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:44546,Performance,perform,performance,44546," Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcess",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:46462,Performance,optimiz,optimized,46462,"to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcessID(TRefTable* reftable) const; Return the last TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the nu",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:46606,Performance,optimiz,optimized,46606,"ast TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadClassBuffer(const TClass* cl, void* pointer, const TClass* onfile_class); Deserial",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:49754,Performance,perform,performance,49754," pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:49781,Performance,perform,performance,49781,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64(Long64_t& l). void ReadULong64(ULong64_t& l). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t*& c)",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:40285,Safety,safe,safely,40285,"derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionNoCheckSum(UInt_t* start = 0, UInt_t* bcnt = 0); Read class version from I/O buffer, when the caller knows for sure that; there is no checksum written/involved. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); Stream an object given a pointer to its actual class. void StreamObject(TObject* obj); Stream an object inheriting from TObject using its streamer. void CheckCount(UInt_t offset); Check if offset is not too large (< k",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:4071,Security,Hash,Hash,4071,"lass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject* obj, UInt_t offset = 1); virtual voidMapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(c",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:40039,Security,checksum,checksum,40039," WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionNoCheckSum(UInt_t* start = 0, UInt_t* bcnt = 0); Read class version from I/O buffer, when the caller knows for sure that; there is no checksum written/involved. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:44170,Security,hash,hashtable,44170,"1); Add object to the fMap container.; If obj is not 0 add object to the map (in read mode also add 0 objects to; the map). This method may only be called outside this class just before; calling obj->Streamer() to prevent self reference of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:44355,Security,hash,hashtable,44355,"erence of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 c",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:44558,Security,hash,hashsize,44558," Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcess",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:49405,Security,hash,hashtable,49405,"Actions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c)",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:49590,Security,hash,hashtable,49590," pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:49793,Security,hash,hashsize,49793,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64(Long64_t& l). void ReadULong64(ULong64_t& l). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t*& c)",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:12649,Testability,Test,TestBit,12649,"rtual voidTObject::SetUniqueID(UInt_t uid); voidTBuffer::SetWriteMode(); virtual voidSetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); TBufferFile(TBuffer::EMode mode); TBufferFile(TBuffer::EMode mode, Int_t bufsiz); TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:12688,Testability,Test,TestBits,12688,"id); voidTBuffer::SetWriteMode(); virtual voidSetWriteParam(Int_t mapsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo* info); TBufferFile(TBuffer::EMode mode); TBufferFile(TBuffer::EMode mode, Int_t bufsiz); TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferFile.html:1613,Usability,Clear,Clear,1613,"s::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const ",MatchSource.WIKI,root/html602/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferFile.html
https://root.cern/root/html602/TBufferJSON.html:3042,Availability,Error,Error,3042,"e, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo*, Bool_t); virtual voidForceWriteInfoClones(TClonesArray*); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); virtual const char*TObjec",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:3171,Availability,error,error,3171,"idTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo*, Bool_t); virtual voidForceWriteInfoClones(TClonesArray*); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual In",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:3255,Availability,error,error,3255," = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo*, Bool_t); virtual voidForceWriteInfoClones(TClonesArray*); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t, void*&, TClass*&) const;",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:40496,Availability,failure,failure,40496,"the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). Int_t WriteClassBuffer(const TClass* cl, void* pointer); Function called by the Streamer functions to serialize object at p; to buffer b. The optional argument info may be specified to give an; alternative StreamerInfo instead of using the default StreamerInfo; automatically built from the class definition.; For more information, see class TStreamerInfo. TBufferJSON(). Version_t ReadVersionNoCheckSum(UInt_t* , UInt_t* ). void TagStreamerInfo(TVirtualStreamerInfo* ); {}. Int_t ReadBuf(void* , Int_t ); abstract virtual methods from TBuffer, which should be redefined. void WriteBuf(const void* , Int_t ). char * ReadString(char* , Int_t ). void WriteString(const char* ). Int_t GetVersionOwner() const. Int_t GetMapCount() const. void GetMappedObject(UInt_t , void*& , TClass*& ) const. void MapObject(const TObject* , UInt_t = 1). void MapObject(const void* , const TClass* , UInt_t = 1). void Reset(). void InitMap(",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:509,Integrability,interface,interface,509,". TBufferJSON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  HTTP;  TBufferJSON. class TBufferJSON: public TBuffer. Class for serializing object into JavaScript Object Notation (JSON) format.; It creates such object representation, which can be directly; used in JavaScript ROOT (JSROOT) for drawing. TBufferJSON implements TBuffer interface, therefore most of; ROOT and user classes can be converted into JSON.; There are certain limitations for classes with custom streamers,; which should be equipped specially for this purposes (see TCanvas::Streamer() as example). To perform conversion, one should use TBufferJSON::ConvertToJSON method like:. TH1* h1 = new TH1I(""h1"",""title"",100, 0, 10);; h1->FillRandom(""gaus"",10000);; TString json = TBufferJSON::ConvertToJSON(h1);. Function Members (Methods); public:. virtual~TBufferJSON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClas",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:19204,Integrability,depend,depending,19204,"ject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TB",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:20268,Integrability,depend,depending,20268,"r used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TBufferJSON(); destroy buffer. TString ConvertToJSON(const TObject* obj, Int_t compact = 0); converts object, inherited from TObject class, to JSON string. void SetCompact(int level); Set level of space/newline compression; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0)",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:32466,Integrability,message,message,32466," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:32665,Integrability,message,message,32665,"Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:35564,Integrability,message,message,35564,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:35738,Integrability,message,message,35738," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:40163,Integrability,Interface,Interface,40163,"ffer. void SetFloatFormat(const char* fmt = ""%e""); set printf format for float/double members, default ""%e"". const char * GetFloatFormat(); return current printf format for float/double members, default ""%e"". Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). Int_t WriteClassBuffer(const TClass* cl, void* pointer); Function called by the Streamer functions to serialize object at p; to buffer b. The optional argument info may be specified to give an; alternative StreamerInfo instead of using the default StreamerInfo; automatically built from the class definition.; For more information, see class TStreamerInfo. TBufferJSON(). Version_t ReadVersionNoCheckSum(UInt_t* , UInt_t* ). void TagStreamerInfo(TVirtualStreamerInfo* ); {}. Int_t ReadBuf(void* , Int_t ); abstract virtual methods from TBuffer, which should be redefine",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:4969,Modifiability,Inherit,InheritsFrom,4969,"rOnly(); static const char*GetFloatFormat(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t, void*&, TClass*&) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject*, UInt_t = 1); virtual voidMapObject(const void*, const TClass*, UInt_t = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator dele",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:5035,Modifiability,Inherit,InheritsFrom,5035,"bject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t, void*&, TClass*&) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject*, UInt_t = 1); virtual voidMapObject(const void*, const TClass*, UInt_t = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* v",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:20226,Modifiability,extend,extending,20226,"ject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TB",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:20569,Modifiability,Inherit,Inheritance,20569,"ion, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TBufferJSON(); destroy buffer. TString ConvertToJSON(const TObject* obj, Int_t compact = 0); converts object, inherited from TObject class, to JSON string. void SetCompact(int level); Set level of space/newline compression; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); converts selected data member into json. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass); Convert single data member to JSON structures; Returns string with ",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:20582,Modifiability,Inherit,Inherited,20582,"ion, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TBufferJSON(); destroy buffer. TString ConvertToJSON(const TObject* obj, Int_t compact = 0); converts object, inherited from TObject class, to JSON string. void SetCompact(int level); Set level of space/newline compression; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); converts selected data member into json. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass); Convert single data member to JSON structures; Returns string with ",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:20823,Modifiability,inherit,inherited,20823,"er for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TBufferJSON(); destroy buffer. TString ConvertToJSON(const TObject* obj, Int_t compact = 0); converts object, inherited from TObject class, to JSON string. void SetCompact(int level); Set level of space/newline compression; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); converts selected data member into json. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass); Convert single data member to JSON structures; Returns string with converted member. Bool_t CheckObject(const TObject* ); Check that object already stored in the buffer. Bool_t CheckObject(const void* , const TClass* ); Check that object already stored in the buffer. void Write",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:25061,Modifiability,inherit,inherited,25061,"TClass* , Version_t = -1); Should be called in the beginning of custom class streamer.; Informs buffer data about class which will be streamed now. ClassBegin(), ClassEnd() and ClassMemeber() should be used in; custom class streamers to specify which kind of data are; now streamed. Such information is used to correctly; convert class data to JSON. Without that functions calls; classes with custom streamers cannot be used with TBufferJSON. void ClassEnd(const TClass* ); Should be called at the end of custom streamer; See TBufferJSON::ClassBegin for more details. void ClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); Method indicates name and typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(TJSONStackObj* stack, const TStreamerElement* elem = 0); Function is converts TObject and TString structures to more compact representation. TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const T",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:750,Performance,perform,perform,750,". TBufferJSON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  HTTP;  TBufferJSON. class TBufferJSON: public TBuffer. Class for serializing object into JavaScript Object Notation (JSON) format.; It creates such object representation, which can be directly; used in JavaScript ROOT (JSROOT) for drawing. TBufferJSON implements TBuffer interface, therefore most of; ROOT and user classes can be converted into JSON.; There are certain limitations for classes with custom streamers,; which should be equipped specially for this purposes (see TCanvas::Streamer() as example). To perform conversion, one should use TBufferJSON::ConvertToJSON method like:. TH1* h1 = new TH1I(""h1"",""title"",100, 0, 10);; h1->FillRandom(""gaus"",10000);; TString json = TBufferJSON::ConvertToJSON(h1);. Function Members (Methods); public:. virtual~TBufferJSON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClas",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:19490,Performance,cache,cache,19490,"ject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creates buffer object to serialize data into json. ~TB",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:25700,Performance,Perform,PerformPostProcessing,25700," typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(TJSONStackObj* stack, const TStreamerElement* elem = 0); Function is converts TObject and TString structures to more compact representation. TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Ignored in TBufferJSON. void * ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer. void WriteObject",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:27338,Performance,optimiz,optimize,27338,"d SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Ignored in TBufferJSON. void * ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStream",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:27608,Performance,optimiz,optimize,27608,"SON. void * ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:27903,Performance,optimiz,optimize,27903,"at16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. ",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:28177,Performance,optimiz,optimize,28177,"fer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t Re",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:21993,Safety,avoid,avoid,21993,"1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); converts selected data member into json. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass); Convert single data member to JSON structures; Returns string with converted member. Bool_t CheckObject(const TObject* ); Check that object already stored in the buffer. Bool_t CheckObject(const void* , const TClass* ); Check that object already stored in the buffer. void WriteObject(const TObject* obj); Convert object into json structures.; !!! Should be used only by TBufferJSON itself.; Use ConvertToJSON() methods to convert object to json; Redefined here to avoid gcc 3.x warning. TJSONStackObj * PushStack(Int_t inclevel = 0); add new level to the structures stack. TJSONStackObj * PopStack(); remove one level from stack. TJSONStackObj * Stack(Int_t depth = 0); return stack object of specified depth. void AppendOutput(const char* line0, const char* line1 = 0); Info(""AppendOutput"","" '%s' '%s'"", line0, line1?line1 : ""---"");. void JsonStartElement(const TStreamerElement* elem, const TClass* base_class = 0). void JsonDisablePostprocessing(). Int_t JsonSpecialClass(const TClass* cl) const; return non-zero value when class has special handling in JSON; it is TCollection (-130), TArray (100), TString (110), std::string (120) and STL containers (1..6). void JsonWriteObject(const void* obj, const TClass* objClass, Bool_t check_map = kTRUE); Write object to buffer; If object was written before, only pointer will be stored; If check_map==kFALSE, object will be stored in any case and pointer will not be registered in the ",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:32452,Safety,avoid,avoid,32452," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:32651,Safety,avoid,avoid,32651,"Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:35546,Safety,avoid,avoid,35546,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:35720,Safety,avoid,avoid,35720," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:4808,Security,Hash,Hash,4808,"ass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable*) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t, void*&, TClass*&) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tGetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tGetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMapObject(const TObject*, UInt_t = 1); virtual voidMapObject(const void*, const TClass*, UInt_t = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char*",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:13074,Testability,Test,TestBit,13074,"ReadParam(Int_t); voidTBuffer::SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); virtual voidSetStreamerElementNumber(TStreamerElement* elem, Int_t comp_type); virtual voidTObject::SetUniqueID(UInt_t uid); voidTBuffer::SetWriteMode(); virtual voidSetWriteParam(Int_t); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo*); TBufferJSON(); TBufferJSON(const TBufferJSON&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:13113,Testability,Test,TestBits,13113,"ocFunc(ReAllocCharFun_t reallocfunc = 0); virtual voidSetStreamerElementNumber(TStreamerElement* elem, Int_t comp_type); virtual voidTObject::SetUniqueID(UInt_t uid); voidTBuffer::SetWriteMode(); virtual voidSetWriteParam(Int_t); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagStreamerInfo(TVirtualStreamerInfo*); TBufferJSON(); TBufferJSON(const TBufferJSON&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferJSON.html:2185,Usability,Clear,Clear,2185,"nce& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html602/TBufferJSON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferJSON.html
https://root.cern/root/html602/TBufferSQL.html:2325,Availability,Error,Error,2325,"ferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static In",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:2454,Availability,error,error,2454,"Class*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:2538,Availability,error,error,2538,"oidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessID*TBuffe",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:4498,Modifiability,Inherit,InheritsFrom,4498,":GetInfo(); virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTBufferFile::IncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:4564,Modifiability,Inherit,InheritsFrom,4564,"able* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTBufferFile::IncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:21028,Modifiability,extend,extending,21028,"fMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int>::const_iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Constructor. TBufferSQL(); Constructor. ~TBufferSQL(); Destructo. void ReadBool(Bool_t& b); Operator>>. void ReadChar(Char_t& c); Operator>>. void ReadShort(Short_t& s); Operator>>. void ReadInt(Int_t& i); Operator>>. void ReadFloat(Float_t& f); Operator>>. vo",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:21299,Modifiability,Inherit,Inheritance,21299,"tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int>::const_iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Constructor. TBufferSQL(); Constructor. ~TBufferSQL(); Destructo. void ReadBool(Bool_t& b); Operator>>. void ReadChar(Char_t& c); Operator>>. void ReadShort(Short_t& s); Operator>>. void ReadInt(Int_t& i); Operator>>. void ReadFloat(Float_t& f); Operator>>. void ReadLong(Long_t& l); Operator>>. void ReadDouble(Double_t& d); Operator>>. void WriteBool(Bool_t b); Operator<<. void WriteChar(Char_t c); Operator<<. void WriteShort(Short_t s); Operator<<. void WriteInt(Int_t i); Operator<<. void WriteLong(Long_t l); Operator<<. void WriteFloat(Float_t f); Operator<<. void WriteDoubl",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:21312,Modifiability,Inherit,Inherited,21312,"tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int>::const_iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Constructor. TBufferSQL(); Constructor. ~TBufferSQL(); Destructo. void ReadBool(Bool_t& b); Operator>>. void ReadChar(Char_t& c); Operator>>. void ReadShort(Short_t& s); Operator>>. void ReadInt(Int_t& i); Operator>>. void ReadFloat(Float_t& f); Operator>>. void ReadLong(Long_t& l); Operator>>. void ReadDouble(Double_t& d); Operator>>. void WriteBool(Bool_t b); Operator<<. void WriteChar(Char_t c); Operator<<. void WriteShort(Short_t s); Operator<<. void WriteInt(Int_t i); Operator<<. void WriteLong(Long_t l); Operator<<. void WriteFloat(Float_t f); Operator<<. void WriteDoubl",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:20174,Performance,cache,cache,20174,"fer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBufferFile::(anonymous)TBufferFile::kStreamedMemberWise; static TBufferFile::(anonymous)TBufferFile::kTextBasedStreaming; static TBufferFile::(anonymous)TBufferFile::kUser1; static TBufferFile::(anonymous)TBufferFile::kUser2; static TBufferFile::(anonymous)TBufferFile::kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int>::const_iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_q",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:4319,Security,Hash,Hash,4319,"atic Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTBufferFile::IncrementLevel(TVirtualStreamerInfo* info); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virt",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:13921,Testability,Test,TestBit,13921,"(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTBufferFile::StreamObject(TObject* obj); virtual voidTBufferFile::StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferSQL(); TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidTBufferFile::WriteArray(const Bool_t* b, Int_t n); virtual voidTBufferFile::WriteArray(const Char_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const UChar_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const Short_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const UShort_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const Int_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const UInt_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const Long_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Long64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Float_t* f, Int_t n); virtual voidTBufferFile::WriteArray(const Double_t* d, In",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:13960,Testability,Test,TestBits,13960,"eamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTBufferFile::StreamObject(TObject* obj); virtual voidTBufferFile::StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidTBufferFile::StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferSQL(); TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidTBufferFile::WriteArray(const Bool_t* b, Int_t n); virtual voidTBufferFile::WriteArray(const Char_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const UChar_t* c, Int_t n); virtual voidTBufferFile::WriteArray(const Short_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const UShort_t* h, Int_t n); virtual voidTBufferFile::WriteArray(const Int_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const UInt_t* i, Int_t n); virtual voidTBufferFile::WriteArray(const Long_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Long64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const ULong64_t* l, Int_t n); virtual voidTBufferFile::WriteArray(const Float_t* f, Int_t n); virtual voidTBufferFile::WriteArray(const Double_t* d, Int_t n); virtual voidTBufferFile::WriteAr",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL.html:1692,Usability,Clear,Clear,1692,"ionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tTBufferFile::ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject:",MatchSource.WIKI,root/html602/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL.html
https://root.cern/root/html602/TBufferSQL2.html:2657,Availability,Error,Error,2657,"; virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetE",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:2786,Availability,error,error,2786,"const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorFlag() const; static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::Get",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:2870,Availability,error,error,2870,"ssMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorFlag() const; static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtua",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:21988,Availability,Error,Error,21988,"ferFile::(anonymous)TBufferFile::kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compress level used to minimize size of data in database; TSQLObjectData*fCurrentData!; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag! Error id value; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Long64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:4911,Modifiability,Inherit,InheritsFrom,4911,"l TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TSQLStructure*GetStructure() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:4977,Modifiability,Inherit,InheritsFrom,4977,"nst; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TSQLStructure*GetStructure() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:23173,Modifiability,extend,extending,23173,"ong64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer for read value; Int_tfReadVersionBuffer! buffer, used to by ReadVersion method; TSQLFile*fSQL! instance of TSQLFile; TSQLStructure*fStk! pointer on current active structure (stack head); TSQLStructure*fStructure! structures, created by object storing; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL2(); Default constructor, should not be used. TBufferSQL2(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from sql.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Creates buffer object to serailize/deserialize data to/from sql.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be ",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:23610,Modifiability,Inherit,Inheritance,23610,"ferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer for read value; Int_tfReadVersionBuffer! buffer, used to by ReadVersion method; TSQLFile*fSQL! instance of TSQLFile; TSQLStructure*fStk! pointer on current active structure (stack head); TSQLStructure*fStructure! structures, created by object storing; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL2(); Default constructor, should not be used. TBufferSQL2(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from sql.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Creates buffer object to serailize/deserialize data to/from sql.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferSQL2(); destroy sql buffer. TSQLStructure* SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); Convert object of any class to sql structures; Return pointer on created TSQLStructure; TSQLStructure object will be owned by TBufferSQL2. void* SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t ",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:23623,Modifiability,Inherit,Inherited,23623,"ferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer for read value; Int_tfReadVersionBuffer! buffer, used to by ReadVersion method; TSQLFile*fSQL! instance of TSQLFile; TSQLStructure*fStk! pointer on current active structure (stack head); TSQLStructure*fStructure! structures, created by object storing; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL2(); Default constructor, should not be used. TBufferSQL2(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from sql.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Creates buffer object to serailize/deserialize data to/from sql.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferSQL2(); destroy sql buffer. TSQLStructure* SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); Convert object of any class to sql structures; Return pointer on created TSQLStructure; TSQLStructure object will be owned by TBufferSQL2. void* SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t ",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:28207,Modifiability,inherit,inherited,28207,"o correctly; convert class data to/from ""normal"" sql tables with meaningfull names; and correct datatypes. Without that functions data from custom streamer; will be saved as ""raw"" data in special _streamer_ table one value after another; Such MUST be used when object is written with standard ROOT streaming; procedure, but should be read back in custom streamer.; For example, custom streamer of TNamed class may look like:. void ClassEnd(const TClass* ); Method indicates end of streaming of classdata in custom streamer.; See ClassBegin() method for more details. void ClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); Method indicates name and typename of class memeber,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as datamember; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(b);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; For more details see ClassBegin() method description. void WorkWithClass(const char* classname, Version_t classversion); This function is a part of IncrementLevel method.; Also used in StartClass method. void WorkWithElement(TStreamerElement* elem, Int_t comp_type); This function is a part of SetStreamerElementNumber method.; It is introduced for reading of data for specified data memeber of class.; Used also in ReadFastArray met",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:30098,Modifiability,variab,variable,30098,"ent(TStreamerElement* elem, Int_t comp_type); This function is a part of SetStreamerElementNumber method.; It is introduced for reading of data for specified data memeber of class.; Used also in ReadFastArray methods to resolve problem of compressed data,; when several data memebers of the same basic type streamed with single ...FastArray call. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer; actually version is normally defined by table name; and kept in intermediate variable fReadVersionBuffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to sql immidiately; Version will be used to produce complete table; name, which will include class version. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have b",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:45765,Modifiability,variab,variable,45765,"value from table and convert it to Bool_t value. void SqlReadBasic(UChar_t& value); read current value from table and convert it to UChar_t value. void SqlReadBasic(UShort_t& value); read current value from table and convert it to UShort_t value. void SqlReadBasic(UInt_t& value); read current value from table and convert it to UInt_t value. void SqlReadBasic(ULong_t& value); read current value from table and convert it to ULong_t value. void SqlReadBasic(ULong64_t& value); read current value from table and convert it to ULong64_t value. const char* SqlReadValue(const char* tname); read string value from current stack node. const char* SqlReadCharStarValue(); read CharStar value, if it has special code, request it from large table. TSQLStructure* PushStack(); Push stack with structurual information about streamed object. TSQLStructure* PopStack(); Pop stack. TSQLStructure* Stack(Int_t depth = 0); returns head of stack. void SetFloatFormat(const char* fmt = ""%e""); set printf format for float/double members, default ""%e""; changes global TSQLServer variable. const char* GetFloatFormat(); return current printf format for float/double members, default ""%e""; return format, hold by TSQLServer. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. TBufferSQL2(const TBufferSQL2& ); TBufferSQL2 objects",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:21647,Performance,cache,cache,21647,"ferFile::(anonymous)TBufferFile::kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compress level used to minimize size of data in database; TSQLObjectData*fCurrentData!; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag! Error id value; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Long64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:31134,Performance,optimiz,optimize,31134,"t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to sql immidiately; Version will be used to produce complete table; name, which will include class version. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:31402,Performance,optimiz,optimize,31402,"ect from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t ",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:31695,Performance,optimiz,optimize,31695,"y used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& ",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:31967,Performance,optimiz,optimize,31967,"the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t ReadArray(Double_t*& d); R",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:25492,Safety,avoid,avoid,25492," TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name and version are taken from special objects table. void IncrementLevel(TVirtualStreamerInfo* ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and indent new level in data structure.; This call indicates, that TStreamerInfo functions starts streaming; object data of correspondent class. void DecrementLevel(TVirtualStreamerInfo* ); Fun",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:4750,Security,Hash,Hash,4750,"Param(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TSQLStructure*GetStructure() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject:",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:13936,Testability,Test,TestBit,13936,"dSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); void*SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); TSQLStructure*SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, TMemberStreamer* streamer, const TClass* cl, Int_t n = 0, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferSQL2(TBuffer::EMode mode); TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:13975,Testability,Test,TestBits,13975,"on(const TClass* cl = 0); void*SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); TSQLStructure*SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, TMemberStreamer* streamer, const TClass* cl, Int_t n = 0, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferSQL2(TBuffer::EMode mode); TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:417,Usability,simpl,simple,417,". TBufferSQL2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  SQL;  TBufferSQL2. class TBufferSQL2: public TBufferFile. Class for serializing/deserializing object to/from SQL data base.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from TSQLStructure objects.; TBufferSQL2 class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored. There are; limitations for complex objects like TTree, TClonesArray, TDirectory and; few other, which can not be converted to SQL (yet). Function Members (Methods); public:. virtual~TBufferSQL2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::Clas",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:441,Usability,simpl,simple,441,". TBufferSQL2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  SQL;  TBufferSQL2. class TBufferSQL2: public TBufferFile. Class for serializing/deserializing object to/from SQL data base.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from TSQLStructure objects.; TBufferSQL2 class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored. There are; limitations for complex objects like TTree, TClonesArray, TDirectory and; few other, which can not be converted to SQL (yet). Function Members (Methods); public:. virtual~TBufferSQL2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::Clas",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:2037,Usability,Clear,Clear,2037,"ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const ",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferSQL2.html:25049,Usability,simpl,simple,25049,"le.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferSQL2(); destroy sql buffer. TSQLStructure* SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); Convert object of any class to sql structures; Return pointer on created TSQLStructure; TSQLStructure object will be owned by TBufferSQL2. void* SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name a",MatchSource.WIKI,root/html602/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferSQL2.html
https://root.cern/root/html602/TBufferXML.html:3216,Availability,Error,Error,3216,"nst; static TObject*ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static void*ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static co",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:3345,Availability,error,error,3345,"nvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:3429,Availability,error,error,3429,"l_t UseNamespaces = kFALSE); static TStringConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:27079,Deployability,configurat,configuration,27079,"nt for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWri",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:27317,Deployability,configurat,configuration,27317,"; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:42287,Integrability,message,message,42287," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:42486,Integrability,message,message,42486,"Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:45299,Integrability,message,message,45299,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:45473,Integrability,message,message,45473," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:5536,Modifiability,Inherit,InheritsFrom,5536,"le::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; Int_tTXMLSetup::GetNextRefCounter(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TStringTXMLSetup::GetSetupAsString(); virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; TXMLSetup::EXMLLayoutTXMLSetup::GetXmlLayout() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTXMLSetup::IsStoreStreamerInfos() const; Bool_tTXMLSetup::IsUseDtd() const; Bool_tTXMLSetup::IsUseNamespaces() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const ch",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:5602,Modifiability,Inherit,InheritsFrom,5602,"UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; Int_tTXMLSetup::GetNextRefCounter(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TStringTXMLSetup::GetSetupAsString(); virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; TXMLSetup::EXMLLayoutTXMLSetup::GetXmlLayout() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTXMLSetup::IsStoreStreamerInfos() const; Bool_tTXMLSetup::IsUseDtd() const; Bool_tTXMLSetup::IsUseNamespaces() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(const void* obj, const TClass* cl, UInt_t offset = 1); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) con",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:25533,Modifiability,extend,extending,25533,"reading; Int_tfCompressLevel! compression level and algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; Bool_tTXMLSetup::fUseDtd; Bool_tTXMLSetup::fUseNamespaces; TStringfValueBuf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static stringfgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXML",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:26203,Modifiability,Inherit,Inheritance,26203,"fault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; Bool_tTXMLSetup::fUseDtd; Bool_tTXMLSetup::fUseNamespaces; TStringfValueBuf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static stringfgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, ",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:26216,Modifiability,Inherit,Inherited,26216,"fault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; Bool_tTXMLSetup::fUseDtd; Bool_tTXMLSetup::fUseNamespaces; TStringfValueBuf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static stringfgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, ",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:27021,Modifiability,inherit,inherited,27021,"nt for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWri",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:27079,Modifiability,config,configuration,27079,"nt for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWri",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:27317,Modifiability,config,configuration,27317,"; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:27561,Modifiability,inherit,inherit,27561,"ta to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:34284,Modifiability,inherit,inherited,34284,"st TClass* , Version_t = -1); Should be called in the beginning of custom class streamer.; Informs buffer data about class which will be streamed now. ClassBegin(), ClassEnd() and ClassMemeber() should be used in; custom class streamers to specify which kind of data are; now streamed. Such information is used to correctly; convert class data to XML. Without that functions calls; classes with custom streamers cannot be used with TBufferXML. void ClassEnd(const TClass* ); Should be called at the end of custom streamer; See TBufferXML::ClassBegin for more details. void ClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); Method indicates name and typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffe",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:24273,Performance,cache,cache,24273,"rFile::(anonymous)TBufferFile::kUser1; static TBufferFile::(anonymous)TBufferFile::kUser2; static TBufferFile::(anonymous)TBufferFile::kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfCanUseCompact! flag indicate that basic type (like Int_t) can be placed in the same tag; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compression level and algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass()",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:34923,Performance,Perform,PerformPostProcessing,34923,"; Method indicates name and typename of class member,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcn",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:35037,Performance,Perform,PerformPreProcessing,35037,"ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. void CheckVersionBuf(); checks buffer, filled by WriteVersion; if next data is arriving, vers",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:37196,Performance,optimiz,optimize,37196," cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to xml; Version will be written with next I/O operation or; will be added as attribute of class tag, created by IncrementLevel call. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer; Actually skip only one node on current level of xml structure. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElem",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:37464,Performance,optimiz,optimize,37464," from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer; Actually skip only one node on current level of xml structure. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h)",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:37757,Performance,optimiz,optimize,37757,"adFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. In",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:38029,Performance,optimiz,optimize,38029,"the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t Re",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:28506,Safety,avoid,avoid,28506,"= kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0 no compression.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negativ",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:42273,Safety,avoid,avoid,42273," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:42472,Safety,avoid,avoid,42472,"Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:45281,Safety,avoid,avoid,45281,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:45455,Safety,avoid,avoid,45455," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:50702,Safety,safe,safe,50702,"ue. void XmlReadBasic(Float_t& value); reads string from current xml node and convert it to Float_t value. void XmlReadBasic(Double_t& value); reads string from current xml node and convert it to Double_t value. void XmlReadBasic(Bool_t& value); reads string from current xml node and convert it to Bool_t value. void XmlReadBasic(UChar_t& value); reads string from current xml node and convert it to UChar_t value. void XmlReadBasic(UShort_t& value); reads string from current xml node and convert it to UShort_t value. void XmlReadBasic(UInt_t& value); reads string from current xml node and convert it to UInt_t value. void XmlReadBasic(ULong_t& value); reads string from current xml node and convert it to ULong_t value. void XmlReadBasic(ULong64_t& value); reads string from current xml node and convert it to ULong64_t value. const char* XmlReadValue(const char* name); read string value from current stack node. void SetFloatFormat(const char* fmt = ""%e""); Set printf format for float/double members, default ""%e""; This method is not thread-safe as it changes a global state. const char* GetFloatFormat(); return current printf format for float/double members, default ""%e"". Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. I",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:5375,Security,Hash,Hash,5375,"ame() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessID*TBufferFile::GetLastProcessID(TRefTable* reftable) const; virtual Int_tTBufferFile::GetMapCount() const; virtual voidTBufferFile::GetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetName() const; Int_tTXMLSetup::GetNextRefCounter(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*TBuffer::GetParent() const; virtual UShort_tTBufferFile::GetPidOffset() const; ReAllocCharFun_tTBuffer::GetReAllocFunc() const; TStringTXMLSetup::GetSetupAsString(); virtual const char*TObject::GetTitle() const; virtual UInt_tTBufferFile::GetTRefExecId(); virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTBufferFile::GetVersionOwner() const; TXMLSetup::EXMLLayoutTXMLSetup::GetXmlLayout() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidIncrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTBufferFile::InitMap(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTBuffer::IsReading() const; virtual Bool_tTObject::IsSortable() const; Bool_tTXMLSetup::IsStoreStreamerInfos() const; Bool_tTXMLSetup::IsUseDtd() const; Bool_tTXMLSetup::IsUseNamespaces() const; Bool_tTBuffer::IsWriting() const; Bool_tTObject::IsZombie() const; Int_tTBuffer::Length() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTBufferFile::MapObject(const TObject* obj, UInt_t offset = 1); virtual voidTBufferFile::MapObject(con",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:26820,Security,access,access,26820,"uf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static stringfgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, pr",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:14770,Testability,Test,TestBit,14770,"es(Bool_t iUseNamespaces = kTRUE); voidTBuffer::SetWriteMode(); virtual voidTBufferFile::SetWriteParam(Int_t mapsize); virtual voidTXMLSetup::SetXmlLayout(TXMLSetup::EXMLLayout layout); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferXML(TBuffer::EMode mode); TBufferXML(const TBufferXML&); TBufferXML(TBuffer::EMode mode, TXMLFile* file); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement*",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:14809,Testability,Test,TestBits,14809,"TBuffer::SetWriteMode(); virtual voidTBufferFile::SetWriteParam(Int_t mapsize); virtual voidTXMLSetup::SetXmlLayout(TXMLSetup::EXMLLayout layout); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSkipObjectAny(); virtual voidSkipVersion(const TClass* cl = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidStreamObject(TObject* obj); virtual voidStreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const char* className, const TClass* onFileClass = 0); virtual voidStreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTBufferFile::TagStreamerInfo(TVirtualStreamerInfo* info); TBufferXML(TBuffer::EMode mode); TBufferXML(const TBufferXML&); TBufferXML(TBuffer::EMode mode, TXMLFile* file); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual voidWriteArray(const Bool_t* b, Int_t n); virtual voidWriteArray(const Char_t* c, Int_t n); virtual voidWriteArray(const UChar_t* c, Int_t n); virtual voidWriteArray(const Short_t* h, Int_t n); virtual voidWriteArray(const UShort_t* h, Int_t n); virtual voidWriteArray(const Int_t* i, Int_t n); virtual voidWriteArray(const UInt_t* i, Int_t n); virtual voidWriteArray(const Long_t* l, Int_t n); virtual voidWriteArray(const ULong_t* l, Int_t n); virtual voidWriteArray(const Long64_t* l, Int_t n); virtual voidWriteArray(const ULong64_t* l, Int_t n); virtual voidWriteArray(const Float_t* f, Int_t n); virtual voidWriteArray(const Double_t* d, Int_t n); virtual voidWriteArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); virtual voidWriteArrayFloat16(const Float_t* f, Int_t n, TStreamerElement* ele = 0); virtual voidWriteBool(Bool_t ",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:422,Usability,simpl,simple,422,". TBufferXML. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  XML;  TBufferXML. class TBufferXML: public TBufferFile, public TXMLSetup. Class for serializing/deserializing object to/from xml.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from xml.; Instead of writing a binary data it creates a set of xml structures as; nodes and attributes; TBufferXML class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored to xml. There are; limitations for complex objects like TTree, which can not be yet converted to xml. Function Members (Methods); public:. virtual~TBufferXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsi",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:446,Usability,simpl,simple,446,". TBufferXML. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  XML;  TBufferXML. class TBufferXML: public TBufferFile, public TXMLSetup. Class for serializing/deserializing object to/from xml.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from xml.; Instead of writing a binary data it creates a set of xml structures as; nodes and attributes; TBufferXML class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored to xml. There are; limitations for complex objects like TTree, which can not be yet converted to xml. Function Members (Methods); public:. virtual~TBufferXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsi",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:2080,Usability,Clear,Clear,2080,"ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TObject*ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static void*ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:19629,Usability,simpl,simple,19629,":CheckCount(UInt_t offset); UInt_tTBufferFile::CheckObject(UInt_t offset, const TClass* cl, Bool_t readClass = kFALSE); voidCheckVersionBuf(); voidCreateElemNode(const TStreamerElement* elem); XMLNodePointer_tCreateItemNode(const char* name); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tExtractPointer(XMLNodePointer_t node, void*& ptr, TClass*& cl); voidExtractReference(XMLNodePointer_t node, const void* ptr, const TClass* cl); Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; const char*TXMLSetup::GetElItemName(TStreamerElement* el); Bool_tTXMLSetup::IsValidXmlSetup(const char* setupstr); voidTObject::MakeZombie(); voidPerformPostProcessing(); voidPerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); TXMLStackObj*PopStack(); Bool_tProcessPointer(const void* ptr, XMLNodePointer_t node); TXMLStackObj*PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); virtual Int_tTBuffer::Read(const char* name); Bool_tTXMLSetup::ReadSetupFromStr(const char* setupstr); voidRegisterPointer(const void* ptr, XMLNodePointer_t node); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); voidSetXML(TXMLEngine* xml); voidShiftStack(const char* info = 0); TXMLStackObj*Stack(Int_t depth = 0); XMLNodePointer_tStackNode(); TBufferXML(); Bool_tVerifyAttr(XMLNodePointer_t node, const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyElemNode(const TStreamerElement* elem); Bool_tVerifyItemNode(const char* name, const char* errinfo = 0); Bool_tVerifyNode(XMLNodePointer_t node, const char* name, const char* errinfo = 0); Bool_tVerifyStackAttr(const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyStackNode(const char* name, const char* errinfo = 0); voidWorkWithClass(TStreamerInfo* info, const TClass* cl = 0); voidWorkWithElemen",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TBufferXML.html:28586,Usability,simpl,simple,28586,"ct class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0 no compression.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates",MatchSource.WIKI,root/html602/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TBufferXML.html
https://root.cern/root/html602/TButton.html:7517,Availability,Error,Error,7517,"const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; vi",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:7684,Availability,error,error,7684,"r* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; vir",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:7768,Availability,error,error,7768,"idTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetCrosshair() const; virtual",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:28276,Availability,down,down,28276,,MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:20098,Deployability,TOGGLE,TOGGLE,20098,"SetAttLinePS(Color_t color, Style_t style, Width_t lwidth); virtual voidTPad::SetAttMarkerPS(Color_t color, Style_t style, Size_t msize); virtual voidTPad::SetAttTextPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize); virtual voidTPad::SetBBoxCenter(const TPoint& p); virtual voidTPad::SetBBoxCenterX(const Int_t x); virtual voidTPad::SetBBoxCenterY(const Int_t y); virtual voidTPad::SetBBoxX1(const Int_t x); virtual voidTPad::SetBBoxX2(const Int_t x); virtual voidTPad::SetBBoxY1(const Int_t y); virtual voidTPad::SetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderMode(Short_t bordermode); virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidTPad::SetCanvasSize(UInt_t ww, UInt_t wh); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidTPad::SetCursor(ECursor cursor); virtual voidTPad::SetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGri",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:20353,Deployability,TOGGLE,TOGGLE,20353,"Pad::SetBBoxCenter(const TPoint& p); virtual voidTPad::SetBBoxCenterX(const Int_t x); virtual voidTPad::SetBBoxCenterY(const Int_t y); virtual voidTPad::SetBBoxX1(const Int_t x); virtual voidTPad::SetBBoxX2(const Int_t x); virtual voidTPad::SetBBoxY1(const Int_t y); virtual voidTPad::SetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderMode(Short_t bordermode); virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidTPad::SetCanvasSize(UInt_t ww, UInt_t wh); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidTPad::SetCursor(ECursor cursor); virtual voidTPad::SetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual ",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:20642,Deployability,TOGGLE,TOGGLE,20642,"BoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderMode(Short_t bordermode); virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidTPad::SetCanvasSize(UInt_t ww, UInt_t wh); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidTPad::SetCursor(ECursor cursor); virtual voidTPad::SetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1); virtual voidSetLogy(Int_t valu",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:21184,Deployability,TOGGLE,TOGGLE,21184,"nt_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1); virtual voidSetLogy(Int_t value = 1); virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidSetMethod(const char* method)MENU ; virtual voidSetName(const char* name); virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:21236,Deployability,TOGGLE,TOGGLE,21236,"on_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1); virtual voidSetLogy(Int_t value = 1); virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidSetMethod(const char* method)MENU ; virtual voidSetName(const char* name); virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:21696,Deployability,TOGGLE,TOGGLE,21696," voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1); virtual voidSetLogy(Int_t value = 1); virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidSetMethod(const char* method)MENU ; virtual voidSetName(const char* name); virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTPad::SetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidTPad::SetSelected(TObject* obj); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTex",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:23065,Deployability,TOGGLE,TOGGLE,23065," Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTPad::SetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidTPad::SetSelected(TObject* obj); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextColorAlpha(Color_t tcolor, Float_t talpha); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTicky(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTitle(const char* title = """"); virtual voidTPad::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) c",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:23117,Deployability,TOGGLE,TOGGLE,23117," voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTPad::SetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidTPad::SetSelected(TObject* obj); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextColorAlpha(Color_t tcolor, Float_t talpha); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTicky(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTitle(const char* title = """"); virtual voidTPad::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TButton(); TButton(const char* title, const ch",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:24284,Deployability,Update,Update,24284,"Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TButton(); TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTPad::Update(); virtual voidTPad::UseCurrentStyle()MENU ; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidx3d(Option_t* option = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Double_t x) const; virtual voidTPad::XYtoAbsPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtual voidTPad::XYtoPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtual Int_tTPad::YtoAbsPixel(Double_t y) const;",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:325,Integrability,interface,interface,325,". TButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GPAD;  TButton. class TButton: public TPad, public TAttText. A TButton object is a user interface object.; A TButton has a name and an associated action.; When the button is clicked with the left mouse button, the corresponding; action is executed.; A TButton can be created by direct invocation of the constructors; or via the graphics editor.; The action can be set via TButton::SetMethod.; The action can be any command. Examples of actions:; ""34+78"" When the button is clicked, the result of addition is printed.; "".x macro.C"" . Clicking the button executes the macro macro.C; The action can be modified at any time via TButton::SetMethod. To modify the layout/size/contents of one or several buttons; in a canvas, you must set the canvas editable via TCanvas::SetEditable.; By default a TCanvas is editable.; By default a TDialogCanvas is not editable.; TButtons are in general placed in a TDialogCanvas. A TButton being a TPad, one can draw graphics primitives in it; when the TCanvas/TDialogCanvas is editable. Example of a macro creating a dialogcanvas with buttons; void but() {; example of a dialogcanvas with a few buttons. TDialogCanvas *dialog = new TDialogCanvas(""dialog"","""",200,300);. Create first button. Clicking on this button will execute 34+56; TButton *but1 = new TButton(""button1"",""34+56"",.05,.8,.45,.88);; but1->Draw();. Create second button. Clicking on this button will create a new canvas; TButton *but2 = new TButton(""canvas"",""c2 = new TCanvas(\""c2\"")"",.55,.8,.95,.88);; but2->Draw();. Create third button. Clicking on this button will invoke the browser; but3 = new TButton(""Browser"",""br = new TBrowser(\""br\"")"",0.25,0.54,0.75,0.64);; but3->SetFillColor(42);; but3->Draw();. Create last button with no name. Instead a graph is draw insi",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:14063,Integrability,Message,Message,14063,"dTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTPad::IsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTPad::IsFolder() const; virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTPad::IsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTPad::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tTPad::OpaqueMoving() const; virtual Bool_tTPad::OpaqueResizing() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static TVirtualPad*&TVirtualPad::Pad(); virtual Bool_tTVirtualPad::PadInHighlightMode() const; virtual Bool_tTVirtualPad::PadInSelectionMode() const; virtual Double_tTPad::PadtoX(Double_t x) const; vi",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:13152,Modifiability,Inherit,InheritsFrom,13152,"h() const; virtual Double_tTPad::GetWNDC() const; virtual UInt_tTPad::GetWw() const; virtual Double_tTPad::GetX1() const; virtual Double_tTPad::GetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tTPad::GetXlowNDC() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Float_tTAttPad::GetYstat() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTPad::IsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTPad::IsFolder() const; virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTPad::IsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTPad::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voi",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:13218,Modifiability,Inherit,InheritsFrom,13218,"ad::GetWw() const; virtual Double_tTPad::GetX1() const; virtual Double_tTPad::GetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tTPad::GetXlowNDC() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Float_tTAttPad::GetYstat() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTPad::IsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTPad::IsFolder() const; virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTPad::IsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTPad::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); virtual Int_",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:33425,Modifiability,Inherit,Inheritance,33425,"fXtoAbsPixelkConversion coefficient for X World to absolute pixel; Double_tTPad::fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworld; Double_tTPad::fXtoPixelkConversion coefficient for X World to pixel; Double_tTPad::fY1Y of lower Y coordinate; Double_tTPad::fY2Y of upper Y coordinate; Double_tTPad::fYUpNDC; Float_tTAttPad::fYfileY position where to draw the file name; Double_tTPad::fYlowNDCY bottom left corner of pad in NDC [0,1]; Float_tTAttPad::fYstatY position where to draw the statistics; Double_tTPad::fYtoAbsPixelkConversion coefficient for Y World to absolute pixel; Double_tTPad::fYtoPixelypixel = fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. private:. Bool_tfFocusedIf cursor is in...; Bool_tfFramingTrue if you want a frame to be painted when pressed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TButton(); Button default constructor. TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Button normal constructor. Note that the button coordinates x1,y1,x2,y2 are always in the range [0,1]. ~TButton(); Button default destructor. void Draw(Option_t* option = """"); Draw this button with its current attributes. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a Button object is clicked. void Paint(Option_t* option = """"); Paint this button with its current attributes. void PaintModified(); Paint is modified. void Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Set world coordinate system for the pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetFraming(Bool_t f = 1); if framing is set, button will be highlighted. void Di",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:33438,Modifiability,Inherit,Inherited,33438,"fXtoAbsPixelkConversion coefficient for X World to absolute pixel; Double_tTPad::fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworld; Double_tTPad::fXtoPixelkConversion coefficient for X World to pixel; Double_tTPad::fY1Y of lower Y coordinate; Double_tTPad::fY2Y of upper Y coordinate; Double_tTPad::fYUpNDC; Float_tTAttPad::fYfileY position where to draw the file name; Double_tTPad::fYlowNDCY bottom left corner of pad in NDC [0,1]; Float_tTAttPad::fYstatY position where to draw the statistics; Double_tTPad::fYtoAbsPixelkConversion coefficient for Y World to absolute pixel; Double_tTPad::fYtoPixelypixel = fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. private:. Bool_tfFocusedIf cursor is in...; Bool_tfFramingTrue if you want a frame to be painted when pressed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TButton(); Button default constructor. TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Button normal constructor. Note that the button coordinates x1,y1,x2,y2 are always in the range [0,1]. ~TButton(); Button default destructor. void Draw(Option_t* option = """"); Draw this button with its current attributes. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a Button object is clicked. void Paint(Option_t* option = """"); Paint this button with its current attributes. void PaintModified(); Paint is modified. void Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Set world coordinate system for the pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetFraming(Bool_t f = 1); if framing is set, button will be highlighted. void Di",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:12844,Security,Hash,Hash,12844,"tUxmin() const; virtual Double_tTPad::GetUymax() const; virtual Double_tTPad::GetUymin() const; virtual TView*TPad::GetView() const; virtual TObject*TPad::GetView3D() const; virtual TVirtualViewer3D*TPad::GetViewer3D(Option_t* type = """"); virtual TVirtualPad*TPad::GetVirtCanvas() const; virtual UInt_tTPad::GetWh() const; virtual Double_tTPad::GetWNDC() const; virtual UInt_tTPad::GetWw() const; virtual Double_tTPad::GetX1() const; virtual Double_tTPad::GetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tTPad::GetXlowNDC() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Float_tTAttPad::GetYstat() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTPad::IsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTPad::IsFolder() const; virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTPad::IsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() c",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:24201,Testability,Test,TestBit,24201,"pText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TButton(); TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTPad::Update(); virtual voidTPad::UseCurrentStyle()MENU ; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidx3d(Option_t* option = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Double_t x) const; virtual voidTPad::XYtoAbsPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtual voidTPad::XYtoPixel(Double_t x, Double_t y, Int",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:24240,Testability,Test,TestBits,24240,"= 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TButton(); TButton(const char* title, const char* method, Double_t x1, Double_t y1, Double_t x2, Double_t y2); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTPad::Update(); virtual voidTPad::UseCurrentStyle()MENU ; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidx3d(Option_t* option = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Double_t x) const; virtual voidTPad::XYtoAbsPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtual voidTPad::XYtoPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel) const; virtua",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:29856,Testability,log,log,29856,"e if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarg",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:29913,Testability,log,log,29913,"2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:29970,Testability,log,log,29970,"pad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Short_tTAttText::fTextAlignT",MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TButton.html:3647,Usability,Clear,Clear,3647,,MatchSource.WIKI,root/html602/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TButton.html
https://root.cern/root/html602/TCanvas.html:1862,Availability,avail,available,1862,"*************** *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * Pad 1 * * Pad 2 * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * ************************************ ************************* *; * *; ***********************************************************************. This canvas contains two pads named P1 and P2. Both Canvas, P1 and P2 can be; moved, grown, shrinked using the normal rules of the Display manager. The image below shows a canvas with 4 pads:. Once objects have been drawn in a canvas, they can be edited/moved by pointing; directly to them. The cursor shape is changed to suggest the type of action that; one can do on this object. Clicking with the right mouse button on an object; pops-up a contextmenu with a complete list of actions possible on this object. A graphical editor may be started from the canvas ""View"" menu under the menu; entry ""Toolbar"". An interactive HELP is available by clicking on the HELP button at the top right; of the canvas. It gives a short explanation about the canvas' menus. A canvas may be automatically divided into pads via TPad::Divide. At creation time, in interactive mode, the canvas size defines the size of the; canvas window (including the window manager's decoration). To define precisely; the graphics area size of a canvas, the following four lines of code should be; used:. {; Double_t w = 600;; Double_t h = 600;; TCanvas * c1 = new TCanvas(""c"", ""c"", w, h);; c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; }. in batch mode simply do:. c->SetCanvasSize(w,h);. . Function Members (Methods); public:. virtual~TCanvas(); virtual voidTPad::AbsCoordinates(Bool_t set); virtual Double_tTPad::AbsPixeltoX(Int_t px); virtual voidTPad::AbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tTPad::AbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidTPad::AddExec(const char* name, con",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:7917,Availability,Error,Error,7917,"nal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidFlush(); voidForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tGetAutoExec() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tT",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:8084,Availability,error,error,8084,"ar* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidFlush(); voidForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tGetAutoExec() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_t",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:8168,Availability,error,error,8168,"oidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidFlush(); voidForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tGetAutoExec() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; TVirtualPadPainter*Get",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:30442,Availability,down,down,30442,,MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:39719,Availability,failure,failure,39719,"itle, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of th",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:42376,Availability,down,down,42376,"anvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Res",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:21393,Deployability,TOGGLE,TOGGLE,21393,"e_t msize); virtual voidTPad::SetAttTextPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize); virtual voidSetBatch(Bool_t batch = kTRUE); virtual voidTPad::SetBBoxCenter(const TPoint& p); virtual voidTPad::SetBBoxCenterX(const Int_t x); virtual voidTPad::SetBBoxCenterY(const Int_t y); virtual voidTPad::SetBBoxX1(const Int_t x); virtual voidTPad::SetBBoxX2(const Int_t x); virtual voidTPad::SetBBoxY1(const Int_t y); virtual voidTPad::SetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTPad::SetBorderMode(Short_t bordermode)MENU ; virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidSetCanvasSize(UInt_t ww, UInt_t wh)MENU ; voidSetClickSelected(TObject* obj); voidSetClickSelectedPad(TPad* pad); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidSetCursor(ECursor cursor); virtual voidSetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:21636,Deployability,TOGGLE,TOGGLE,21636,"const Int_t x); virtual voidTPad::SetBBoxCenterY(const Int_t y); virtual voidTPad::SetBBoxX1(const Int_t x); virtual voidTPad::SetBBoxX2(const Int_t x); virtual voidTPad::SetBBoxY1(const Int_t y); virtual voidTPad::SetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTPad::SetBorderMode(Short_t bordermode)MENU ; virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidSetCanvasSize(UInt_t ww, UInt_t wh)MENU ; voidSetClickSelected(TObject* obj); voidSetClickSelectedPad(TPad* pad); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidSetCursor(ECursor cursor); virtual voidSetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAt",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:21919,Deployability,TOGGLE,TOGGLE,21919,"::SetBit(UInt_t f, Bool_t set); virtual voidTPad::SetBorderMode(Short_t bordermode)MENU ; virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidSetCanvasSize(UInt_t ww, UInt_t wh)MENU ; voidSetClickSelected(TObject* obj); voidSetClickSelectedPad(TPad* pad); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidSetCursor(ECursor cursor); virtual voidSetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttL",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:22406,Deployability,TOGGLE,TOGGLE,22406," voidSetCursor(ECursor cursor); virtual voidSetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual void",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:22528,Deployability,TOGGLE,TOGGLE,22528,"ion = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const c",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:22580,Deployability,TOGGLE,TOGGLE,22580,"); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t x",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:23000,Deployability,TOGGLE,TOGGLE,23000,"ode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:23051,Deployability,TOGGLE,TOGGLE,23051,"e(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey ",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:23102,Deployability,TOGGLE,TOGGLE,23102,"(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TO",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:24104,Deployability,TOGGLE,TOGGLE,24104,"E ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTicky(Int_t value = 1)TOGGLE ; virtual voidSetTitle(const char* title = """"); virtual voidTPad::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); voidSetWindowPosition(Int_t x, Int_t y); voidSetWindowSize(UInt_t ww, UInt_t wh); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); voidShow(); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSize(Float_t xsizeuser = 0, Float_t ysizeuser = 0); virtual voidTPad::StartEditing()SIGNAL ; virtual voi",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:24156,Deployability,TOGGLE,TOGGLE,24156,"at_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); voidSetPadSave(TPad* pad); virtual voidTPad::SetPhi(Double_t phi = 30); voidSetRetained(Bool_t retained = kTRUE); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); voidSetSelectedPad(TPad* pad); voidSetSupportGL(Bool_t support); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetTicky(Int_t value = 1)TOGGLE ; virtual voidSetTitle(const char* title = """"); virtual voidTPad::SetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); voidSetWindowPosition(Int_t x, Int_t y); voidSetWindowSize(UInt_t ww, UInt_t wh); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); voidShow(); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSize(Float_t xsizeuser = 0, Float_t ysizeuser = 0); virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& C",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:44426,Deployability,Toggle,Toggle,44426,"rameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use this function to zoom in a canvas and naviguate via; the scroll bars. void SetCursor(ECursor cursor); Set cursor. void SetDoubleBuffer(Int_t mode = 1); Set Double Buffer On/Off. void SetFixedAspectRatio(Bool_t fixed = kTRUE); Fix canvas aspect ratio to current value if fixed is true. void SetFolder(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the p",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46124,Deployability,Toggle,ToggleAutoExec,46124,"owsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); asser",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46142,Deployability,Toggle,Toggle,46142,"owsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); asser",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46192,Deployability,Toggle,ToggleEventStatus,46192,"s. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). T",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46213,Deployability,Toggle,Toggle,46213,"s. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). T",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46242,Deployability,Toggle,ToggleToolBar,46242,"t canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46259,Deployability,Toggle,Toggle,46259,"t canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46280,Deployability,Toggle,ToggleEditor,46280,"zeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46296,Deployability,Toggle,Toggle,46296,"zeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46316,Deployability,Toggle,ToggleToolTips,46316,"he canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCan",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46334,Deployability,Toggle,Toggle,46334,"he canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCan",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46449,Deployability,Update,Update,46449,"ters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {retu",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46459,Deployability,Update,Update,46459,"ters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {retu",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46034,Energy Efficiency,allocate,allocated,46034,"r(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirt",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:14979,Integrability,Message,Message,14979,"thod, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsGrayscale(); virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; static TCanvas*MakeDefCanvas(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voidTAttLine::Modify(); voidMoveOpaque(Int_t set = 1); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpaqueMoving() const; virtual Bool_tOpaqueResizing() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static TVirtualPad*&TVirtualPad::Pad(); virtual Bool_tTVirtualPad::PadInHighlightMode() const; virtual Bool_tTVirtualPad::PadInSelectionMode() const; virtual Double_tTPad::PadtoX(Do",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:41476,Integrability,depend,depending,41476,":; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu item DrawClonePad.; Note that the original canvas may have subpads. void DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = ",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:14039,Modifiability,Inherit,InheritsFrom,14039,"GetXlowNDC() const; Size_tGetXsizeReal() const; Size_tGetXsizeUser() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Size_tGetYsizeReal() const; Size_tGetYsizeUser() const; Float_tTAttPad::GetYstat() const; virtual voidHandleInput(EEventType button, Int_t x, Int_t y); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; Bool_tHasMenuBar() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsGrayscale(); virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; static TCanvas*MakeDefCanvas(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t ",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:14105,Modifiability,Inherit,InheritsFrom,14105,"() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Size_tGetYsizeReal() const; Size_tGetYsizeUser() const; Float_tTAttPad::GetYstat() const; virtual voidHandleInput(EEventType button, Int_t x, Int_t y); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; Bool_tHasMenuBar() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsGrayscale(); virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsVertical() const; Bool_tTObject::IsZombie() const; virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; static TCanvas*MakeDefCanvas(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTPad::Modified(Bool_t flag = 1)SIGNAL ; virtual voidTAttLine::Modify(); voidMoveOpaque(I",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:36928,Modifiability,Inherit,Inheritance,36928,"TPad::fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworld; Double_tTPad::fXtoPixelkConversion coefficient for X World to pixel; Double_tTPad::fY1Y of lower Y coordinate; Double_tTPad::fY2Y of upper Y coordinate; Double_tTPad::fYUpNDC; Float_tTAttPad::fYfileY position where to draw the file name; Double_tTPad::fYlowNDCY bottom left corner of pad in NDC [0,1]; Size_tfYsizeRealCurrent size of canvas along Y in CM; Size_tfYsizeUserUser specified size of canvas along Y in CM; Float_tTAttPad::fYstatY position where to draw the statistics; Double_tTPad::fYtoAbsPixelkConversion coefficient for Y World to absolute pixel; Double_tTPad::fYtoPixelypixel = fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Bool_tfgIsFolderIndicates if canvas can be browsed as a folder; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCanvas(Bool_t build = kTRUE); Canvas default constructor. void Constructor(); Canvas default constructor. TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); Create an embedded canvas, i.e. a canvas that is in a TGCanvas widget; which is placed in a TGFrame. This ctor is only called via the; TRootEmbeddedCanvas class. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. TCanvas(const char* name, const char* title = """", Int_t form = 1); Create a new canvas with a predefined size form.; If form < 0 the menubar is not shown. form = 1 700x500 at 10,10 (set by TStyle::SetCanvasDefH,W,X,Y); form = 2 500x500 at 20,20; form = 3 500x500 at 30,30; form = 4 500x500 at 40,40; form = 5 500x500 at 50,50. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t form); Create a new canvas with a predefined size form.; If form < 0 the menubar is not shown. ",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:36941,Modifiability,Inherit,Inherited,36941,"TPad::fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworld; Double_tTPad::fXtoPixelkConversion coefficient for X World to pixel; Double_tTPad::fY1Y of lower Y coordinate; Double_tTPad::fY2Y of upper Y coordinate; Double_tTPad::fYUpNDC; Float_tTAttPad::fYfileY position where to draw the file name; Double_tTPad::fYlowNDCY bottom left corner of pad in NDC [0,1]; Size_tfYsizeRealCurrent size of canvas along Y in CM; Size_tfYsizeUserUser specified size of canvas along Y in CM; Float_tTAttPad::fYstatY position where to draw the statistics; Double_tTPad::fYtoAbsPixelkConversion coefficient for Y World to absolute pixel; Double_tTPad::fYtoPixelypixel = fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Bool_tfgIsFolderIndicates if canvas can be browsed as a folder; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCanvas(Bool_t build = kTRUE); Canvas default constructor. void Constructor(); Canvas default constructor. TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); Create an embedded canvas, i.e. a canvas that is in a TGCanvas widget; which is placed in a TGFrame. This ctor is only called via the; TRootEmbeddedCanvas class. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. TCanvas(const char* name, const char* title = """", Int_t form = 1); Create a new canvas with a predefined size form.; If form < 0 the menubar is not shown. form = 1 700x500 at 10,10 (set by TStyle::SetCanvasDefH,W,X,Y); form = 2 500x500 at 20,20; form = 3 500x500 at 30,30; form = 4 500x500 at 40,40; form = 5 500x500 at 50,50. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t form); Create a new canvas with a predefined size form.; If form < 0 the menubar is not shown. ",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:44356,Modifiability,variab,variable,44356,"cessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use this function to zoom in a canvas and naviguate via; the scroll bars. void SetCursor(ECursor cursor); Set cursor. void SetDoubleBuffer(Int_t mode = 1); Set Double Buffer On/Off. void SetFixedAspectRatio(Bool_t fixed = kTRUE); Fix canvas aspect ratio to current value if fixed is true. void SetFolder(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canv",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46991,Modifiability,plugin,plugin,46991,"caling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {retur",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:42861,Performance,response time,response time,42861,"dle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. v",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:43757,Performance,response time,response time,43757,"s drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:46971,Performance,load,loaded,46971,"caling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {retur",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:13690,Security,Hash,Hash,13690,"tVirtCanvas() const; virtual UInt_tGetWh() const; UInt_tGetWindowHeight() const; Int_tGetWindowTopX(); Int_tGetWindowTopY(); UInt_tGetWindowWidth() const; virtual Double_tTPad::GetWNDC() const; virtual UInt_tGetWw() const; virtual Double_tTPad::GetX1() const; virtual Double_tTPad::GetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tTPad::GetXlowNDC() const; Size_tGetXsizeReal() const; Size_tGetXsizeUser() const; Float_tTAttPad::GetXstat() const; virtual Double_tTPad::GetY1() const; virtual Double_tTPad::GetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tTPad::GetYlowNDC() const; Size_tGetYsizeReal() const; Size_tGetYsizeUser() const; Float_tTAttPad::GetYstat() const; virtual voidHandleInput(EEventType button, Int_t x, Int_t y); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tTPad::HasCrosshair() const; virtual Bool_tTPad::HasFixedAspectRatio() const; virtual ULong_tTPad::Hash() const; Bool_tHasMenuBar() const; virtual Bool_tTPad::HasViewer3D() const; virtual voidTPad::HighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tTVirtualPad::IsBeingResized() const; virtual Bool_tTPad::IsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsGrayscale(); virtual Bool_tTPad::IsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tTPad::IsV",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:47072,Security,Access,Access,47072," Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:25626,Testability,Test,TestBit,25626," voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); voidShow(); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSize(Float_t xsizeuser = 0, Float_t ysizeuser = 0); virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static Bool_tSupportAlpha(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCanvas(Bool_t build = kTRUE); TCanvas(const char* name, const char* title = """", Int_t form = 1); TCanvas(const char* name, const char* title, Int_t ww, Int_t wh); TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); TCanvas(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleAutoExec(); virtual voidToggleEditor(); virtual voidToggleEventStatus(); virtual voidToggleToolBar(); virtual voidToggleToolTips(); virtual voidUpdate(); virtual voidUseCurrentStyle()MENU ; Bool_tUseGL() const; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTPad::x3d(Option_t* type = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Dou",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:25665,Testability,Test,TestBits,25665,"virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); voidShow(); virtual voidTPad::ShowGuidelines(TObject* object, const Int_t event, const char mode = 'i', const bool cling = true); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSize(Float_t xsizeuser = 0, Float_t ysizeuser = 0); virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static Bool_tSupportAlpha(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCanvas(Bool_t build = kTRUE); TCanvas(const char* name, const char* title = """", Int_t form = 1); TCanvas(const char* name, const char* title, Int_t ww, Int_t wh); TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); TCanvas(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleAutoExec(); virtual voidToggleEditor(); virtual voidToggleEventStatus(); virtual voidToggleToolBar(); virtual voidToggleToolTips(); virtual voidUpdate(); virtual voidUseCurrentStyle()MENU ; Bool_tUseGL() const; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTPad::x3d(Option_t* type = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Double_t x) const; virtual voidTPad::XYtoAb",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:32719,Testability,log,log,32719,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:32776,Testability,log,log,32776,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:32833,Testability,log,log,32833,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:47147,Testability,assert,assert,47147,"e pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() co",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:48297,Testability,Test,TestBit,48297,"se(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuB",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:48367,Testability,Test,TestBit,48367," const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() c",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:48432,Testability,Test,TestBit,48432,"textMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRe",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:48498,Testability,Test,TestBit,48498,"etDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaq",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:48562,Testability,Test,TestBit,48562,") const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaque); }. Bool_t OpaqueResizing() const; { return TestBit(kResizeO",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:49275,Testability,Test,TestBit,49275,"EventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaque); }. Bool_t OpaqueResizing() const; { return TestBit(kResizeOpaque); }. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); { return TPad::Pick(px, py, pickobj); }. void RaiseWindow(); { fCanvasImp->RaiseWindow(); }. void SetWindowPosition(Int_t x, Int_t y); { fCanvasImp->SetWindowPosition(x, y); }. void SetWindowSize(UInt_t ww, UInt_t wh); { fCanvasImp->SetWindowSize(ww, wh); }. void SetHighLightColor(Color_t col); { fHighLightColor = col; }. void SetClickSelected(TObject* obj); { fClickSelected = obj; }. void SetSelectedPad(TPad* pad); { fSelectedPad = pad; }. void SetClickSelectedPad(TPad* pad); { fClickSelectedPad = pad; }. void Show(); { fCanvasImp->Show(); }. void SetPadSave(TPad* pad); {fPadSave = pad;}. void SetRetained(Bool_t retained = kTRUE); { fRetain",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:49473,Testability,Test,TestBit,49473,"etShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaque); }. Bool_t OpaqueResizing() const; { return TestBit(kResizeOpaque); }. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); { return TPad::Pick(px, py, pickobj); }. void RaiseWindow(); { fCanvasImp->RaiseWindow(); }. void SetWindowPosition(Int_t x, Int_t y); { fCanvasImp->SetWindowPosition(x, y); }. void SetWindowSize(UInt_t ww, UInt_t wh); { fCanvasImp->SetWindowSize(ww, wh); }. void SetHighLightColor(Color_t col); { fHighLightColor = col; }. void SetClickSelected(TObject* obj); { fClickSelected = obj; }. void SetSelectedPad(TPad* pad); { fSelectedPad = pad; }. void SetClickSelectedPad(TPad* pad); { fClickSelectedPad = pad; }. void Show(); { fCanvasImp->Show(); }. void SetPadSave(TPad* pad); {fPadSave = pad;}. void SetRetained(Bool_t retained = kTRUE); { fRetained=retained;}. Bool_t UseGL() const; { return fUseGL; }. void SetSupportGL(Bool_t support); {fUseGL = support;}.  Author: Rene Brun 12/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:49538,Testability,Test,TestBit,49538,"t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const; {return fCanvasID;}. TCanvasImp * GetCanvasImp() const; {return fCanvasImp;}. UInt_t GetWindowWidth() const; { return fWindowWidth; }. UInt_t GetWindowHeight() const; { return fWindowHeight; }. UInt_t GetWw() const; { return fCw; }. UInt_t GetWh() const; { return fCh; }. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); {wtopx=GetWindowTopX(); wtopy=fWindowTopY; ww=fWindowWidth; wh=fWindowHeight;}. Bool_t HasMenuBar() const; { return TestBit(kMenuBar); }. void Iconify(); { fCanvasImp->Iconify(); }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsRetained() const; { return fRetained; }. Bool_t OpaqueMoving() const; { return TestBit(kMoveOpaque); }. Bool_t OpaqueResizing() const; { return TestBit(kResizeOpaque); }. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); { return TPad::Pick(px, py, pickobj); }. void RaiseWindow(); { fCanvasImp->RaiseWindow(); }. void SetWindowPosition(Int_t x, Int_t y); { fCanvasImp->SetWindowPosition(x, y); }. void SetWindowSize(UInt_t ww, UInt_t wh); { fCanvasImp->SetWindowSize(ww, wh); }. void SetHighLightColor(Color_t col); { fHighLightColor = col; }. void SetClickSelected(TObject* obj); { fClickSelected = obj; }. void SetSelectedPad(TPad* pad); { fSelectedPad = pad; }. void SetClickSelectedPad(TPad* pad); { fClickSelectedPad = pad; }. void Show(); { fCanvasImp->Show(); }. void SetPadSave(TPad* pad); {fPadSave = pad;}. void SetRetained(Bool_t retained = kTRUE); { fRetained=retained;}. Bool_t UseGL() const; { return fUseGL; }. void SetSupportGL(Bool_t support); {fUseGL = support;}.  Author: Rene Brun 12/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gpad:$Id$  Last generated: 2015-06-30 1",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:2469,Usability,simpl,simply,2469,"they can be edited/moved by pointing; directly to them. The cursor shape is changed to suggest the type of action that; one can do on this object. Clicking with the right mouse button on an object; pops-up a contextmenu with a complete list of actions possible on this object. A graphical editor may be started from the canvas ""View"" menu under the menu; entry ""Toolbar"". An interactive HELP is available by clicking on the HELP button at the top right; of the canvas. It gives a short explanation about the canvas' menus. A canvas may be automatically divided into pads via TPad::Divide. At creation time, in interactive mode, the canvas size defines the size of the; canvas window (including the window manager's decoration). To define precisely; the graphics area size of a canvas, the following four lines of code should be; used:. {; Double_t w = 600;; Double_t h = 600;; TCanvas * c1 = new TCanvas(""c"", ""c"", w, h);; c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; }. in batch mode simply do:. c->SetCanvasSize(w,h);. . Function Members (Methods); public:. virtual~TCanvas(); virtual voidTPad::AbsCoordinates(Bool_t set); virtual Double_tTPad::AbsPixeltoX(Int_t px); virtual voidTPad::AbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tTPad::AbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidTPad::AddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTPad::AutoExec(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); virtual TLegend*TPad::BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """")MENU ; virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:39786,Usability,Clear,Clear,39786," top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse ",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:39903,Usability,clear,cleared,39903," ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu i",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:40005,Usability,Clear,Cleared,40005,"ive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu item DrawClonePad.; Note that the original canvas may have subpads. void DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected)",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:40041,Usability,Clear,Cleared,40041,"ive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu item DrawClonePad.; Note that the original canvas may have subpads. void DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected)",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:41930,Usability,Feedback,FeedbackMode,41930,"id DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TOb",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:41972,Usability,feedback,feedback,41972,"id DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TOb",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvas.html:47800,Usability,Clear,ClearPadSave,47800,"a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelectedY;}. Option_t * GetSelectedOpt() const; {return fSelectedOpt.Data();}. TVirtualPad * GetSelectedPad() const; { return fSelectedPad; }. TVirtualPad * GetClickSelectedPad() const; { return fClickSelectedPad; }. Bool_t GetShowEventStatus() const; { return TestBit(kShowEventStatus); }. Bool_t GetShowToolBar() const; { return TestBit(kShowToolBar); }. Bool_t GetShowEditor() const; { return TestBit(kShowEditor); }. Bool_t GetShowToolTips() const; { return TestBit(kShowToolTips); }. Bool_t GetAutoExec() const; { return TestBit(kAutoExec); }. Size_t GetXsizeUser() const; {return fXsizeUser;}. Size_t GetYsizeUser() const; {return fYsizeUser;}. Size_t GetXsizeReal() const; {return fXsizeReal;}. Size_t GetYsizeReal() const; {return fYsizeReal;}. Int_t GetCanvasID() const",MatchSource.WIKI,root/html602/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvas.html
https://root.cern/root/html602/TCanvasImp.html:2006,Modifiability,Inherit,Inheritance,2006,"indowPosition(Int_t x, Int_t y); virtual voidSetWindowSize(UInt_t w, UInt_t h); virtual voidSetWindowTitle(const char* newTitle); virtual voidShow(); virtual voidShowEditor(Bool_t show = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidShowMenuBar(Bool_t show = kTRUE); virtual voidShowStatusBar(Bool_t show = kTRUE); virtual voidShowToolBar(Bool_t show = kTRUE); virtual voidShowToolTips(Bool_t show = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TCanvasImp(TCanvas* c = 0); TCanvasImp(TCanvas* c, const char* name, UInt_t width, UInt_t height); TCanvasImp(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height). protected:. virtual Bool_tIsLocked(); virtual voidLock(); TCanvasImp&operator=(const TCanvasImp& ci); TCanvasImp(const TCanvasImp& ci); virtual voidUnlock(). Data Members; protected:. TCanvas*fCanvasTCanvas associated with this implementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline TCanvasImp(TCanvas* c, const char* name, UInt_t width, UInt_t height); { }. inline TCanvasImp(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height); { }. UInt_t GetWindowGeometry(Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); { x = y = 0; w = h = 0; return 0;}. void SetStatusText(const char* text = 0, Int_t partidx = 0); { }. void SetWindowPosition(Int_t x, Int_t y); { }. void SetWindowSize(UInt_t w, UInt_t h); { }. void SetWindowTitle(const char* newTitle); { }. void SetCanvasSize(UInt_t w, UInt_t h); { }. void ShowMenuBar(Bool_t show = kTRUE); { }. void ShowStatusBar(Bool_t show = kTRUE); { }. void RaiseWindow(); { }. void ReallyDelete(); { }. void ShowEditor(Bool_t show = kTRUE); { }. void ShowToolBar(Bool_t show = kTRUE); { }. void ShowToolTips(Bool_t show = kTRUE); { }. TCanvasImp(const TCanvasImp& ci); { }. TCanvasImp& operator=(const TCanvasImp& ci); {if(this!=&ci) fCanvas=ci.fCanvas; return *this;}. vo",MatchSource.WIKI,root/html602/TCanvasImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvasImp.html
https://root.cern/root/html602/TCanvasImp.html:2019,Modifiability,Inherit,Inherited,2019,"indowPosition(Int_t x, Int_t y); virtual voidSetWindowSize(UInt_t w, UInt_t h); virtual voidSetWindowTitle(const char* newTitle); virtual voidShow(); virtual voidShowEditor(Bool_t show = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidShowMenuBar(Bool_t show = kTRUE); virtual voidShowStatusBar(Bool_t show = kTRUE); virtual voidShowToolBar(Bool_t show = kTRUE); virtual voidShowToolTips(Bool_t show = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TCanvasImp(TCanvas* c = 0); TCanvasImp(TCanvas* c, const char* name, UInt_t width, UInt_t height); TCanvasImp(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height). protected:. virtual Bool_tIsLocked(); virtual voidLock(); TCanvasImp&operator=(const TCanvasImp& ci); TCanvasImp(const TCanvasImp& ci); virtual voidUnlock(). Data Members; protected:. TCanvas*fCanvasTCanvas associated with this implementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline TCanvasImp(TCanvas* c, const char* name, UInt_t width, UInt_t height); { }. inline TCanvasImp(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height); { }. UInt_t GetWindowGeometry(Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); { x = y = 0; w = h = 0; return 0;}. void SetStatusText(const char* text = 0, Int_t partidx = 0); { }. void SetWindowPosition(Int_t x, Int_t y); { }. void SetWindowSize(UInt_t w, UInt_t h); { }. void SetWindowTitle(const char* newTitle); { }. void SetCanvasSize(UInt_t w, UInt_t h); { }. void ShowMenuBar(Bool_t show = kTRUE); { }. void ShowStatusBar(Bool_t show = kTRUE); { }. void RaiseWindow(); { }. void ReallyDelete(); { }. void ShowEditor(Bool_t show = kTRUE); { }. void ShowToolBar(Bool_t show = kTRUE); { }. void ShowToolTips(Bool_t show = kTRUE); { }. TCanvasImp(const TCanvasImp& ci); { }. TCanvasImp& operator=(const TCanvasImp& ci); {if(this!=&ci) fCanvas=ci.fCanvas; return *this;}. vo",MatchSource.WIKI,root/html602/TCanvasImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCanvasImp.html
https://root.cern/root/html602/TChain.html:5170,Availability,Error,Error,5170,"ion_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:5299,Availability,error,error,5299,"p1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const;",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:5383,Availability,error,error,5383,"tive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const; virtual Bool_tGetBranchStatus(const char* branchname) const; static Int_tTTree::Get",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:39612,Availability,error,error,39612," closing a file during the chain processing, the file; may be closed with option ""R"" if flag is set to kTRUE.; by default flag is kTRUE.; When closing a file with option ""R"", all TProcessIDs referenced by this; file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. void CreatePackets(); -- Initialize the packet descriptor string. void DirectoryAutoAdd(TDirectory* ); Override the TTree::DirectoryAutoAdd behavior:; we never auto add. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Draw expression varexp for selected entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +, example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain and draw histogram corresponding to; expression varexp.; Returns -1 in case of error or number of selected events in case of success. TBranch* FindBranch(const char* name); -- See TTree::GetReadEntry(). TLeaf* FindLeaf(const char* name); -- See TTree::GetReadEntry(). const char* GetAlias(const char* aliasName) const; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator ",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:40049,Availability,error,error,40049,"being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. void CreatePackets(); -- Initialize the packet descriptor string. void DirectoryAutoAdd(TDirectory* ); Override the TTree::DirectoryAutoAdd behavior:; we never auto add. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Draw expression varexp for selected entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +, example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain and draw histogram corresponding to; expression varexp.; Returns -1 in case of error or number of selected events in case of success. TBranch* FindBranch(const char* name); -- See TTree::GetReadEntry(). TLeaf* FindLeaf(const char* name); -- See TTree::GetReadEntry(). const char* GetAlias(const char* aliasName) const; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator over the cluster of baskets starting at firstentry. This iterator is not yet supported for TChain object. Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The input parameter entry is the entry number in; the current tree of this chain. Long64_t GetEntries() const; -- Return the total number of entries in the chain.; In case the number of entries in each tree is not yet known,; the of",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:41315,Availability,failure,failure,41315,"t; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator over the cluster of baskets starting at firstentry. This iterator is not yet supported for TChain object. Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The input parameter entry is the entry number in; the current tree of this chain. Long64_t GetEntries() const; -- Return the total number of entries in the chain.; In case the number of entries in each tree is not yet known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the curren",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:42495,Availability,failure,failure,42495,"try list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all b",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:43838,Availability,error,error,43838,"branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:51016,Availability,error,error,51016,"presses the search for the url fragment; identifier and limits the query identifier search to cases; where the tree name is given as a trailing slash-separated; string at the end of the file name.; Outpus:; filename - the url or filename to be opened or matched; treename - the treename, which may be found as a trailing part of the; name or in a url fragment section. If not found this will; be empty.; query - is the url query section, including the leading question; mark. If not found or the query section is only followed by; a fragment this will be empty.; suffix - the portion of name which was removed to form filename. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. Long64_t Process(TSelector* selector, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If var",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:51299,Availability,error,error,51299,"ame, which may be found as a trailing part of the; name or in a url fragment section. If not found this will; be empty.; query - is the url query section, including the leading question; mark. If not found or the query section is only followed by; a fragment this will be empty.; suffix - the portion of name which was removed to form filename. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. Long64_t Process(TSelector* selector, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; ",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:54445,Availability,error,error,54445,"c of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); -- Set branch status to Process or DoNotProcess. bname is the name of a branch. if bname=""*"", apply to all branches.; status = 1 branch will be processed; = 0 branch will not be processed; See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of ent",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:55576,Availability,error,error,55576,"irectory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() functi",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:16811,Deployability,update,updateExisting,16811,"e = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cacheSize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLin",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:58214,Deployability,Release,ReleaseChainProof,58214,"E the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used with; care because it may take a long time to execute. void SetWeight(Double_t w = 1, Option_t* option = """"); -- Set chain weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram.; For example the equivalent of; chain.Draw(""x"",""w""); is; chain.SetWeight(w,""global"");; chain.Draw(""x"");. By default the weight used will be the weight; of each Tree in the TChain. However, one can force the individual; weights to be ignored by specifying the option ""global"".; In this case, the TChain global weight will be used for all Trees. void Streamer(TBuffer& ); -- Stream a class object. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); -- Dummy function kept for back compatibility.; The cache is now activated automatically when processing TTrees/TChain. TChain(const TChain& ). TChain& operator=(const TChain& ). void ReleaseChainProof(). Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0). Int_t Fill(); { MayNotUse(""Fill()""); return -1; }. Long64_t GetCacheSize() const; { return fTree ? fTree->GetCacheSize() : fCacheSize; }. Int_t GetNtrees() const; { return fNtrees; }. Long64_t GetEntries() const. TObjArray * GetListOfFiles() const; Warning, GetListOfFiles returns the list of TChainElements (not the list of files); see TChain::AddFile to see how to get the corresponding TFile objects. {return fFiles;}. TList * GetStatus() const; { return fStatus; }. TTree * GetTree() const; { return fTree; }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Long64_t * GetTreeOffset() const; { return fTreeOffset; }. Int_t GetTreeOffsetLen() const; { return fTreeOffsetLen; }. void SetMakeClass(Int_t make); { TTree::SetMakeClass(make); if (fTree) fTree->SetMakeClass(make);}.  Author: Rene Brun 03/02/97  Copyright (C) 1995-2000, Rene ",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:26534,Energy Efficiency,allocate,allocated,26534,"entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); TFile*fFile! Pointer to current file (We own the file).; Int_tTTree::fFileNumber! current file number (if file extensions); TObjArray*fFiles-> List of file names containing the trees (TChainElement, owned); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNtreesNumber of trees; In",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:32501,Energy Efficiency,efficient,efficient,32501,"an contain a query identifier without tree_name, but; generally urls can not be written with them because of ambiguity with the; wildcard character. (Also see the documentaiton for TChain::AddFile,; which does not support wildcards but allows the url to contain query). NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be connected to read an entry.; This option is the default and very efficient if one process; the chain sequentially. Note that in case TChain::GetEntry(entry); is called and entry refers to an entry in the 3rd file, for example,; this forces the Tree headers in the first and second file; to be read to find the number of entries in these files.; Note that if one calls TChain::GetEntriesFast() after having created; a chain with this default, GetEntriesFast will return kBigNumber!; TChain::GetEntries will force of the Tree headers in the chain to be; read to read the number of entries in each Tree. D- The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:35203,Energy Efficiency,efficient,efficient,35203,"l fragment. eg.; root://machine/path/file_name.root?query#tree_name. If tree_name is given as a part of the file name it is used to; as the name of the tree to load from the file. Otherwise if tname; argument is specified the chain will load the tree named tname from; the file, otherwise the original treename specified in the TChain; constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. Note that if one calls GetEntriesFast() after having created; a chain with this default, GetEntriesFast() will return kBigNumber!; Using the GetEntries() function instead will force all of the tree; headers in the chain to be read to read the number of entries in; each tree. D. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. The function returns 1 if the file is successfully",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:31429,Integrability,depend,depending,31429,")) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. ~TChain(); -- Destructor. Int_t Add(TChain* chain); -- Add all files referenced by the passed chain to this chain.; The function returns the total number of files connected. Int_t Add(const char* name, Long64_t nentries = kBigNumber); -- Add a new file to this chain. Argument name may have either of two formats. The first:; [//machine]/path/file_name.root[/tree_name]. If tree_name is missing the chain name will be assumed.; Wildcard treatment is triggered by the any of the special characters []*?; which may be used in the file name, eg. specifying ""xxx*.root"" adds; all files starting with xxx in the current file system directory. Alternatively name may have the format of a url, eg.; root://machine/path/file_name.root; or root://machine/path/file_name.root/tree_name; or root://machine/path/file_name.root/tree_name?query. where ""query"" is to be interpreted by the remote server. Wildcards may be; supported in urls, depending on the protocol plugin and the remote server.; http or https urls can contain a query identifier without tree_name, but; generally urls can not be written with them because of ambiguity with the; wildcard character. (Also see the documentaiton for TChain::AddFile,; which does not support wildcards but allows the url to contain query). NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be co",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:31446,Integrability,protocol,protocol,31446,")) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. ~TChain(); -- Destructor. Int_t Add(TChain* chain); -- Add all files referenced by the passed chain to this chain.; The function returns the total number of files connected. Int_t Add(const char* name, Long64_t nentries = kBigNumber); -- Add a new file to this chain. Argument name may have either of two formats. The first:; [//machine]/path/file_name.root[/tree_name]. If tree_name is missing the chain name will be assumed.; Wildcard treatment is triggered by the any of the special characters []*?; which may be used in the file name, eg. specifying ""xxx*.root"" adds; all files starting with xxx in the current file system directory. Alternatively name may have the format of a url, eg.; root://machine/path/file_name.root; or root://machine/path/file_name.root/tree_name; or root://machine/path/file_name.root/tree_name?query. where ""query"" is to be interpreted by the remote server. Wildcards may be; supported in urls, depending on the protocol plugin and the remote server.; http or https urls can contain a query identifier without tree_name, but; generally urls can not be written with them because of ambiguity with the; wildcard character. (Also see the documentaiton for TChain::AddFile,; which does not support wildcards but allows the url to contain query). NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be co",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:42439,Integrability,rout,routine,42439,"set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); --",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:44212,Integrability,rout,routine,44212,"ning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So in a case where we have:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will have not subdirectory. To recreate; the directory structure do:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.M",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:44960,Integrability,rout,routine,44960,"e requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So in a case where we have:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will have not subdirectory. To recreate; the directory structure do:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. Long64_t Merge(TCollection* list, Option_t* option = """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is s",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:46455,Integrability,rout,routine,46455,"nfo); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _l",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:49506,Integrability,depend,depends,49506,"fast mode, the check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in general the automatic file overflow described; above may happen during the merge.; If only the current file is produced (the file passed as first argument),; one can instruct Merge to not close and delete the file by specifying; the option ""keep"". The function returns the total number of files produced.; To check that all files have been merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void ParseTreeFilename(const char* name, TString& filename, TString& treename, TString& query, TString& suffix, Bool_t wildcards) const; -- Get the tree url or filename and other information from the name. A treename and a url's query section is split off from name. The; splitting depends on whether the resulting filename is to be; subsequently treated for wildcards or not, since the question mark is; both the url query identifier and a wildcard. Wildcard matching is not; done in this method itself. /a/path/file.root[/treename]; xxx://a/path/file.root[/treename][?query]; xxx://a/path/file.root[?query[#treename]]. Inputs:; name - is the original name; wildcards - indicates if the resulting filename will be treated for; wildcards. For backwards compatibility, with most protocols; this flag suppresses the search for the url fragment; identifier and limits the query identifier search to cases; where the tree name is given as a trailing slash-separated; string at the end of the file name.; Outpus:; filename - the url or filename to be opened or matched; treename - the treename, which may be found as a trailing part of the; name or in a url fragment section. If not found this will; be empty.; query - is the url query section, including the leading question; mark. If not found or the query section is only followed by; a fragment this will be e",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:50002,Integrability,protocol,protocols,50002,"en merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void ParseTreeFilename(const char* name, TString& filename, TString& treename, TString& query, TString& suffix, Bool_t wildcards) const; -- Get the tree url or filename and other information from the name. A treename and a url's query section is split off from name. The; splitting depends on whether the resulting filename is to be; subsequently treated for wildcards or not, since the question mark is; both the url query identifier and a wildcard. Wildcard matching is not; done in this method itself. /a/path/file.root[/treename]; xxx://a/path/file.root[/treename][?query]; xxx://a/path/file.root[?query[#treename]]. Inputs:; name - is the original name; wildcards - indicates if the resulting filename will be treated for; wildcards. For backwards compatibility, with most protocols; this flag suppresses the search for the url fragment; identifier and limits the query identifier search to cases; where the tree name is given as a trailing slash-separated; string at the end of the file name.; Outpus:; filename - the url or filename to be opened or matched; treename - the treename, which may be found as a trailing part of the; name or in a url fragment section. If not found this will; be empty.; query - is the url query section, including the leading question; mark. If not found or the query section is only followed by; a fragment this will be empty.; suffix - the portion of name which was removed to form filename. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:54451,Integrability,message,message,54451,"c of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); -- Set branch status to Process or DoNotProcess. bname is the name of a branch. if bname=""*"", apply to all branches.; status = 1 branch will be processed; = 0 branch will not be processed; See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of ent",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:10843,Modifiability,Inherit,InheritsFrom,10843,"t size); virtual TTree*GetTree() const; virtual TVirtualIndex*TTree::GetTreeIndex() const; virtual Int_tGetTreeNumber() const; Long64_t*GetTreeOffset() const; Int_tGetTreeOffsetLen() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTTree::GetUpdate() const; virtual TList*TTree::GetUserInfo(); virtual Double_t*TTree::GetV1(); virtual Double_t*TTree::GetV2(); virtual Double_t*TTree::GetV3(); virtual Double_t*TTree::GetV4(); virtual Double_t*TTree::GetVal(Int_t i); TTreeFormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tGetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofil",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:10909,Modifiability,Inherit,InheritsFrom,10909,"e::GetTreeIndex() const; virtual Int_tGetTreeNumber() const; Long64_t*GetTreeOffset() const; Int_tGetTreeOffsetLen() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTTree::GetUpdate() const; virtual TList*TTree::GetUserInfo(); virtual Double_t*TTree::GetV1(); virtual Double_t*TTree::GetV2(); virtual Double_t*TTree::GetV3(); virtual Double_t*TTree::GetV4(); virtual Double_t*TTree::GetVal(Int_t i); TTreeFormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tGetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, In",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:28175,Modifiability,variab,variables,28175,"er interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTreeNumber! Current Tree number in fTreeOffset table; Long64_t*fTreeOffset[fTreeOffsetLen] Array of variables; Int_tfTreeOffsetLenCurrent size of fTreeOffset array; Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new elem",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:29291,Modifiability,Inherit,Inheritance,29291,"nter to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new element to this chain. In case the Tree is in a subdirectory, do, eg:; TChain ch(""subdir/treename"");. Example:; Suppose we have 3 files f1.root, f2.root and f3.root. Each file; contains a TTree object named ""T"".; TChain ch(""T""); creates a chain to process a Tree called ""T""; ch.Add(""f1.root"");; ch.Add(""f2.root"");; ch.Add(""f3.root"");; ch.Draw(""x"");; The Draw function above will process the variable ""x"" in Tree ""T""; reading sequentially the 3 files in the chain ch. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileEle",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:29304,Modifiability,Inherit,Inherited,29304,"nter to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new element to this chain. In case the Tree is in a subdirectory, do, eg:; TChain ch(""subdir/treename"");. Example:; Suppose we have 3 files f1.root, f2.root and f3.root. Each file; contains a TTree object named ""T"".; TChain ch(""T""); creates a chain to process a Tree called ""T""; ch.Add(""f1.root"");; ch.Add(""f2.root"");; ch.Add(""f3.root"");; ch.Draw(""x"");; The Draw function above will process the variable ""x"" in Tree ""T""; reading sequentially the 3 files in the chain ch. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileEle",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:30025,Modifiability,variab,variable,30025,"tatic TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new element to this chain. In case the Tree is in a subdirectory, do, eg:; TChain ch(""subdir/treename"");. Example:; Suppose we have 3 files f1.root, f2.root and f3.root. Each file; contains a TTree object named ""T"".; TChain ch(""T""); creates a chain to process a Tree called ""T""; ch.Add(""f1.root"");; ch.Add(""f2.root"");; ch.Add(""f3.root"");; ch.Draw(""x"");; The Draw function above will process the variable ""x"" in Tree ""T""; reading sequentially the 3 files in the chain ch. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. ~TChain(); -- Destructor. Int_t Add(TChain* chain); -- Add all files referenced by the passed chain to this chain.; The function returns the total number of files connected. Int_t Add(const char* name, Long64_t nentries = kBigNumber); -- Add a new file to this chain. Argument name may have either of two formats. The first:; [//machine]/path/file_name.root[/tree_name]. If tree_name is missing the chain name will be assumed.; Wildcard treatment is triggered by the any of the special characters []*?; which may be used in the file ",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:31455,Modifiability,plugin,plugin,31455,")) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. ~TChain(); -- Destructor. Int_t Add(TChain* chain); -- Add all files referenced by the passed chain to this chain.; The function returns the total number of files connected. Int_t Add(const char* name, Long64_t nentries = kBigNumber); -- Add a new file to this chain. Argument name may have either of two formats. The first:; [//machine]/path/file_name.root[/tree_name]. If tree_name is missing the chain name will be assumed.; Wildcard treatment is triggered by the any of the special characters []*?; which may be used in the file name, eg. specifying ""xxx*.root"" adds; all files starting with xxx in the current file system directory. Alternatively name may have the format of a url, eg.; root://machine/path/file_name.root; or root://machine/path/file_name.root/tree_name; or root://machine/path/file_name.root/tree_name?query. where ""query"" is to be interpreted by the remote server. Wildcards may be; supported in urls, depending on the protocol plugin and the remote server.; http or https urls can contain a query identifier without tree_name, but; generally urls can not be written with them because of ambiguity with the; wildcard character. (Also see the documentaiton for TChain::AddFile,; which does not support wildcards but allows the url to contain query). NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be co",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:37300,Modifiability,variab,variable,37300," kBigNumber); Add all files referenced in the list to the chain. The object type in the; list must be either TFileInfo or TObjString or TUrl .; The function return 1 if successful, 0 otherwise. TFriendElement* AddFriend(const char* chainname, const char* dummy = """"); -- Add a TFriendElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* ch",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:37531,Modifiability,variab,variable,37531,"dElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the c",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:37580,Modifiability,variab,variable,37580,"dElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the c",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:37690,Modifiability,variab,variable,37690,"iend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the chain. void CanDeleteRefs(Bool_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" i",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:37730,Modifiability,variab,variable,37730,"iend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the chain. void CanDeleteRefs(Bool_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" i",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:37762,Modifiability,variab,variable,37762,"iend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the chain. void CanDeleteRefs(Bool_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" i",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:11415,Performance,Load,LoadTreeFriend,11415,"Var2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tGetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tMerge(const char* name, Option_t* option = """"); virtual Long64_tMerge(TCollection* list, Option_t* option = """"); virtual Long64_tMerge(TCollection* list, TFileMergeInfo* info); virtual Long64_tMerge(TFile* file, Int_t basketsize, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:12976,Performance,Optimiz,OptimizeBaskets,12976,") const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tMerge(const char* name, Option_t* option = """"); virtual Long64_tMerge(TCollection* list, Option_t* option = """"); virtual Long64_tMerge(TCollection* list, TFileMergeInfo* info); virtual Long64_tMerge(TFile* file, Int_t basketsize, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTTree::OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:16523,Performance,cache,cacheSize,16523,"as(const char* aliasName, const char* aliasFormula); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cacheSize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTA",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:21991,Performance,cache,cacheSize,21991,"ar* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidInvalidateCurrentTree(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidReleaseChainProof(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TChain&operator=(const TChain&); voidParseTreeFilename(const char* name, TString& filename, TString& treename, TString& query, TString& suffix, Bool_t wildcards) const; TChain(const TChain&). Data ",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:24358,Performance,cache,cache,24358,"tusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TChain::(anonymous)kProofLite; static TChain::(anonymous)kProofUptodate; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Bool_tfCanDeleteRefs! If true, TProcessIDs are deleted when closing a file; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTre",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:24502,Performance,cache,cache,24502,"tusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TChain::(anonymous)kProofLite; static TChain::(anonymous)kProofUptodate; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Bool_tfCanDeleteRefs! If true, TProcessIDs are deleted when closing a file; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTre",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:27019,Performance,load,loading,27019,"h_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNtreesNumber of trees; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TChain*fProofChain! chain proxy when going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TList*fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTreeNumber! Current Tree number in fTreeOffset table; Long64_t*fTreeOffset[fTreeOffsetLen] Array of variables; Int_tfTreeOffsetLenCurrent size of fTreeOffset array; Int_tTT",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:34369,Performance,load,load,34369,"El=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber) and no; wildcarding is used, ALWAYS returns 1 without regard to whether; the file exists or contains the correct tree. If wildcarding is used, regardless of the value of nentries,; returns the number of files matching the name without regard to; whether they contain the correct tree. If nentries<=0 and wildcarding is not used, return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. Filename formats are similar to TChain::Add. Wildcards are not; applied. urls may also contain query and fragment identifiers; where the tree name can be specified in the url fragment. eg.; root://machine/path/file_name.root?query#tree_name. If tree_name is given as a part of the file name it is used to; as the name of the tree to load from the file. Otherwise if tname; argument is specified the chain will load the tree named tname from; the file, otherwise the original treename specified in the TChain; constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in th",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:34446,Performance,load,load,34446,"ng the default of kBigNumber) and no; wildcarding is used, ALWAYS returns 1 without regard to whether; the file exists or contains the correct tree. If wildcarding is used, regardless of the value of nentries,; returns the number of files matching the name without regard to; whether they contain the correct tree. If nentries<=0 and wildcarding is not used, return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. Filename formats are similar to TChain::Add. Wildcards are not; applied. urls may also contain query and fragment identifiers; where the tree name can be specified in the url fragment. eg.; root://machine/path/file_name.root?query#tree_name. If tree_name is given as a part of the file name it is used to; as the name of the tree to load from the file. Otherwise if tname; argument is specified the chain will load the tree named tname from; the file, otherwise the original treename specified in the TChain; constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. N",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:41545,Performance,load,loads,41545," branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator over the cluster of baskets starting at firstentry. This iterator is not yet supported for TChain object. Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The input parameter entry is the entry number in; the current tree of this chain. Long64_t GetEntries() const; -- Return the total number of entries in the chain.; In case the number of entries in each tree is not yet known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 o",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:42074,Performance,load,loaded,42074,"t known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. ",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:43401,Performance,Load,LoadBaskets,43401,"TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTR",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:43482,Performance,load,load,43482,"s 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """"",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:43575,Performance,Load,LoadBasket,43575,"f leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentrie",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:43619,Performance,Load,LoadTree,43619,"r* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:43845,Performance,Load,LoadTree,43845,"branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:46248,Performance,Load,Load,46248,"ion* list, Option_t* option = """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. th",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:47551,Performance,optimiz,optimize,47551,"ure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW. When merging many files, it may happen that the resulting file; reaches a size > TTree::fgMaxTreeSize (default = 1.9 GBytes).; In this case the current file is automatically closed and a new; file started. If the name of the merged file was ""merged.root"",; the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; etc. fgMaxTreeSize may be modified via the static function; TTree::SetMaxTreeSize.; When in fast mode, the check and switch is only don",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:47747,Performance,perform,performance,47747,"'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW. When merging many files, it may happen that the resulting file; reaches a size > TTree::fgMaxTreeSize (default = 1.9 GBytes).; In this case the current file is automatically closed and a new; file started. If the name of the merged file was ""merged.root"",; the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; etc. fgMaxTreeSize may be modified via the static function; TTree::SetMaxTreeSize.; When in fast mode, the check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in genera",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:52258,Performance,Load,LoadTree,52258," case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement objec",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:52267,Performance,load,loads,52267," case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement objec",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:52452,Performance,cache,cacheSize,52452,"his TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAd",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:52477,Performance,cache,cache,52477,"his TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void SetCacheSize(Long64_t cacheSize = -1); Set the cache size of the underlying TTree,; See TTree::SetCacheSize. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAd",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:55452,Performance,load,loads,55452,"nown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned b",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:55651,Performance,load,loaded,55651,"irectory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() functi",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:56270,Performance,load,loads,56270,"to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() function is called, the TEntryList is not owned by the chain; any more and will not be deleted with it. void SetPacketSize(Int_t size = 100); -- Set number of entries per packet for parallel root. void SetProof(Bool_t on = kTRUE, Bool_t refresh = kFALSE, Bool_t gettreeheader = kFALSE); Enable/Disable PROOF processing on the current default Proof (gProof). ""Draw"" and ""Processed"" commands will be handled by PROOF.; The refresh and gettreeheader are meaningfull only if on == kTRUE.; If refresh is kTRUE the underlying fProofChain (chain proxy) is always; rebuilt (even if already existing).; If gettreeheader is kTRUE the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used wit",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:58082,Performance,cache,cache,58082,"underlying fProofChain (chain proxy) is always; rebuilt (even if already existing).; If gettreeheader is kTRUE the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used with; care because it may take a long time to execute. void SetWeight(Double_t w = 1, Option_t* option = """"); -- Set chain weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram.; For example the equivalent of; chain.Draw(""x"",""w""); is; chain.SetWeight(w,""global"");; chain.Draw(""x"");. By default the weight used will be the weight; of each Tree in the TChain. However, one can force the individual; weights to be ignored by specifying the option ""global"".; In this case, the TChain global weight will be used for all Trees. void Streamer(TBuffer& ); -- Stream a class object. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); -- Dummy function kept for back compatibility.; The cache is now activated automatically when processing TTrees/TChain. TChain(const TChain& ). TChain& operator=(const TChain& ). void ReleaseChainProof(). Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0). Int_t Fill(); { MayNotUse(""Fill()""); return -1; }. Long64_t GetCacheSize() const; { return fTree ? fTree->GetCacheSize() : fCacheSize; }. Int_t GetNtrees() const; { return fNtrees; }. Long64_t GetEntries() const. TObjArray * GetListOfFiles() const; Warning, GetListOfFiles returns the list of TChainElements (not the list of files); see TChain::AddFile to see how to get the corresponding TFile objects. {return fFiles;}. TList * GetStatus() const; { return fStatus; }. TTree * GetTree() const; { return fTree; }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Long64_t * GetTreeOffset() const; { return fTreeOffset; }. Int_t GetTreeOffsetLen() const; { return fTreeOffsetLen; }. void SetMakeClass(Int_t make); { TTree::SetMakeClass(",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:10677,Security,Hash,Hash,10677,"tual Int_tTTree::GetTimerInterval() const; virtual const char*TNamed::GetTitle() const; virtual Long64_tTTree::GetTotBytes() const; TBuffer*TTree::GetTransientBuffer(Int_t size); virtual TTree*GetTree() const; virtual TVirtualIndex*TTree::GetTreeIndex() const; virtual Int_tGetTreeNumber() const; Long64_t*GetTreeOffset() const; Int_tGetTreeOffsetLen() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTTree::GetUpdate() const; virtual TList*TTree::GetUserInfo(); virtual Double_t*TTree::GetV1(); virtual Double_t*TTree::GetV2(); virtual Double_t*TTree::GetV3(); virtual Double_t*TTree::GetV4(); virtual Double_t*TTree::GetVal(Int_t i); TTreeFormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tGetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tLoadBaskets(Long64_t maxmemory); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); voidLookup(Bool_t force = kFALSE); virtual voidLoop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:37286,Security,access,access,37286," kBigNumber); Add all files referenced in the list to the chain. The object type in the; list must be either TFileInfo or TObjString or TUrl .; The function return 1 if successful, 0 otherwise. TFriendElement* AddFriend(const char* chainname, const char* dummy = """"); -- Add a TFriendElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* ch",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:19804,Testability,Test,TestBit,19804,"e(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTree::SetNotify(TObject* obj); virtual voidTTree::SetObject(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPacketSize(Int_t size = 100); virtual voidTTree::SetParallelUnzip(Bool_t opt = kTRUE, Float_t RelSize = -1); virtual voidTTree::SetPerfStats(TVirtualPerfStats* perf); virtual voidSetProof(Bool_t on = kTRUE, Bool_t refresh = kFALSE, Bool_t gettreeheader = kFALSE); virtual voidTTree::SetScanField(Int_t n = 50)MENU ; virtual voidTTree::SetTimerInterval(Int_t msec = 333); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTTree::SetTreeIndex(TVirtualIndex* index); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTTree::SetUpdate(Int_t freq = 0); virtual voidSetWeight(Double_t w = 1, Option_t* option = """"); virtual voidTTree::Show(Long64_t entry = -1, Int_t lenmax = 20); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidTTree::StartViewer()MENU ; virtual voidTTree::StopCacheLearningPhase(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChain(); TChain(const char* name, const char* title = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Int_tTTree::UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidUseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); virtual voidTTree::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:19843,Testability,Test,TestBits,19843,"e(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTree::SetNotify(TObject* obj); virtual voidTTree::SetObject(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPacketSize(Int_t size = 100); virtual voidTTree::SetParallelUnzip(Bool_t opt = kTRUE, Float_t RelSize = -1); virtual voidTTree::SetPerfStats(TVirtualPerfStats* perf); virtual voidSetProof(Bool_t on = kTRUE, Bool_t refresh = kFALSE, Bool_t gettreeheader = kFALSE); virtual voidTTree::SetScanField(Int_t n = 50)MENU ; virtual voidTTree::SetTimerInterval(Int_t msec = 333); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTTree::SetTreeIndex(TVirtualIndex* index); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTTree::SetUpdate(Int_t freq = 0); virtual voidSetWeight(Double_t w = 1, Option_t* option = """"); virtual voidTTree::Show(Long64_t entry = -1, Int_t lenmax = 20); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidTTree::StartViewer()MENU ; virtual voidTTree::StopCacheLearningPhase(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChain(); TChain(const char* name, const char* title = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Int_tTTree::UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidUseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); virtual voidTTree::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:46196,Testability,test,test,46196,"E"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. Long64_t Merge(TCollection* list, Option_t* option = """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are wri",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:3471,Usability,Clear,Clear,3471,"ddobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const ch",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChain.html:3795,Usability,undo,undo,3795,"nchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root/html602/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChain.html
https://root.cern/root/html602/TChainElement.html:1226,Availability,Error,Error,1226," virtual~TChainElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOpt",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:1355,Availability,error,error,1355," virtual~TChainElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOpt",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:1439,Availability,error,error,1439,"nst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const; virtual Int_tGetPacketSize() const; virtual Int_tGetStatus() const; virtual const ",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:7025,Deployability,update,updated,7025,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:2734,Modifiability,Inherit,InheritsFrom,2734,"st TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const; virtual Int_tGetPacketSize() const; virtual Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tHasBeenLookedUp(); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* ",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:2800,Modifiability,Inherit,InheritsFrom,2800,"const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const; virtual Int_tGetPacketSize() const; virtual Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tHasBeenLookedUp(); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TChainElement&operator=(const TChainElement&); virtual voidTO",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:7461,Modifiability,Inherit,Inheritance,7461,"BitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassName() const; { return fBaddressClassName; }. Bool_t GetBaddressIsPtr() const; { return fBaddressIsPtr; }. UInt_t GetBaddressType() const; { return fBaddressType; }. TBranch ** GetBranchPtr() const; { return fBranchPtr; }. Long64_t GetEntries() const; {return fEntries;}. char * GetPackets() const; {return fPackets;}. Int_t GetPacketSize() const; {return fPacketSize;}. Int_t ",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:7474,Modifiability,Inherit,Inherited,7474,"BitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassName() const; { return fBaddressClassName; }. Bool_t GetBaddressIsPtr() const; { return fBaddressIsPtr; }. UInt_t GetBaddressType() const; { return fBaddressType; }. TBranch ** GetBranchPtr() const; { return fBranchPtr; }. Long64_t GetEntries() const; {return fEntries;}. char * GetPackets() const; {return fPackets;}. Int_t GetPacketSize() const; {return fPacketSize;}. Int_t ",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:7038,Performance,load,loading,7038,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:2624,Security,Hash,Hash,2624,"ar*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const; virtual Int_tGetPacketSize() const; virtual Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tHasBeenLookedUp(); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:5450,Testability,Test,TestBit,5450,"t::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetBaddress(void* add); virtual voidSetBaddressClassName(const char* clname); virtual voidSetBaddressIsPtr(Bool_t isptr); virtual voidSetBaddressType(UInt_t type); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBranchPtr(TBranch** ptr); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLookedUp(Bool_t y = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberEntries(Long64_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPacketSize(Int_t size = 100); virtual voidSetStatus(Int_t status); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChainElement(); TChainElement(const TChainElement&); TChainElement(const char* title, const char* filename); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:5489,Testability,Test,TestBits,5489,"t::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetBaddress(void* add); virtual voidSetBaddressClassName(const char* clname); virtual voidSetBaddressIsPtr(Bool_t isptr); virtual voidSetBaddressType(UInt_t type); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBranchPtr(TBranch** ptr); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLookedUp(Bool_t y = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberEntries(Long64_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPacketSize(Int_t size = 100); virtual voidSetStatus(Int_t status); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChainElement(); TChainElement(const TChainElement&); TChainElement(const char* title, const char* filename); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:8560,Testability,Test,TestBit,8560,"ch status when used as a branch; TStringTNamed::fTitleobject title. private:. static TChainElement::EStatusBitskHasBeenLookedUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassName() const; { return fBaddressClassName; }. Bool_t GetBaddressIsPtr() const; { return fBaddressIsPtr; }. UInt_t GetBaddressType() const; { return fBaddressType; }. TBranch ** GetBranchPtr() const; { return fBranchPtr; }. Long64_t GetEntries() const; {return fEntries;}. char * GetPackets() const; {return fPackets;}. Int_t GetPacketSize() const; {return fPacketSize;}. Int_t GetStatus() const; {return fStatus;}. Bool_t HasBeenLookedUp(); { return TestBit(kHasBeenLookedUp); }. void SetBaddress(void* add); {fBaddress = add;}. void SetBaddressClassName(const char* clname); { fBaddressClassName = clname; }. void SetBaddressIsPtr(Bool_t isptr); { fBaddressIsPtr = isptr; }. void SetBaddressType(UInt_t type); { fBaddressType = type; }. void SetBranchPtr(TBranch** ptr); { fBranchPtr = ptr; }. void SetNumberEntries(Long64_t n); {fEntries=n;}. void SetStatus(Int_t status); {fStatus = status;}.  Author: Rene Brun 11/02/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainElement.html:654,Usability,Clear,Clear,654," virtual~TChainElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOpt",MatchSource.WIKI,root/html602/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainElement.html
https://root.cern/root/html602/TChainIndex.html:1235,Availability,Error,Error,1235," virtual~TChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; ",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:1364,Availability,error,error,1364,"ChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() con",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:1448,Availability,error,error,1448,"end(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:8462,Deployability,release,released,8462,"ex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaL",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:8477,Deployability,Release,ReleaseSubTreeIndex,8477,"ex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaL",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:8506,Deployability,Release,ReleaseSubTreeIndex,8506,"in.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the p",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:8569,Deployability,Release,Releases,8569,"in.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the p",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:9451,Deployability,Update,UpdateFormulaLeaves,9451,"Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); See TTreeIndex::SetTree. TChainIndex(). const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fEntries.size();}.  Author: Marek Biskup 07/06/2005  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:9493,Deployability,Update,Updates,9493,"Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); See TTreeIndex::SetTree. TChainIndex(). const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fEntries.size();}.  Author: Marek Biskup 07/06/2005  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:2881,Modifiability,Inherit,InheritsFrom,2881,"erFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*TVirtualIndex::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:2947,Modifiability,Inherit,InheritsFrom,2947,"estIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*TVirtualIndex::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TChainIndex&operator=(const TChainIndex&); virtual vo",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:7228,Modifiability,Inherit,Inheritance,7228," static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. vector<TChainIndex::TChainIndexEntry>fEntriesdescriptions of indices of trees in the chain.; TTreeFormula*fMajorFormulaParent! Pointer to major TreeFormula in Parent tree (if any); TStringfMajorNameIndex major name; TTreeFormula*fMinorFormulaParent! Pointer to minor TreeFormula in Parent tree (if any); TStringfMinorNameIndex minor name; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TTree*TVirtualIndex::fTree! pointer to Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainIndex(); Default constructor for TChainIndex. TChainIndex(const TTree* T, const char* majorname, const char* minorname); Normal constructor for TChainIndex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a ",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:7241,Modifiability,Inherit,Inherited,7241," static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. vector<TChainIndex::TChainIndexEntry>fEntriesdescriptions of indices of trees in the chain.; TTreeFormula*fMajorFormulaParent! Pointer to major TreeFormula in Parent tree (if any); TStringfMajorNameIndex major name; TTreeFormula*fMinorFormulaParent! Pointer to minor TreeFormula in Parent tree (if any); TStringfMinorNameIndex minor name; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TTree*TVirtualIndex::fTree! pointer to Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainIndex(); Default constructor for TChainIndex. TChainIndex(const TTree* T, const char* majorname, const char* minorname); Normal constructor for TChainIndex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a ",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:9541,Performance,Load,LoadTree,9541,"Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); See TTreeIndex::SetTree. TChainIndex(). const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fEntries.size();}.  Author: Marek Biskup 07/06/2005  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:2771,Security,Hash,Hash,2771,"virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*TVirtualIndex::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:5267,Testability,Test,TestBit,5267,"perator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TChainIndex&operator=(const TChainIndex&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChainIndex(); TChainIndex(const TChainIndex&); TChainIndex(const TTree* T, const char* majorname, const char* minorname); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:5306,Testability,Test,TestBits,5306,"perator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TChainIndex&operator=(const TChainIndex&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TChainIndex(); TChainIndex(const TChainIndex&); TChainIndex(const TTree* T, const char* majorname, const char* minorname); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex.html:692,Usability,Clear,Clear,692," virtual~TChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; ",MatchSource.WIKI,root/html602/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex.html
https://root.cern/root/html602/TChainIndex__TChainIndexEntry.html:1362,Modifiability,Inherit,Inheritance,1362,"h. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TChainIndex::TChainIndexEntry. class TChainIndex::TChainIndexEntry. A Chain Index. Function Members (Methods); public:. ~TChainIndexEntry(); TChainIndex::TChainIndexEntry::IndexValPair_tGetMaxIndexValPair() const; TChainIndex::TChainIndexEntry::IndexValPair_tGetMinIndexValPair() const; TChainIndex::TChainIndexEntry&operator=(const TChainIndex::TChainIndexEntry&); TChainIndex::TChainIndexEntry&operator=(TChainIndex::TChainIndexEntry&&); voidSetMinMaxFrom(const TTreeIndex* index); TChainIndex::TChainIndexEntryTChainIndexEntry(); TChainIndex::TChainIndexEntryTChainIndexEntry(const TChainIndex::TChainIndexEntry&); TChainIndex::TChainIndexEntryTChainIndexEntry(TChainIndex::TChainIndexEntry&&). Data Members; public:. Long64_tfMaxIndexValMinorthe maximum value of the index (lower bits); Long64_tfMaxIndexValuethe maximum value of the index (upper bits); Long64_tfMinIndexValMinorthe minimum value of the index (lower bits); Long64_tfMinIndexValuethe minimum value of the index (upper bits); TVirtualIndex*fTreeIndexthe tree index in case it was created in the constructor,. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetMinMaxFrom(const TTreeIndex* index). TChainIndexEntry(); holds a description of indices of trees in the chain. {}. IndexValPair_t GetMinIndexValPair() const; { return IndexValPair_t(fMinIndexValue, fMinIndexValMinor); }. IndexValPair_t GetMaxIndexValPair() const; { return IndexValPair_t(fMaxIndexValue, fMaxIndexValMinor); }.  Author: Marek Biskup 07/06/2005  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChainIndex__TChainIndexEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex__TChainIndexEntry.html
https://root.cern/root/html602/TChainIndex__TChainIndexEntry.html:1375,Modifiability,Inherit,Inherited,1375,"h. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TChainIndex::TChainIndexEntry. class TChainIndex::TChainIndexEntry. A Chain Index. Function Members (Methods); public:. ~TChainIndexEntry(); TChainIndex::TChainIndexEntry::IndexValPair_tGetMaxIndexValPair() const; TChainIndex::TChainIndexEntry::IndexValPair_tGetMinIndexValPair() const; TChainIndex::TChainIndexEntry&operator=(const TChainIndex::TChainIndexEntry&); TChainIndex::TChainIndexEntry&operator=(TChainIndex::TChainIndexEntry&&); voidSetMinMaxFrom(const TTreeIndex* index); TChainIndex::TChainIndexEntryTChainIndexEntry(); TChainIndex::TChainIndexEntryTChainIndexEntry(const TChainIndex::TChainIndexEntry&); TChainIndex::TChainIndexEntryTChainIndexEntry(TChainIndex::TChainIndexEntry&&). Data Members; public:. Long64_tfMaxIndexValMinorthe maximum value of the index (lower bits); Long64_tfMaxIndexValuethe maximum value of the index (upper bits); Long64_tfMinIndexValMinorthe minimum value of the index (lower bits); Long64_tfMinIndexValuethe minimum value of the index (upper bits); TVirtualIndex*fTreeIndexthe tree index in case it was created in the constructor,. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetMinMaxFrom(const TTreeIndex* index). TChainIndexEntry(); holds a description of indices of trees in the chain. {}. IndexValPair_t GetMinIndexValPair() const; { return IndexValPair_t(fMinIndexValue, fMinIndexValMinor); }. IndexValPair_t GetMaxIndexValPair() const; { return IndexValPair_t(fMaxIndexValue, fMaxIndexValMinor); }.  Author: Marek Biskup 07/06/2005  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChainIndex__TChainIndexEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChainIndex__TChainIndexEntry.html
https://root.cern/root/html602/TChair.html:1956,Availability,Error,Error,1956," virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Opti",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:2085,Availability,error,error,2085,"(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual Char_t*GetArray() const; v",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:2169,Availability,error,error,2169,"onst; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual Char_t*GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::Get",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:14830,Deployability,Update,Update,14830,"eturn GetThisTable()->GetType();}. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Long_t HasData() const; { return GetThisTable()->HasData();}. Bool_t IsFolder() const; { return GetThisTable()->IsFolder();}. void ls(Option_t* option = """") const; {GetThisTable()->ls(option);}. void ls(Int_t deep) const; {GetThisTable()->ls(deep);}. Int_t NaN(); {return GetThisTable()->NaN();}. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); {return GetThisTable()->MakeExpression(expressions,nExpressions);}. Char_t * Print(Char_t* buf, Int_t n) const; { return GetThisTable()->Print(buf, n);}. void Print(Option_t* opt = """") const; {GetThisTable()->Print(opt);}. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const. const Char_t * PrintHeader() const; {return GetThisTable()->PrintHeader();}. Int_t Purge(Option_t* opt = """"); {return GetThisTable()->Purge(opt);}. void * ReAllocate(Int_t newsize); { return GetThisTable()->ReAllocate(newsize); }. void * ReAllocate(); { return GetThisTable()->ReAllocate(); }. void SavePrimitive(ostream& out, Option_t* option = """"); {GetThisTable()->SavePrimitive(out,option);}. void Set(Int_t n); {GetThisTable()->Set(n);}. void Set(Int_t n, Char_t* array); {GetThisTable()->Set(n,array);}. void SetNRows(Int_t n); {GetThisTable()->SetNRows(n);}. void Reset(Int_t c = 0); {GetThisTable()->Reset(c) ;}. void Update(); {GetThisTable()->Update();}. void Update(TDataSet* set, UInt_t opt = 0); {GetThisTable()->Update(set,opt);}.  Author: Valery Fine(fine@bnl.gov) 13/03/2000  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id$  Last generated: 2015-06-02 13:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:14857,Deployability,Update,Update,14857,"eturn GetThisTable()->GetType();}. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Long_t HasData() const; { return GetThisTable()->HasData();}. Bool_t IsFolder() const; { return GetThisTable()->IsFolder();}. void ls(Option_t* option = """") const; {GetThisTable()->ls(option);}. void ls(Int_t deep) const; {GetThisTable()->ls(deep);}. Int_t NaN(); {return GetThisTable()->NaN();}. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); {return GetThisTable()->MakeExpression(expressions,nExpressions);}. Char_t * Print(Char_t* buf, Int_t n) const; { return GetThisTable()->Print(buf, n);}. void Print(Option_t* opt = """") const; {GetThisTable()->Print(opt);}. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const. const Char_t * PrintHeader() const; {return GetThisTable()->PrintHeader();}. Int_t Purge(Option_t* opt = """"); {return GetThisTable()->Purge(opt);}. void * ReAllocate(Int_t newsize); { return GetThisTable()->ReAllocate(newsize); }. void * ReAllocate(); { return GetThisTable()->ReAllocate(); }. void SavePrimitive(ostream& out, Option_t* option = """"); {GetThisTable()->SavePrimitive(out,option);}. void Set(Int_t n); {GetThisTable()->Set(n);}. void Set(Int_t n, Char_t* array); {GetThisTable()->Set(n,array);}. void SetNRows(Int_t n); {GetThisTable()->SetNRows(n);}. void Reset(Int_t c = 0); {GetThisTable()->Reset(c) ;}. void Update(); {GetThisTable()->Update();}. void Update(TDataSet* set, UInt_t opt = 0); {GetThisTable()->Update(set,opt);}.  Author: Valery Fine(fine@bnl.gov) 13/03/2000  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id$  Last generated: 2015-06-02 13:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:14874,Deployability,Update,Update,14874,"eturn GetThisTable()->GetType();}. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Long_t HasData() const; { return GetThisTable()->HasData();}. Bool_t IsFolder() const; { return GetThisTable()->IsFolder();}. void ls(Option_t* option = """") const; {GetThisTable()->ls(option);}. void ls(Int_t deep) const; {GetThisTable()->ls(deep);}. Int_t NaN(); {return GetThisTable()->NaN();}. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); {return GetThisTable()->MakeExpression(expressions,nExpressions);}. Char_t * Print(Char_t* buf, Int_t n) const; { return GetThisTable()->Print(buf, n);}. void Print(Option_t* opt = """") const; {GetThisTable()->Print(opt);}. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const. const Char_t * PrintHeader() const; {return GetThisTable()->PrintHeader();}. Int_t Purge(Option_t* opt = """"); {return GetThisTable()->Purge(opt);}. void * ReAllocate(Int_t newsize); { return GetThisTable()->ReAllocate(newsize); }. void * ReAllocate(); { return GetThisTable()->ReAllocate(); }. void SavePrimitive(ostream& out, Option_t* option = """"); {GetThisTable()->SavePrimitive(out,option);}. void Set(Int_t n); {GetThisTable()->Set(n);}. void Set(Int_t n, Char_t* array); {GetThisTable()->Set(n,array);}. void SetNRows(Int_t n); {GetThisTable()->SetNRows(n);}. void Reset(Int_t c = 0); {GetThisTable()->Reset(c) ;}. void Update(); {GetThisTable()->Update();}. void Update(TDataSet* set, UInt_t opt = 0); {GetThisTable()->Update(set,opt);}.  Author: Valery Fine(fine@bnl.gov) 13/03/2000  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id$  Last generated: 2015-06-02 13:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:14930,Deployability,Update,Update,14930,"eturn GetThisTable()->GetType();}. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Long_t HasData() const; { return GetThisTable()->HasData();}. Bool_t IsFolder() const; { return GetThisTable()->IsFolder();}. void ls(Option_t* option = """") const; {GetThisTable()->ls(option);}. void ls(Int_t deep) const; {GetThisTable()->ls(deep);}. Int_t NaN(); {return GetThisTable()->NaN();}. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); {return GetThisTable()->MakeExpression(expressions,nExpressions);}. Char_t * Print(Char_t* buf, Int_t n) const; { return GetThisTable()->Print(buf, n);}. void Print(Option_t* opt = """") const; {GetThisTable()->Print(opt);}. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const. const Char_t * PrintHeader() const; {return GetThisTable()->PrintHeader();}. Int_t Purge(Option_t* opt = """"); {return GetThisTable()->Purge(opt);}. void * ReAllocate(Int_t newsize); { return GetThisTable()->ReAllocate(newsize); }. void * ReAllocate(); { return GetThisTable()->ReAllocate(); }. void SavePrimitive(ostream& out, Option_t* option = """"); {GetThisTable()->SavePrimitive(out,option);}. void Set(Int_t n); {GetThisTable()->Set(n);}. void Set(Int_t n, Char_t* array); {GetThisTable()->Set(n,array);}. void SetNRows(Int_t n); {GetThisTable()->SetNRows(n);}. void Reset(Int_t c = 0); {GetThisTable()->Reset(c) ;}. void Update(); {GetThisTable()->Update();}. void Update(TDataSet* set, UInt_t opt = 0); {GetThisTable()->Update(set,opt);}.  Author: Valery Fine(fine@bnl.gov) 13/03/2000  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id$  Last generated: 2015-06-02 13:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:327,Integrability,interface,interface,327,". TChair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MISC;  TABLE;  TChair. class TChair: public TDataSet. TChair. It is a base class to create a custom interface for TTable objects. Function Members (Methods); public:. virtual~TChair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual voidAddAt(TDataSet* dataset, Int_t idx); virtual voidAddAt(const void* c, Int_t i); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); const void*At(Int_t i) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:4287,Modifiability,Inherit,InheritsFrom,4287,":GetList() const; virtual Int_tTDataSet::GetListSize() const; static TDataSet*TDataSet::GetMainSet(); TObject*TDataSet::GetMother() const; virtual const char*TNamed::GetName() const; virtual Long_tGetNRows() const; TObjArray*TDataSet::GetObjArray() const; virtual TObject*TDataSet::GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TDataSet*TDataSet::GetParent() const; virtual TClass*GetRowClass() const; virtual TTableDescriptor*GetRowDescriptors() const; virtual Long_tGetRowSize() const; virtual Long_tGetTableSize() const; virtual const char*TNamed::GetTitle() const; virtual const Char_t*GetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Long_tHasData() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual TDataSet*TDataSet::Instance() const; static TDataSet*TDataSet::instance(); voidTDataSet::InvertAllMarks()MENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTDataSet::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tTDataSet::IsMarked() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDataSet::IsThisDir(const char* dirname, int len = -1, int ignorecase = 0) const; Bool_tTObject::IsZombie() const; virtual TDataSet*TDataSet::Last() const; virtual voidls(Option_t* option = """") const; virtual voidls(Int_t deep) const; virtual Char_t*MakeExpression(const Char_t*[] expressions, Int_t nExpressions); voidTDataSet::Mark()MENU ; voidTDataSet::Mark(UInt_t flag, TDataSet::EBitOpt reset = kSet); voidTData",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:4353,Modifiability,Inherit,InheritsFrom,4353,"ic TDataSet*TDataSet::GetMainSet(); TObject*TDataSet::GetMother() const; virtual const char*TNamed::GetName() const; virtual Long_tGetNRows() const; TObjArray*TDataSet::GetObjArray() const; virtual TObject*TDataSet::GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TDataSet*TDataSet::GetParent() const; virtual TClass*GetRowClass() const; virtual TTableDescriptor*GetRowDescriptors() const; virtual Long_tGetRowSize() const; virtual Long_tGetTableSize() const; virtual const char*TNamed::GetTitle() const; virtual const Char_t*GetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Long_tHasData() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual TDataSet*TDataSet::Instance() const; static TDataSet*TDataSet::instance(); voidTDataSet::InvertAllMarks()MENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTDataSet::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tTDataSet::IsMarked() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDataSet::IsThisDir(const char* dirname, int len = -1, int ignorecase = 0) const; Bool_tTObject::IsZombie() const; virtual TDataSet*TDataSet::Last() const; virtual voidls(Option_t* option = """") const; virtual voidls(Int_t deep) const; virtual Char_t*MakeExpression(const Char_t*[] expressions, Int_t nExpressions); voidTDataSet::Mark()MENU ; voidTDataSet::Mark(UInt_t flag, TDataSet::EBitOpt reset = kSet); voidTDataSet::MarkAll()MENU ; voidTObject::MayNotUse(const char* method) co",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:11253,Modifiability,Inherit,Inheritance,11253,"t::kOverwrite; static TDataSet::EDataSetPassTDataSet::kPrune; static TDataSet::EDataSetPassTDataSet::kRefs; static TDataSet::EBitOptTDataSet::kReset; static TDataSet::EBitOptTDataSet::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDataSet::EDataSetPassTDataSet::kStop; static TDataSet::EDataSetPassTDataSet::kStruct; static TDataSet::EDataSetPassTDataSet::kUp; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. ULong_tfLastIndxindex pof the last used table row;; void*fLastRowpointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0,",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:11266,Modifiability,Inherit,Inherited,11266,"t::kOverwrite; static TDataSet::EDataSetPassTDataSet::kPrune; static TDataSet::EDataSetPassTDataSet::kRefs; static TDataSet::EBitOptTDataSet::kReset; static TDataSet::EBitOptTDataSet::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDataSet::EDataSetPassTDataSet::kStop; static TDataSet::EDataSetPassTDataSet::kStruct; static TDataSet::EDataSetPassTDataSet::kUp; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. ULong_tfLastIndxindex pof the last used table row;; void*fLastRowpointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0,",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:4177,Security,Hash,Hash,4177,"ion() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() const; virtual Int_tTDataSet::GetListSize() const; static TDataSet*TDataSet::GetMainSet(); TObject*TDataSet::GetMother() const; virtual const char*TNamed::GetName() const; virtual Long_tGetNRows() const; TObjArray*TDataSet::GetObjArray() const; virtual TObject*TDataSet::GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TDataSet*TDataSet::GetParent() const; virtual TClass*GetRowClass() const; virtual TTableDescriptor*GetRowDescriptors() const; virtual Long_tGetRowSize() const; virtual Long_tGetTableSize() const; virtual const char*TNamed::GetTitle() const; virtual const Char_t*GetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Long_tHasData() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; virtual TDataSet*TDataSet::Instance() const; static TDataSet*TDataSet::instance(); voidTDataSet::InvertAllMarks()MENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTDataSet::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; virtual Bool_tTDataSet::IsMarked() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDataSet::IsThisDir(const char* dirname, int len = -1, int ignorecase = 0) const; Bool_tTObject::IsZombie() const; virtual TDataSet*TDataSet::Last() const; virtual voidls(Option_t* option = """") const; virtual voidls(Int_t deep) const; virtual Char_t*MakeExpression(const Char_t*[] expressions, Int_t nE",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:8403,Testability,Test,TestBit,8403,"obj); virtual voidTDataSet::Remove(TDataSet* set); virtual TDataSet*TDataSet::RemoveAt(Int_t idx); virtual voidReset(Int_t c = 0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidSet(Int_t n); virtual voidSet(Int_t n, Char_t* array); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTDataSet::SetMother(TDataSet* parent = 0); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNRows(Int_t n); virtual voidTDataSet::SetObject(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTDataSet::SetParent(TDataSet* parent = 0); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDataSet::SetWrite(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTDataSet::Shunt(TDataSet* newParent = 0); virtual Int_tTNamed::Sizeof() const; virtual voidTDataSet::Sort(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const TTable*Table() const; TChair(TTable* table); TChair(const TChair& org); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTDataSet::UnMark()MENU ; voidTDataSet::UnMarkAll()MENU ; virtual voidUpdate(); virtual voidUpdate(TDataSet* set, UInt_t opt = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:8442,Testability,Test,TestBits,8442,"obj); virtual voidTDataSet::Remove(TDataSet* set); virtual TDataSet*TDataSet::RemoveAt(Int_t idx); virtual voidReset(Int_t c = 0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidSet(Int_t n); virtual voidSet(Int_t n, Char_t* array); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTDataSet::SetMother(TDataSet* parent = 0); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNRows(Int_t n); virtual voidTDataSet::SetObject(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTDataSet::SetParent(TDataSet* parent = 0); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDataSet::SetWrite(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTDataSet::Shunt(TDataSet* newParent = 0); virtual Int_tTNamed::Sizeof() const; virtual voidTDataSet::Sort(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const TTable*Table() const; TChair(TTable* table); TChair(const TChair& org); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTDataSet::UnMark()MENU ; voidTDataSet::UnMarkAll()MENU ; virtual voidUpdate(); virtual voidUpdate(TDataSet* set, UInt_t opt = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:11848,Testability,assert,assert,11848,"ointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); {return GetThisTable()->CopyRows(srcChair->GetThisTable(),srcRow,dstRow,nRows,expand);}. void Draw(Option_t* opt); {GetThisTable()->Draw(opt);}. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); {return GetThisTable()->Draw(varexp,selection,option,nentries,firstentry);}. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Char_t * GetArray() c",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:11874,Testability,assert,assert,11874,"fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); {return GetThisTable()->CopyRows(srcChair->GetThisTable(),srcRow,dstRow,nRows,expand);}. void Draw(Option_t* opt); {GetThisTable()->Draw(opt);}. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); {return GetThisTable()->Draw(varexp,selection,option,nentries,firstentry);}. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Char_t * GetArray() const; {return (Char_t *)GetThisTable()->GetArray();}",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TChair.html:1027,Usability,Clear,Clear,1027," virtual~TChair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual voidAddAt(TDataSet* dataset, Int_t idx); virtual voidAddAt(const void* c, Int_t i); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); const void*At(Int_t i) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html602/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TChair.html
https://root.cern/root/html602/TCivetweb.html:2039,Availability,Error,Error,2039," virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:2168,Availability,error,error,2168," virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:2252,Availability,error,error,2252,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::Inhe",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:963,Integrability,rout,routine,963,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  HTTP;  TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:3251,Modifiability,Inherit,InheritsFrom,3251," = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:3317,Modifiability,Inherit,InheritsFrom,3317,"t_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCivetweb&operator=(const TCivetweb&); virtual voidTO",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:7122,Modifiability,Inherit,Inheritance,7122," const; voidTObject::MakeZombie(); virtual voidTHttpEngine::Process(); voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const.  Last changed: Tue Jun 30 14:40:54 2015  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:7135,Modifiability,Inherit,Inherited,7135," const; voidTObject::MakeZombie(); virtual voidTHttpEngine::Process(); voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const.  Last changed: Tue Jun 30 14:40:54 2015  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:7532,Modifiability,config,configure,7532," const; voidTObject::MakeZombie(); virtual voidTHttpEngine::Process(); voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const.  Last changed: Tue Jun 30 14:40:54 2015  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:604,Security,authenticat,authentication,604,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  HTTP;  TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:661,Security,authenticat,authentication,661,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  HTTP;  TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:736,Security,Authenticat,Authentication,736,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  HTTP;  TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:810,Security,access,access,810,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  HTTP;  TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:875,Security,authenticat,authentication,875,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  HTTP;  TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:933,Security,authenticat,authentication,933,". TCivetweb. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  HTTP;  TCivetweb. class TCivetweb: public THttpEngine. TCivetweb. http server implementation, based on civetweb embedded server; It is default kind of engine, created for THttpServer. Following additional options can be specified; top=foldername - name of top folder, seen in the browser; thrds=N - use N threads to run civetweb server (default 5); auth_file - global authentication file; auth_domain - domain name, used for authentication. Example:; new THttpServer(""http:8080?top=MyApp&thrds=3"");. Authentication:; When auth_file and auth_domain parameters are specified, access; to running http server will be possible only after user; authentication, using so-call digest method. To generate; authentication file, htdigest routine should be used:. [shell] htdigest -c .htdigest domain_name user. When creating server, parameters should be:. new THttpServer(""http:8080?auth_file=.htdigets&auth_domain=domain_name"");. Function Members (Methods); public:. virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:3141,Security,Hash,Hash,3141,"nst char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:7601,Security,authenticat,authentication,7601," const; voidTObject::MakeZombie(); virtual voidTHttpEngine::Process(); voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const.  Last changed: Tue Jun 30 14:40:54 2015  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:7679,Security,authenticat,authentication,7679," const; voidTObject::MakeZombie(); virtual voidTHttpEngine::Process(); voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Bool_t Create(const char* args); Creates embedded civetweb server; As argument, http port should be specified in form ""8090""; One could provide extra parameters after '?' (like URL parameters); thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible at the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain. TCivetweb(). const char * GetTopName() const.  Last changed: Tue Jun 30 14:40:54 2015  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:5515,Testability,Test,TestBit,5515,"r* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCivetweb&operator=(const TCivetweb&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCivetweb(); TCivetweb(const TCivetweb&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:5554,Testability,Test,TestBits,5554,"r* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCivetweb&operator=(const TCivetweb&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCivetweb(); TCivetweb(const TCivetweb&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCivetweb.html:1456,Usability,Clear,Clear,1456," virtual~TCivetweb(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root/html602/TCivetweb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCivetweb.html
https://root.cern/root/html602/TCL.html:945,Integrability,interface,interface,945,". TCL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MISC;  TABLE;  TCL. class TCL. The set of methods to work with the plain matrix / vector; ""derived"" from http://wwwinfo.cern.ch/asdoc/shortwrupsdir/f110/top.html; ""derived"" from http://wwwinfo.cern.ch/asdoc/shortwrupsdir/f112/top.html. Revision 1.7 2006/05/21 18:05:26 brun; Fix more coding conventions violations. Revision 1.6 2006/05/20 14:06:09 brun; Fix a VERY long list of coding conventions violations. Revision 1.5 2003/09/30 09:52:49 brun; Add references to the original CERNLIB packages. Revision 1.4 2003/05/28 15:17:03 brun; From Valeri Fine. A new version of the table package.; It fixes a couple of memory leaks:; class TTableDescriptorm; class TVolumePosition; and provides some clean up; for the TCL class interface. Revision 1.3 2003/04/03 17:39:39 fine; Make merge with ROOT 3.05.03 and add TR package; 122; Revision 1.2 2003/02/04 23:35:20 fine; Clean up. Revision 1.1 2002/04/15 20:23:39 fine; NEw naming schema for RootKErnel classes and a set of classes to back geometry OO. Revision 1.2 2001/05/29 19:08:08 brun; New version of some STAR classes from Valery. Revision 1.2 2001/05/27 02:38:14 fine; New method trsedu to solev Ax=B from Victor. Revision 1.1.1.1 2000/11/27 22:57:14 fisyak. Revision 1.1.1.1 2000/05/16 17:00:48 rdm; Initial import of ROOT into CVS. Function Members (Methods); public:. virtual~TCL(); static TClass*Class(); virtual TClass*IsA() const; static float*mxmad(const float* a, const float* b, float* c, int i, int j, int k); static double*mxmad(const double* a, const double* b, double* c, int i, int j, int k); static float*mxmad1(const float* a, const float* b, float* c, int i, int j, int k); static double*mxmad1(const double* a, const double* b, double* c, int i, int j, int k); static float*mxmad2(const float* a, const float",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TCL.html:9646,Modifiability,Inherit,Inheritance,9646,"*vlinco(const double* a, double fa, const double* b, double fb, double* x, int n); static float*vmatl(const float* g, const float* c, float* x, int n = 3, int m = 3); static double*vmatl(const double* g, const double* c, double* x, int n = 3, int m = 3); static float*vmatr(const float* c, const float* g, float* x, int n = 3, int m = 3); static double*vmatr(const double* c, const double* g, double* x, int n = 3, int m = 3); static float*vscale(const float* a, float scale, float* b, int n); static double*vscale(const double* a, double scale, double* b, int n); static float*vsub(const float* a, const float* b, float* x, int n); static double*vsub(const double* a, const double* b, double* x, int n); static float*vsub(const float* b, const double* c, float* a, int n); static double*vsub(const double* b, const float* c, double* a, int n); static float*vzero(float* a, int n2); static double*vzero(double* a, int n2); static void**vzero(void** a, int n2). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; float * mxmad_0_(int n, const float* a, const float* b, float* c, int i, int j, int k). double * mxmad_0_(int n, const double* a, const double* b, double* c, int i, int j, int k). float * mxmlrt_0_(int n__, const float* a, const float* b, float* c, int ni, int nj); Matrix Multiplication; CERN PROGLIB# F110 MXMLRT .VERSION KERNFOR 2.00 720707; ORIG. 01/01/64 RKB. ; see original documentation of CERNLIB package F110. double * mxmlrt_0_(int n__, const double* a, const double* b, double* c, int ni, int nj); Matrix Multiplication (double precision). float * mxtrp(const float* a, float* b, int i, int j). Matrix Transposition; CERN PROGLIB# F110 MXTRP .VERSION KERNFOR 1.0 650809; ORIG. 01/01/64 RKB. ; see original documentation of CERNLIB package F110. double * mxtrp(const double* a, double* b, int i, int j); Matrix Transposition (double precision); CERN PROGLIB# F110 MXTRP .VERSION KERNFOR 1.0 650809; ORIG. 01/01/64 RKB. ; see original docum",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TCL.html:9659,Modifiability,Inherit,Inherited,9659,"*vlinco(const double* a, double fa, const double* b, double fb, double* x, int n); static float*vmatl(const float* g, const float* c, float* x, int n = 3, int m = 3); static double*vmatl(const double* g, const double* c, double* x, int n = 3, int m = 3); static float*vmatr(const float* c, const float* g, float* x, int n = 3, int m = 3); static double*vmatr(const double* c, const double* g, double* x, int n = 3, int m = 3); static float*vscale(const float* a, float scale, float* b, int n); static double*vscale(const double* a, double scale, double* b, int n); static float*vsub(const float* a, const float* b, float* x, int n); static double*vsub(const double* a, const double* b, double* x, int n); static float*vsub(const float* b, const double* c, float* a, int n); static double*vsub(const double* b, const float* c, double* a, int n); static float*vzero(float* a, int n2); static double*vzero(double* a, int n2); static void**vzero(void** a, int n2). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; float * mxmad_0_(int n, const float* a, const float* b, float* c, int i, int j, int k). double * mxmad_0_(int n, const double* a, const double* b, double* c, int i, int j, int k). float * mxmlrt_0_(int n__, const float* a, const float* b, float* c, int ni, int nj); Matrix Multiplication; CERN PROGLIB# F110 MXMLRT .VERSION KERNFOR 2.00 720707; ORIG. 01/01/64 RKB. ; see original documentation of CERNLIB package F110. double * mxmlrt_0_(int n__, const double* a, const double* b, double* c, int ni, int nj); Matrix Multiplication (double precision). float * mxtrp(const float* a, float* b, int i, int j). Matrix Transposition; CERN PROGLIB# F110 MXTRP .VERSION KERNFOR 1.0 650809; ORIG. 01/01/64 RKB. ; see original documentation of CERNLIB package F110. double * mxtrp(const double* a, double* b, int i, int j); Matrix Transposition (double precision); CERN PROGLIB# F110 MXTRP .VERSION KERNFOR 1.0 650809; ORIG. 01/01/64 RKB. ; see original docum",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TCL.html:14268,Modifiability,variab,variables,14268,"inal documentation of CERNLIB package F112. double * trasat(const double* a, const double* s, double* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trasat(const double* a, const float* s, float* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trata(const float* a, float* r, int m, int n); trata.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRATA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .V",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TCL.html:14388,Modifiability,variab,variables,14388,"Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trasat(const double* a, const float* s, float* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trata(const float* a, float* r, int m, int n); trata.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRATA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(cons",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TCL.html:15131,Modifiability,variab,variables,15131,"112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation ",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TCL.html:15618,Modifiability,variab,variables,15618,"age F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see origina",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TCL.html:15791,Modifiability,variab,variables,15791,"1204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trsa(const double* s, const double* a, double* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROG",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TCL.html:15914,Modifiability,variab,variables,15914,"* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trsa(const double* s, const double* a, double* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. L",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TCL.html:16921,Modifiability,variab,variables,16921,"s. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trsa(const double* s, const double* a, double* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. double * trsat(const double* s, const double* a, double* b, int m, int n); trsat.F -- translated by f2c (version 19970219); CERN PROGLIB# F112 TRSAT .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. float * trsequ(float* smx, int m = 3, float* b = 0, int n = 1); Linear Equations, Matrix Inversion; trsequ solves the matrix equation. SMX*x = B. which represents a system of m simultaneous linear equations with n right-hand sides:; SMX is an unpacked symmetric matrix (all elements) (m x m); B is an unpacked matrix of right-hand sides (n x m). double * trsequ(double* smx, int m = 3, double* b = 0, int n = 1); Linear Equations, Matrix Inversion; trsequ solves the matrix equation. SMX*x = B. which represents a system of m simultaneous linear equations with n right-hand sides:; SMX is an unpacked symmetric matrix (all elements) (m x m); B is an unpacked matrix of right-hand sides (n x m). float * mxmad(const float* a, const float* b",MatchSource.WIKI,root/html602/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCL.html
https://root.cern/root/html602/TClass.html:2893,Availability,Error,Error,2893,"TObject::ClassName() const; Long_tClassProperty() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetA",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:3064,Availability,error,error,3064,"nt_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:3148,Availability,error,error,3148,"ed) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:19881,Availability,avail,available,19881,"CheckSumkNoRange; static TClass::ECheckSumkNoRangeCheck; static TDictionary::ESTLTypeTDictionary::kNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TClass::ENewTypekRealNew; static TClass::ECheckSumkReflex; static TClass::ECheckSumkReflexNoComment; static TDictionary::ESTLTypeTDictionary::kSet; static TObject::(anonymous)TObject::kSingleKey; static TClass::(anonymous)kStartWithTObject; static TClass::(anonymous)kUnloaded; static TDictionary::ESTLTypeTDictionary::kVector; static TClass::(anonymous)kWarned; static TClass::ECheckSumkWithTypeDef; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TViewPubDataMembers*fAllPubDataall public data members (including from base classes); TViewPubFunctions*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; atomic<Bool_t>fCanLoadClassInfo!Indicates whether the ClassInfo is supposed to be available.; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Long_tfClassProperty!C++ Property of the class (is abstract, has virtual table, etc.); Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; ClassConvStreamerFunc_tfConvStreamerFuncWrapper around this class custom conversion Streamer member function.; TClass::ConvSIMap_tfConversionStreamerInfoArray of the streamer infos derived from another class.; atomic<TVirtualStreamerInfo*>fCurrentInfo!cached current streamer info.; TListOfDataMembers*fDatalinked list for data members; Short_tfDeclFileLineline of class declaratio",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:27386,Availability,error,error,27386,"char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:39547,Availability,avail,available,39547,"also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; th",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:48164,Availability,down,down,48164,"is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; t",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:48311,Availability,down,down,48311,"called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:48491,Availability,down,down,48491,"er();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:48638,Availability,down,down,48638,"must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyCla",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:48939,Availability,Error,Error,48939,"e that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClas",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:15375,Deployability,Update,UpdateInterpreterStateMarker,15375,"l = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """"). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TVirtualStreamerInfo*FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; voidGetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Class",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:28556,Deployability,update,updated,28556,"or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:55182,Deployability,install,installs,55182,") const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written b",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:58479,Deployability,Install,Install,58479,"of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBuffer(TBuffer& b, void* pointer, Int_t version, UInt_t start, UInt_t count); Function called by the Streamer functions to deserialize information; from buffer b into object at p.; This function assumes that the class version and the byte count information; have been read.; version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadBuffer(TBuffer& b, void* pointer); Function called by the Streamer functions to deserialize information; from buffer b into object at p. Int_t WriteBuffer(TBuffer& b, void* pointer, const char* info = """"); Function called by the Streamer functions to serialize object at p; to buffer b. The optional argument info may be specified to give an; alternative StreamerInfo instead of using the default StreamerInfo; automatically built from the class definition.; For more information, see class TV",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61289,Deployability,Install,Install,61289,"This, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find th",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61391,Deployability,Install,Install,61391,"brary. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * Fin",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61477,Deployability,Install,Install,61477," onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the St",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61564,Deployability,Install,Install,61564,"ign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreame",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61647,Deployability,Install,Install,61647,"mulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerI",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61743,Deployability,Install,Install,61743," TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtual",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61837,Deployability,Install,Install,61837," or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a C",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61943,Deployability,Install,Install,61943,"ject. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVi",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:63636,Deployability,Update,Update,63636,"rom the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTO",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:48759,Energy Efficiency,allocate,allocated,48759,"herits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:49821,Energy Efficiency,allocate,allocated,49821,"class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0:",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:50071,Energy Efficiency,allocate,allocated,50071,"ed by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassT",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:50345,Energy Efficiency,allocate,allocated,50345,"otIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should us",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:54150,Energy Efficiency,efficient,efficiently,54150,"ng data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:20305,Integrability,interface,interface,20305,"lass::(anonymous)kWarned; static TClass::ECheckSumkWithTypeDef; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TViewPubDataMembers*fAllPubDataall public data members (including from base classes); TViewPubFunctions*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; atomic<Bool_t>fCanLoadClassInfo!Indicates whether the ClassInfo is supposed to be available.; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Long_tfClassProperty!C++ Property of the class (is abstract, has virtual table, etc.); Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; ClassConvStreamerFunc_tfConvStreamerFuncWrapper around this class custom conversion Streamer member function.; TClass::ConvSIMap_tfConversionStreamerInfoArray of the streamer infos derived from another class.; atomic<TVirtualStreamerInfo*>fCurrentInfo!cached current streamer info.; TListOfDataMembers*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; ROOT::DelFunc_tfDeletepointer to a function deleting one object.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApoint",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:24857,Integrability,interface,interface,24857,"dStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. void RemoveClassDeclId(TDictionary::DeclId_t id). TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); Create a TClass object. This object does not contain anything. We mimic; the case of a class fwd declared in the interpreter. TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:25788,Integrability,interface,interface,25788,"to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); Create a TClass object. This object does not contain anything. We mimic; the case of a class fwd declared in the interpreter. TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. This copies the ClassInfo (i.e. does *not* take ownership of it). TClass(const char* name, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:34723,Integrability,wrap,wrapper,34723,"); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method retu",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:34861,Integrability,wrap,wrapper,34861,"ssOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shar",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:37426,Integrability,depend,depends,37426,"fo& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:43798,Integrability,interface,interface,43798,"TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod* FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); Find a method with decl id in this class or its bases. TMethod * GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClassMethod(Long_t faddr); Look for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); Look for a method in this class that has the name and matches the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; Returns 0 in case method is not found.; See TClass::GetMethod to also search the base classes. TMethod * GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:48927,Integrability,message,message,48927,"e that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). If quiet is true, do no issue a message via Error on case; of problems, just return 0. The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClas",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:50980,Integrability,interface,interface,50980,"wType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dic",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:54797,Integrability,rout,routine,54797,"om; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the valu",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61050,Integrability,wrap,wrapper,61050,"o not have the library defining the class. void StreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature voi",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61173,Integrability,wrap,wrapper,61173,"ass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from i",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61303,Integrability,wrap,wrapper,61303,"This, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find th",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61405,Integrability,wrap,wrapper,61405,"brary. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * Fin",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61491,Integrability,wrap,wrapper,61491," onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the St",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61578,Integrability,wrap,wrapper,61578,"ign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreame",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61661,Integrability,wrap,wrapper,61661,"mulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerI",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61757,Integrability,wrap,wrapper,61757," TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtual",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61851,Integrability,wrap,wrapper,61851," or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a C",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61957,Integrability,wrap,wrapper,61957,"ject. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVi",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:63806,Integrability,wrap,wrapper,63806,"file_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { re",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:63895,Integrability,wrap,wrapper,63895,"represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMem",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:63960,Integrability,wrap,wrapper,63960,"merInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { ret",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:64043,Integrability,wrap,wrapper,64043,"sum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fV",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:64121,Integrability,wrap,wrapper,64121,"ayout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:64208,Integrability,wrap,wrapper,64208,"versionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:64294,Integrability,wrap,wrapper,64294,"ion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() cons",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:64384,Integrability,wrap,wrapper,64384,"his class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:24116,Modifiability,Inherit,Inheritance,24116,"Streamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; atomic<TClass::StreamerImpl_t>fStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; atomic<Bool_t>fVersionUsed!Indicates whether GetClassVersion has been called; static atomic<Int_t>fgClassCountprovides unique id for a each class; static THashTable*fgClassTypedefHash; static TClass::EStreamerTypekDefault; static TClass::EStreamerTypekEmulatedStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. void RemoveClassDeclId(TDictionary::DeclId_t id). TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dict",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:24129,Modifiability,Inherit,Inherited,24129,"Streamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; atomic<TClass::StreamerImpl_t>fStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; atomic<Bool_t>fVersionUsed!Indicates whether GetClassVersion has been called; static atomic<Int_t>fgClassCountprovides unique id for a each class; static THashTable*fgClassTypedefHash; static TClass::EStreamerTypekDefault; static TClass::EStreamerTypekEmulatedStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. void RemoveClassDeclId(TDictionary::DeclId_t id). TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dict",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:29464,Modifiability,inherit,inherited,29464,"dtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Boo",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:29507,Modifiability,inherit,inheritance,29507,"e names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Bool_t CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) c",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:31581,Modifiability,inherit,inheritance,31581," of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; interpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. Long_t ClassProperty() const; Return the C++ property of this class, eg. is abstract, has virtual base; class, see EClassProperty in TDictionary.h. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the same 'dictionary'.; This effectively creates a hard alias for the class name. void CopyCollectionProxy(const TVirtualCollectionProxy& ); Copy the argument. void Draw(Option_t* option = """"); Draw detailed class inheritance structure.; If a class B inherits from a class A, the description of B is drawn; on the right side of the description of A.; Member functions overridden by B are shown in class A with a blue line; erasing the corresponding member function. void Dump(const void* obj, Bool_t noAddr = kFALSE) const; Dump contents of object on stdout.; Using the information in the object dictionary; each data member is interpreted.; If a data member is a pointer, the pointer value is printed; 'obj' is assume to point to an object of the class describe by this TClass. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; f",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:31618,Modifiability,inherit,inherits,31618,"bject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; interpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. Long_t ClassProperty() const; Return the C++ property of this class, eg. is abstract, has virtual base; class, see EClassProperty in TDictionary.h. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the same 'dictionary'.; This effectively creates a hard alias for the class name. void CopyCollectionProxy(const TVirtualCollectionProxy& ); Copy the argument. void Draw(Option_t* option = """"); Draw detailed class inheritance structure.; If a class B inherits from a class A, the description of B is drawn; on the right side of the description of A.; Member functions overridden by B are shown in class A with a blue line; erasing the corresponding member function. void Dump(const void* obj, Bool_t noAddr = kFALSE) const; Dump contents of object on stdout.; Using the information in the object dictionary; each data member is interpreted.; If a data member is a pointer, the pointer value is printed; 'obj' is assume to point to an object of the class describe by this TClass. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style. If noAddr is true, printout of all pointer values is skipped. c",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:33683,Modifiability,inherit,inheritance,33683,"(const char* text) const; Introduce an escape character (@) in front of a special chars.; You need to use the result immediately before it is being overwritten. TClass * GetActualClass(const void* object) const; Return a pointer the the real class of the object.; This is equivalent to object->IsA() when the class has a ClassDef.; It is REQUIRED that object is coming from a proper pointer to the; class represented by 'this'.; Example: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; TObject *obj = (TObject*)((void*)myobject)directory->Get(""some object of MyClass"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). Class",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:33846,Modifiability,inherit,inheritance,33846,"lass * GetActualClass(const void* object) const; Return a pointer the the real class of the object.; This is equivalent to object->IsA() when the class has a ClassDef.; It is REQUIRED that object is coming from a proper pointer to the; class represented by 'this'.; Example: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; TObject *obj = (TObject*)((void*)myobject)directory->Get(""some object of MyClass"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreame",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:34121,Modifiability,inherit,inheritance,34121," Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; TObject *obj = (TObject*)((void*)myobject)directory->Get(""some object of MyClass"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent =",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:34350,Modifiability,inherit,inheritance,34350,"s would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'tr",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:45500,Modifiability,variab,variable,45500,"ass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:45550,Modifiability,variab,variable,45550,"ass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46225,Modifiability,variab,variable,46225,"Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objec",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46275,Modifiability,variab,variable,46275,"Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objec",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46783,Modifiability,variab,variable,46783,"inter to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46833,Modifiability,variab,variable,46833,"inter to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:47652,Modifiability,Inherit,InheritsFrom,47652,"o, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, B",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:47715,Modifiability,inherit,inherits,47715,"o, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, B",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:47844,Modifiability,Inherit,InheritsFrom,47844,"d IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCal",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:47909,Modifiability,inherit,inherits,47909,"d IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). const void * DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCal",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:53490,Modifiability,inherit,inherits,53490,"bers). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class i",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:53795,Modifiability,inherit,inherit,53795,"to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmu",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:53878,Modifiability,inherit,inherits,53878,"used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType.",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:54301,Modifiability,inherit,inherits,54301,"nd if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:54381,Modifiability,inherit,inheritance,54381,"nd if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:54507,Modifiability,inherit,inherits,54507,"nd if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:644,Performance,load,load,644,". TClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. Function Members (Methods); public:. virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); static voidAddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); voidCalculateStreamerOffset() const; Bool_tCallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) const; Bool_tCanIgnoreTObjectStreamer(); Bool_tCanSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; Long_tClassProperty() const; virtual voidTNamed::Clear(Option_t* option = """")",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:4446,Performance,load,load,4446,"t; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamembe",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:4542,Performance,load,load,4542,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() cons",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:4630,Performance,load,load,4630,"::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFun",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:6439,Performance,load,load,6439,"atamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetN",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:6499,Performance,load,load,6499,"ername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::G",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:6572,Performance,load,load,6572,"() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSt",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:6615,Performance,load,load,6615," ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption()",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:6670,Performance,load,load,6670,"c_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TClass*const*GetPersistentRef() const; TRealDat",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:6777,Performance,load,load,6777," type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TClass*const*GetPersistentRef() const; TRealData*GetRealData(const char* name) const; TVirtualRefProxy*GetReferenceProxy() const; ROOT::ResetAfterMergeFun",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:9570,Performance,Load,Load,9570,"Bool_tHasDictionarySelection(const char* clname); virtual ULong_tTNamed::Hash() const; Bool_tHasInterpreterInfo() const; Bool_tHasInterpreterInfoInMemory() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); static TClass*LoadClass(const char* requestedname, Bool_t silent); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); voi",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:9602,Performance,Load,LoadClass,9602,"char* clname); virtual ULong_tTNamed::Hash() const; Bool_tHasInterpreterInfo() const; Bool_tHasInterpreterInfoInMemory() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); static TClass*LoadClass(const char* requestedname, Bool_t silent); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz,",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:16130,Performance,Load,LoadClassCustom,16130," visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); static TClass*LoadClassCustom(const char* requestedname, Bool_t silent); static TClass*LoadClassDefault(const char* requestedname, Bool_t silent); voidLoadClassInfo() const; TClass&operator=(const TClass&); voidSetClassSize(Int_t sizof); voidSetClassVersion(Version_t version); voidSetStreamerImpl(); static voidStreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerExternal(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObject(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectEmulated(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectInitialized(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TClass(const TClass& tc). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TDictionary::ESTLTypeTDictionary::k",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:16203,Performance,Load,LoadClassDefault,16203," visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); static TClass*LoadClassCustom(const char* requestedname, Bool_t silent); static TClass*LoadClassDefault(const char* requestedname, Bool_t silent); voidLoadClassInfo() const; TClass&operator=(const TClass&); voidSetClassSize(Int_t sizof); voidSetClassVersion(Version_t version); voidSetStreamerImpl(); static voidStreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerExternal(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObject(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectEmulated(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); static voidStreamerTObjectInitialized(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TClass(const TClass& tc). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TDictionary::ESTLTypeTDictionary::k",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:20612,Performance,cache,cached,20612,"embers*fAllPubDataall public data members (including from base classes); TViewPubFunctions*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; atomic<Bool_t>fCanLoadClassInfo!Indicates whether the ClassInfo is supposed to be available.; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Long_tfClassProperty!C++ Property of the class (is abstract, has virtual table, etc.); Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; ClassConvStreamerFunc_tfConvStreamerFuncWrapper around this class custom conversion Streamer member function.; TClass::ConvSIMap_tfConversionStreamerInfoArray of the streamer infos derived from another class.; atomic<TVirtualStreamerInfo*>fCurrentInfo!cached current streamer info.; TListOfDataMembers*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; ROOT::DelFunc_tfDeletepointer to a function deleting one object.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; atomic<Bool_t>fHasRootPcmInfo!Whether info was loaded from a root pcm.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; TVi",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:21413,Performance,load,loaded,21413,Wrapper around this class custom conversion Streamer member function.; TClass::ConvSIMap_tfConversionStreamerInfoArray of the streamer infos derived from another class.; atomic<TVirtualStreamerInfo*>fCurrentInfo!cached current streamer info.; TListOfDataMembers*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; ROOT::DelFunc_tfDeletepointer to a function deleting one object.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; atomic<Bool_t>fHasRootPcmInfo!Whether info was loaded from a root pcm.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; atomic<TMethodCall*>fIsAMethod!saved info to call a IsA member function; atomic<Bool_t>fIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; atomic<TVirtualStreamerInfo*>fLastReadInfo!cached streamer info used in the last read.; ROOT::MergeFunc_tfMergepointer to a function implementing Merging objects of this class.; atomic<TListOfFunctions*>fMethodlinked list for methods; ROOT::NewFunc_tfNewpointer to a function newing one object.; ROOT::NewArrFunc_tfNewArraypointer to a function newing an array of objects.; static TClass::TDeclNameRegistryfNoInfoOrEmuOrFwdDeclNameRegistryStore the decl names of the forwardd and no info instances; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances o,MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:21859,Performance,cache,cached,21859,bject.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; atomic<Bool_t>fHasRootPcmInfo!Whether info was loaded from a root pcm.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; atomic<TMethodCall*>fIsAMethod!saved info to call a IsA member function; atomic<Bool_t>fIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; atomic<TVirtualStreamerInfo*>fLastReadInfo!cached streamer info used in the last read.; ROOT::MergeFunc_tfMergepointer to a function implementing Merging objects of this class.; atomic<TListOfFunctions*>fMethodlinked list for methods; ROOT::NewFunc_tfNewpointer to a function newing one object.; ROOT::NewArrFunc_tfNewArraypointer to a function newing an array of objects.; static TClass::TDeclNameRegistryfNoInfoOrEmuOrFwdDeclNameRegistryStore the decl names of the forwardd and no info instances; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances on heap; atomic<TClass**>fPersistentRef!Persistent address of pointer to this TClass object and its successors.; atomic<Long_t>fProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; ROOT::ResetAfterMergeFunc_tfResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! S,MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:23116,Performance,Load,Loaded,23116,"ction newing an array of objects.; static TClass::TDeclNameRegistryfNoInfoOrEmuOrFwdDeclNameRegistryStore the decl names of the forwardd and no info instances; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances on heap; atomic<TClass**>fPersistentRef!Persistent address of pointer to this TClass object and its successors.; atomic<Long_t>fProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; ROOT::ResetAfterMergeFunc_tfResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! Schema evolution rules; TStringfSharedLibsshared libraries containing class code; ShowMembersFunc_tfShowMemberspointer to the class's ShowMembers function; Int_tfSizeofSizeof the class.; TClass::EStatefState!Current 'state' of the class (Emulated,Interpreted,Loaded); TClassStreamer*fStreamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; atomic<TClass::StreamerImpl_t>fStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; atomic<Bool_t>fVersionUsed!Indicates whether GetClassVersion has been called; static atomic<Int_t>fgClassCountprovides unique id for a each class; static THashTable*fgClassTypedefHash; static TClass::EStreamerTypekDefault; static TClass::EStreamerTypekEmulatedStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:23498,Performance,cache,cached,23498,"; atomic<Long_t>fProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; ROOT::ResetAfterMergeFunc_tfResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! Schema evolution rules; TStringfSharedLibsshared libraries containing class code; ShowMembersFunc_tfShowMemberspointer to the class's ShowMembers function; Int_tfSizeofSizeof the class.; TClass::EStatefState!Current 'state' of the class (Emulated,Interpreted,Loaded); TClassStreamer*fStreamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; atomic<TClass::StreamerImpl_t>fStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; atomic<Bool_t>fVersionUsed!Indicates whether GetClassVersion has been called; static atomic<Int_t>fgClassCountprovides unique id for a each class; static THashTable*fgClassTypedefHash; static TClass::EStreamerTypekDefault; static TClass::EStreamerTypekEmulatedStreamer; static TClass::EStreamerTypekExternal; static TClass::EStreamerTypekForeign; static TClass::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:27355,Performance,load,loaded,27355,"ersion_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; s",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:35086,Performance,load,load,35086,"le inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOr",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:35200,Performance,load,load,35200,"he base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cna",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:35255,Performance,load,loading,35255,"he base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cna",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:35561,Performance,load,load,35561,"f any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""d",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:35679,Performance,load,load,35679,"const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:35792,Performance,load,load,35792,"t; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealDat",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:35847,Performance,load,loading,35847,"t; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealDat",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:36301,Performance,load,loading,36301,"ared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:36423,Performance,load,loading,36423,"(typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:37593,Performance,load,load,37593,"et(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not al",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:37690,Performance,load,load,37690,"e class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:37799,Performance,load,load,37799," emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRU",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:37892,Performance,load,load,37892,"const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subs",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:37959,Performance,load,load,37959,"elf,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). v",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:38232,Performance,load,load,38232,"et the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:38797,Performance,load,load,38797," list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& v",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:39273,Performance,load,loading,39273,"load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the se",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:39397,Performance,load,load,39397,"hods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool rec",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:39497,Performance,load,loaded,39497,"also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; th",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:39608,Performance,load,loaded,39608,"also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; th",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:41323,Performance,cache,caches,41323,"ngDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; the class itself, all base classes, direct data members,; and for collection proxies the container's; elements without iterating over the element's data members;; With recurse = true the classes checked for missing dictionaries are:; the class itself, all base classes, recursing on the data members,; and for the collection proxies recursiong on the elements of the; collection and iterating over the element's data members. Bool_t IsFolder(void* obj) const; Return kTRUE if the class has elements. void ReplaceWith(TClass* newcl) const; Inform the other objects to replace this object by the new TClass (newcl). void ResetClassInfo(Long_t tagnum); Make sure that the current ClassInfo is up to date. void ResetClassInfo(); Make sure that the current ClassInfo is up to date. void ResetCaches(); To clean out all caches. void ResetMenuList(); Resets the menu list to it's standard value. void ls(Option_t* opt = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList()",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:42515,Performance,load,loads,42515,"s verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod* FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); Find a method with decl id in this class or its bases. TMethod * GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:42714,Performance,load,loading,42714,"menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod* FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); Find a method with decl id in this class or its bases. TMethod * GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClas",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:44901,Performance,load,load,44901,"that has the name and matches the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; Returns 0 in case method is not found.; See TClass::GetMethod to also search the base classes. TMethod * GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two spe",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:44975,Performance,load,loaded,44975,"that has the name and matches the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; Returns 0 in case method is not found.; See TClass::GetMethod to also search the base classes. TMethod * GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two spe",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:45302,Performance,load,loaded,45302,"EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable proper",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:45353,Performance,load,loaded,45353,"method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindS",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:45447,Performance,optimiz,optimizes,45447,"ass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:45585,Performance,Optimiz,Optimize,45585,"ass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:45884,Performance,load,loaded,45884,"eturn the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is c",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46027,Performance,load,loaded,46027,"s(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Stre",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46078,Performance,load,loaded,46078,"Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46172,Performance,optimiz,optimizes,46172,"Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objec",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46310,Performance,Optimiz,Optimize,46310,"Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objec",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46608,Performance,load,loaded,46608,"ed externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Cl",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46730,Performance,optimiz,optimizes,46730,"inter to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46868,Performance,Optimiz,Optimize,46868,"inter to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:51640,Performance,Load,Load,51640,". void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetC",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:51658,Performance,Load,Load,51658,". void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetC",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:51731,Performance,Load,LoadClass,51731,"lation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:51855,Performance,load,load,51855,"n. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are use",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:52162,Performance,Load,LoadClassDefault,52162,"ent; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; R",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:52293,Performance,load,load,52293,"m to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:52581,Performance,Load,LoadClassCustom,52581,"ss. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the foll",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:52711,Performance,load,load,52711,"* LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TO",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:52983,Performance,Load,LoadClassInfo,52983," class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initial",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:53013,Performance,load,load,53013," class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initial",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:53080,Performance,load,loading,53080," class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initial",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:54228,Performance,cache,cache,54228,"rn true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:65334,Performance,Load,LoadClassInfo,65334,e destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TClass ** GetPersistentRef() const; { return fPersistentRef; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. EState GetState() const; { return fState; }. const TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const;,MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:66813,Performance,perform,performance,66813,"return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TClass ** GetPersistentRef() const; { return fPersistentRef; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. EState GetState() const; { return fState; }. const TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const; { return fTypeInfo; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsVersioned() const; { return !( GetClassVersion()<=1 && IsForeign() ); }. void ResetInstanceCount(); { fInstanceCount = fOnHeap = 0; }. void SetDeclFile(const char* name, int line); { fDeclFileName = name; fDeclFileLine = line; }. void SetImplFileName(const char* implFileName); { fImplFileName = implFileName; }. ENewType IsCallingNew(). void Streamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; Inline for performance, skipping one function call.  Author: Rene Brun 07/01/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id$  Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:55783,Safety,safe,safe,55783,"pl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code);",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:3434,Security,checksum,checksum,3434,"ject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:3531,Security,checksum,checksum,3531,"oidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, B",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:3717,Security,checksum,checksum,3717,"t; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMet",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:3795,Security,checksum,checksum,3795,"oid*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMet",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:8645,Security,Hash,Hash,8645,"stentRef() const; TRealData*GetRealData(const char* name) const; TVirtualRefProxy*GetReferenceProxy() const; ROOT::ResetAfterMergeFunc_tGetResetAfterMerge() const; const ROOT::TSchemaRuleSet*GetSchemaRules() const; ROOT::TSchemaRuleSet*GetSchemaRules(Bool_t create = kFALSE); const char*GetSharedLibs(); ShowMembersFunc_tGetShowMembersWrapper() const; TClass::EStateGetState() const; TClassStreamer*GetStreamer() const; ClassStreamerFunc_tGetStreamerFunc() const; TVirtualStreamerInfo*GetStreamerInfo(Int_t version = 0) const; TVirtualStreamerInfo*GetStreamerInfoAbstractEmulated(Int_t version = 0) const; const TObjArray*GetStreamerInfos() const; virtual const char*TNamed::GetTitle() const; const type_info*GetTypeInfo() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasDataMemberInfo() const; Bool_tHasDefaultConstructor() const; Bool_tHasDictionary(); static Bool_tHasDictionarySelection(const char* clname); virtual ULong_tTNamed::Hash() const; Bool_tHasInterpreterInfo() const; Bool_tHasInterpreterInfoInMemory() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); static TClass*LoadClass(const char* requestedname, Bool_t si",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:9756,Security,checksum,checksum,9756,"(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); static TClass*LoadClass(const char* requestedname, Bool_t silent); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """");",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:14915,Security,checksum,checksum,14915,"l = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """"). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TVirtualStreamerInfo*FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; voidGetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Class",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:24966,Security,access,access,24966,"::EStreamerTypekInstrumented; static TClass::(anonymous)kLoading; static TClass::EStreamerTypekTObject; static TClass::(anonymous)kUnloading. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). DeclIdMap_t * GetDeclIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); static: Add a TClass* to the map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. void RemoveClassDeclId(TDictionary::DeclId_t id). TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); Create a TClass object. This object does not contain anything. We mimic; the case of a class fwd declared in the interpreter. TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. This copies the ",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:25897,Security,access,access,25897," Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); Create a TClass object. This object does not contain anything. We mimic; the case of a class fwd declared in the interpreter. TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. This copies the ClassInfo (i.e. does *not* take ownership of it). TClass(const char* name, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. T",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:27594,Security,checksum,checksum,27594,"ad(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separat",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:27837,Security,checksum,checksum,27837,"sInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimite",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:28816,Security,checksum,checksum,28816,"checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTra",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:28855,Security,checksum,checksums,28855,"checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTra",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:30362,Security,access,access,30362,"ame, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Bool_t CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) const; Call ShowMembers() on the obj of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; interpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. Long_t ClassProperty() const; Return the C++ property of this class, eg. is abstract, has virtual base; class, see EClassProperty in TDictionary.h. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the sam",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:34731,Security,access,accessor,34731,"); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method retu",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:34869,Security,access,accessor,34869,"ssOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shar",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:39073,Security,access,accessible,39073,"nction template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pai",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:41797,Security,access,accessible,41797,"sing on the data members,; and for the collection proxies recursiong on the elements of the; collection and iterating over the element's data members. Bool_t IsFolder(void* obj) const; Return kTRUE if the class has elements. void ReplaceWith(TClass* newcl) const; Inform the other objects to replace this object by the new TClass (newcl). void ResetClassInfo(Long_t tagnum); Make sure that the current ClassInfo is up to date. void ResetClassInfo(); Make sure that the current ClassInfo is up to date. void ResetCaches(); To clean out all caches. void ResetMenuList(); Resets the menu list to it's standard value. void ls(Option_t* opt = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * Get",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:46385,Security,checksum,checksum,46385,"ed externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Cl",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:51310,Security,checksum,checksum,51310,":IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedn",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:56640,Security,checksum,checksum,56640,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:56676,Security,checksum,checksum,56676,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:56718,Security,checksum,checksum,56718,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:56756,Security,checksum,checksum,56756,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:57131,Security,checksum,checksum,57131,"= """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefP",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:57504,Security,checksum,checksum,57504,"e user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBu",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:57535,Security,checksum,checksum,57535,"e user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBu",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61058,Security,access,accessor,61058,"o not have the library defining the class. void StreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature voi",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:61181,Security,access,accessor,61181,"ass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from i",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:62261,Security,checksum,checksum,62261,"nc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversi",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:62346,Security,checksum,checksum,62346,"nc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversi",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:62419,Security,checksum,checksum,62419,"ge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStre",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:62504,Security,checksum,checksum,62504,"ge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStre",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:63027,Security,checksum,checksum,63027,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper ar",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:63135,Security,checksum,checksum,63135,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper ar",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:63250,Security,checksum,checksum,63250,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:63363,Security,checksum,checksum,63363,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:63726,Security,access,access,63726," class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. v",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:14313,Testability,Test,TestBit,14313,"::SetNameTitle(const char* name, const char* title); voidSetNew(ROOT::NewFunc_t newFunc); voidSetNewArray(ROOT::NewArrFunc_t newArrayFunc); static voidTObject::SetObjectStat(Bool_t stat); voidSetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); voidSetStreamerFunc(ClassStreamerFunc_t strm); TVirtualStreamerInfo*SetStreamerInfo(Int_t version, const char* info = """"); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUnloaded(); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSize() const; virtual Int_tTNamed::Sizeof() const; voidStore(TBuffer& b) const; virtual voidStreamer(TBuffer&); voidStreamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClass(); TClass(const char* name, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """").",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:14352,Testability,Test,TestBits,14352,"::SetNameTitle(const char* name, const char* title); voidSetNew(ROOT::NewFunc_t newFunc); voidSetNewArray(ROOT::NewArrFunc_t newArrayFunc); static voidTObject::SetObjectStat(Bool_t stat); voidSetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); voidSetStreamerFunc(ClassStreamerFunc_t strm); TVirtualStreamerInfo*SetStreamerInfo(Int_t version, const char* info = """"); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUnloaded(); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSize() const; virtual Int_tTNamed::Sizeof() const; voidStore(TBuffer& b) const; virtual voidStreamer(TBuffer&); voidStreamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClass(); TClass(const char* name, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, TClass::EState theState, Bool_t silent = kFALSE); TClass(ClassInfo_t* info, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const char* dfil, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """").",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:55563,Testability,test,test,55563," a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchL",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:64675,Testability,Test,TestBit,64675,_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealDa,MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:65315,Testability,Test,TestBit,65315,e destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TClass ** GetPersistentRef() const; { return fPersistentRef; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. EState GetState() const; { return fState; }. const TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const;,MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClass.html:1973,Usability,Clear,Clear,1973,"d_t id, TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); voidCalculateStreamerOffset() const; Bool_tCallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) const; Bool_tCanIgnoreTObjectStreamer(); Bool_tCanSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; Long_tClassProperty() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* t",MatchSource.WIKI,root/html602/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClass.html
https://root.cern/root/html602/TClassDocInfo.html:1265,Availability,Error,Error,1265," virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:1394,Availability,error,error,1394," virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:1478,Availability,error,error,1478,"ocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char*TObject::GetIconName() const; const char*GetImplFileName() const; const char*GetImplFileSysName() const; TList&GetListOfTypedefs(); TModuleDocInfo*GetModule() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTime",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:2643,Modifiability,Inherit,InheritsFrom,2643,"Object::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char*TObject::GetIconName() const; const char*GetImplFileName() const; const char*GetImplFileSysName() const; TList&GetListOfTypedefs(); TModuleDocInfo*GetModule() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; Bool_tHaveSource() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsSelected() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::opera",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:2709,Modifiability,Inherit,InheritsFrom,2709,"t::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char*TObject::GetIconName() const; const char*GetImplFileName() const; const char*GetImplFileSysName() const; TList&GetListOfTypedefs(); TModuleDocInfo*GetModule() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; Bool_tHaveSource() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsSelected() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TClassDocInfo&operator=(const TCla",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:7026,Modifiability,Inherit,Inheritance,7026,"ect::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TDictionary*fClassclass (or typedef) represented by this info object; TStringfDeclFileNameheader; TStringfDeclFileSysNamefile system's location of the header; TStringfHtmlFileNamename of the HTML doc file; TStringfImplFileNamesource; TStringfImplFileSysNamefile system's location of the source; TModuleDocInfo*fModulemodule this class is in; Bool_tfSelectedselected for doc output; TListfTypedefstypedefs to this class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char* GetName() const; Get the class name, or (UNKNOWN) is no TClass object was found. ULong_t Hash() const; Forward to TClass::Hash(), return -1 if no TClass object was found. Int_t Compare(const TObject* obj) const; Compare two TClassDocInfo objects; used for sorting. TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); initialize the object. { }. TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); { }. virtual ~TClassDocInfo(); {}. TDictionary* GetClass() const; { return fClass; }. const char* GetHtmlFileName() const; { return fHtmlFileName; }. const char* GetDeclFileName() const; { return fDeclFileName; }. const char* GetImplFileName() const; { return fImplFileName; }. const char* GetDeclFileSysName() const; { return fDeclFil",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:7039,Modifiability,Inherit,Inherited,7039,"ect::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TDictionary*fClassclass (or typedef) represented by this info object; TStringfDeclFileNameheader; TStringfDeclFileSysNamefile system's location of the header; TStringfHtmlFileNamename of the HTML doc file; TStringfImplFileNamesource; TStringfImplFileSysNamefile system's location of the source; TModuleDocInfo*fModulemodule this class is in; Bool_tfSelectedselected for doc output; TListfTypedefstypedefs to this class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char* GetName() const; Get the class name, or (UNKNOWN) is no TClass object was found. ULong_t Hash() const; Forward to TClass::Hash(), return -1 if no TClass object was found. Int_t Compare(const TObject* obj) const; Compare two TClassDocInfo objects; used for sorting. TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); initialize the object. { }. TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); { }. virtual ~TClassDocInfo(); {}. TDictionary* GetClass() const; { return fClass; }. const char* GetHtmlFileName() const; { return fHtmlFileName; }. const char* GetDeclFileName() const; { return fDeclFileName; }. const char* GetImplFileName() const; { return fImplFileName; }. const char* GetDeclFileSysName() const; { return fDeclFil",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:292,Performance,Cache,Caches,292,". TClassDocInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HTML;  TClassDocInfo. class TClassDocInfo: public TObject. Caches class documentation information, like which module it belongs to,; and whether THtml should generate documentation for the class. Function Members (Methods); public:. virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:7204,Security,Hash,Hash,7204,"static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TDictionary*fClassclass (or typedef) represented by this info object; TStringfDeclFileNameheader; TStringfDeclFileSysNamefile system's location of the header; TStringfHtmlFileNamename of the HTML doc file; TStringfImplFileNamesource; TStringfImplFileSysNamefile system's location of the source; TModuleDocInfo*fModulemodule this class is in; Bool_tfSelectedselected for doc output; TListfTypedefstypedefs to this class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char* GetName() const; Get the class name, or (UNKNOWN) is no TClass object was found. ULong_t Hash() const; Forward to TClass::Hash(), return -1 if no TClass object was found. Int_t Compare(const TObject* obj) const; Compare two TClassDocInfo objects; used for sorting. TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); initialize the object. { }. TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); { }. virtual ~TClassDocInfo(); {}. TDictionary* GetClass() const; { return fClass; }. const char* GetHtmlFileName() const; { return fHtmlFileName; }. const char* GetDeclFileName() const; { return fDeclFileName; }. const char* GetImplFileName() const; { return fImplFileName; }. const char* GetDeclFileSysName() const; { return fDeclFileSysName; }. const char* GetImplFileSysName() const; { return fImplFileSysName; }. void SetModule(TModuleDocInfo* module); { fModule = module; }. TModuleDocInfo* GetModule() const; { retur",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:7237,Security,Hash,Hash,7237,"static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TDictionary*fClassclass (or typedef) represented by this info object; TStringfDeclFileNameheader; TStringfDeclFileSysNamefile system's location of the header; TStringfHtmlFileNamename of the HTML doc file; TStringfImplFileNamesource; TStringfImplFileSysNamefile system's location of the source; TModuleDocInfo*fModulemodule this class is in; Bool_tfSelectedselected for doc output; TListfTypedefstypedefs to this class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char* GetName() const; Get the class name, or (UNKNOWN) is no TClass object was found. ULong_t Hash() const; Forward to TClass::Hash(), return -1 if no TClass object was found. Int_t Compare(const TObject* obj) const; Compare two TClassDocInfo objects; used for sorting. TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); initialize the object. { }. TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); { }. virtual ~TClassDocInfo(); {}. TDictionary* GetClass() const; { return fClass; }. const char* GetHtmlFileName() const; { return fHtmlFileName; }. const char* GetDeclFileName() const; { return fDeclFileName; }. const char* GetImplFileName() const; { return fImplFileName; }. const char* GetDeclFileSysName() const; { return fDeclFileSysName; }. const char* GetImplFileSysName() const; { return fImplFileSysName; }. void SetModule(TModuleDocInfo* module); { fModule = module; }. TModuleDocInfo* GetModule() const; { retur",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:5301,Testability,Test,TestBit,5301,"ze_t sz, void* vp); TClassDocInfo&operator=(const TClassDocInfo&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDeclFileName(const char* name); voidSetDeclFileSysName(const char* fsname); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHtmlFileName(const char* name); voidSetImplFileName(const char* name); voidSetImplFileSysName(const char* fsname); voidSetModule(TModuleDocInfo* module); static voidTObject::SetObjectStat(Bool_t stat); voidSetSelected(Bool_t sel = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassDocInfo(const TClassDocInfo&); TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:5340,Testability,Test,TestBits,5340,"ze_t sz, void* vp); TClassDocInfo&operator=(const TClassDocInfo&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDeclFileName(const char* name); voidSetDeclFileSysName(const char* fsname); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHtmlFileName(const char* name); voidSetImplFileName(const char* name); voidSetImplFileSysName(const char* fsname); voidSetModule(TModuleDocInfo* module); static voidTObject::SetObjectStat(Bool_t stat); voidSetSelected(Bool_t sel = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassDocInfo(const TClassDocInfo&); TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocInfo.html:734,Usability,Clear,Clear,734," virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char",MatchSource.WIKI,root/html602/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html
https://root.cern/root/html602/TClassDocOutput.html:2620,Availability,Error,Error,2620,"Copy(TObject& object) const; Bool_tTDocOutput::CopyHtmlFile(const char* sourceName, const char* destName = """"); voidCreateClassHierarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; ",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:2749,Availability,error,error,2749,"erarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() con",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:2833,Availability,error,error,2833,"ndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:12409,Availability,down,down,12409,"ludes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the h",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:15433,Deployability,update,updates,15433,"d in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write method name with return type ret and parameters param to out.; Build a link using file and anchor. Cooment it with comment, and; show the code codeOneLiner (set if the func consists of only one line; of code, immediately surrounded by ""{"",""}""). Also updates fMethodNames's; count of method names. TClassDocOutput(THtml& html, TClass* cl, TList* typedefs).  Author: Axel Naumann 2007-01-09  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/html:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:751,Integrability,interface,interfaces,751,". TClassDocOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HTML;  TClassDocOutput. class TClassDocOutput: public TDocOutput. Write the documentation for a class or namespace. The documentation is; parsed by TDocParser and then passed to TClassDocOutput to generate; the class doc header, the class description, members overview, and method; documentation. All generic output functionality is in TDocOutput; it is; re-used in this derived class. You usually do not use this class yourself; it is invoked indirectly by; THtml. Customization of the output should happen via the interfaces defined; by THtml. Function Members (Methods); public:. virtual~TClassDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDocOutput::AdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); voidClass2Html(Bool_t force = kFALSE); Bool_tClassDotCharts(ostream& out); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTDocOutput::Convert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tTDocOutput::CopyHtmlFile(const char* sourceName, const char* destName = """"); voidCreateClassHierarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:12007,Integrability,depend,dependencies,12007,"utput::ETraversekBoth; static TDocOutput::EGraphvizToolTDocOutput::kCirco; static TDocOutput::EGraphvizToolTDocOutput::kDot; static TClassDocOutput::ETraversekDown; static TDocOutput::EGraphvizToolTDocOutput::kFdp; static TDocOutput::EGraphvizToolTDocOutput::kNeato; static TClassDocOutput::ETraversekUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:12038,Integrability,depend,dependency,12038,"utput::ETraversekBoth; static TDocOutput::EGraphvizToolTDocOutput::kCirco; static TDocOutput::EGraphvizToolTDocOutput::kDot; static TClassDocOutput::ETraversekDown; static TDocOutput::EGraphvizToolTDocOutput::kFdp; static TDocOutput::EGraphvizToolTDocOutput::kNeato; static TClassDocOutput::ETraversekUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:13010,Integrability,depend,dependency,13010,"clude dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxL",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:13183,Integrability,depend,dependency,13183,"int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:14293,Integrability,rout,routine,14293," char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write method name with return type ret and parameters param to out.; Build a link using file and anchor. Cooment it with comment, and; show the code codeO",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:3852,Modifiability,Inherit,InheritsFrom,3852,"Object::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTDocOutput::IsModified(TClass* classPtr, TDocOutput::EFileType type); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeTree(Bool_t force = kFALSE); voidTObject::MayNotUse(const char* method) const; virtual voidTDocOutput::NameSpace2FileName(TString& name); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* p",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:3918,Modifiability,Inherit,InheritsFrom,3918,"dTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTDocOutput::IsModified(TClass* classPtr, TDocOutput::EFileType type); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeTree(Bool_t force = kFALSE); voidTObject::MayNotUse(const char* method) const; virtual voidTDocOutput::NameSpace2FileName(TString& name); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:11328,Modifiability,Inherit,Inheritance,11328,"Object::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TDocOutput::EFileTypeTDocOutput::kSource; static TDocOutput::EFileTypeTDocOutput::kTree; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TClass*fCurrentClassclass to generate output for; TList*fCurrentClassesTypedefstypedefs to the current class; Int_tfHierarchyLinescounter for no. lines in hierarchy; THtml*TDocOutput::fHtmlTHtml object we belong to; TDocParser*fParserparser we use; static TClassDocOutput::ETraversekBoth; static TDocOutput::EGraphvizToolTDocOutput::kCirco; static TDocOutput::EGraphvizToolTDocOutput::kDot; static TClassDocOutput::ETraversekDown; static TDocOutput::EGraphvizToolTDocOutput::kFdp; static TDocOutput::EGraphvizToolTDocOutput::kNeato; static TClassDocOutput::ETraversekUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - point",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:11341,Modifiability,Inherit,Inherited,11341,"Object::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TDocOutput::EFileTypeTDocOutput::kSource; static TDocOutput::EFileTypeTDocOutput::kTree; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TClass*fCurrentClassclass to generate output for; TList*fCurrentClassesTypedefstypedefs to the current class; Int_tfHierarchyLinescounter for no. lines in hierarchy; THtml*TDocOutput::fHtmlTHtml object we belong to; TDocParser*fParserparser we use; static TClassDocOutput::ETraversekBoth; static TDocOutput::EGraphvizToolTDocOutput::kCirco; static TDocOutput::EGraphvizToolTDocOutput::kDot; static TClassDocOutput::ETraversekDown; static TDocOutput::EGraphvizToolTDocOutput::kFdp; static TDocOutput::EGraphvizToolTDocOutput::kNeato; static TClassDocOutput::ETraversekUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - point",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:11974,Modifiability,inherit,inheritance,11974,"utput::ETraversekBoth; static TDocOutput::EGraphvizToolTDocOutput::kCirco; static TDocOutput::EGraphvizToolTDocOutput::kDot; static TClassDocOutput::ETraversekDown; static TDocOutput::EGraphvizToolTDocOutput::kFdp; static TDocOutput::EGraphvizToolTDocOutput::kNeato; static TClassDocOutput::ETraversekUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:12250,Modifiability,inherit,inherited,12250,"EGraphvizToolTDocOutput::kFdp; static TDocOutput::EGraphvizToolTDocOutput::kNeato; static TClassDocOutput::ETraversekUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:12836,Modifiability,inherit,inherited,12836," of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .c",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:14234,Modifiability,inherit,inheritance,14234,"endency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write meth",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:14803,Modifiability,inherit,inheritance,14803,"lass is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write method name with return type ret and parameters param to out.; Build a link using file and anchor. Cooment it with comment, and; show the code codeOneLiner (set if the func consists of only one line; of code, immediately surrounded by ""{"",""}""). Also updates fMethodNames's; count of method names. TClassDocOutput(THtml& html, TClass* cl, TList* typedefs).  Author: Axel Naumann 2007-01-09  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/html:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the d",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:3742,Security,Hash,Hash,3742,"t_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTDocOutput::IsModified(TClass* classPtr, TDocOutput::EFileType type); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeTree(Bool_t force = kFALSE); voidTObject::MayNotUse(const char* method) const; virtual voidTDocOutput::NameSpace2FileName(TString& name); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::opera",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:6879,Testability,Test,TestBit,6879,"* entity, const char* comment = 0); virtual voidTDocOutput::ReferenceEntity(TSubString& str, TMethod* entity, const char* comment = 0); virtual Bool_tTDocOutput::ReferenceIsRelative(const char* reference) const; virtual const char*TDocOutput::ReplaceSpecialChars(char c); voidTDocOutput::ReplaceSpecialChars(TString& text); voidTDocOutput::ReplaceSpecialChars(ostream& out, const char* string); voidTDocOutput::ReplaceSpecialChars(TString& text, Ssiz_t& pos); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassDocOutput(const TClassDocOutput&); TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTDocOutput::WriteHtmlFooter(ostream& out, const char* dir = """", const char* lastUpdate = """", const char* author = """", const char* copyright = """"); virtual voidTDocOutput::WriteHtmlHeader(ostream& out, const char* title, const char* dir = """", TClass* cls = 0); voidTDocOutput::WriteLineNumbers(ostream& out, Long_t nLines, const TString& infileBase) const.",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:6918,Testability,Test,TestBits,6918,"* entity, const char* comment = 0); virtual voidTDocOutput::ReferenceEntity(TSubString& str, TMethod* entity, const char* comment = 0); virtual Bool_tTDocOutput::ReferenceIsRelative(const char* reference) const; virtual const char*TDocOutput::ReplaceSpecialChars(char c); voidTDocOutput::ReplaceSpecialChars(TString& text); voidTDocOutput::ReplaceSpecialChars(ostream& out, const char* string); voidTDocOutput::ReplaceSpecialChars(TString& text, Ssiz_t& pos); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassDocOutput(const TClassDocOutput&); TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTDocOutput::WriteHtmlFooter(ostream& out, const char* dir = """", const char* lastUpdate = """", const char* author = """", const char* copyright = """"); virtual voidTDocOutput::WriteHtmlHeader(ostream& out, const char* title, const char* dir = """", TClass* cls = 0); voidTDocOutput::WriteLineNumbers(ostream& out, Long_t nLines, const TString& infileBase) const.",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassDocOutput.html:1249,Usability,Clear,Clear,1249,"Output. class TClassDocOutput: public TDocOutput. Write the documentation for a class or namespace. The documentation is; parsed by TDocParser and then passed to TClassDocOutput to generate; the class doc header, the class description, members overview, and method; documentation. All generic output functionality is in TDocOutput; it is; re-used in this derived class. You usually do not use this class yourself; it is invoked indirectly by; THtml. Customization of the output should happen via the interfaces defined; by THtml. Function Members (Methods); public:. virtual~TClassDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDocOutput::AdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); voidClass2Html(Bool_t force = kFALSE); Bool_tClassDotCharts(ostream& out); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTDocOutput::Convert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tTDocOutput::CopyHtmlFile(const char* sourceName, const char* destName = """"); voidCreateClassHierarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser:",MatchSource.WIKI,root/html602/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html
https://root.cern/root/html602/TClassEdit.html:450,Availability,error,errorCode,450,". TClassEdit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  CORE;  METAUTILS;  TClassEdit. namespace TClassEdit. Function Members (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); char*DemangleName(const char* mangled_name, int& errorCode); char*DemangleTypeIdName(const type_info& ti, int& errorCode); TClassEdit::EComplexTypeGetComplexType(const char*); stringGetLong64_Name(const char* original); stringGetLong64_Name(const string& original); voidGetNormalizedName(string& norm_name, const char* name); intGetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone); const char*GetUnqualifiedName(const char* name); voidInit(TClassEdit::TInterpreterLookupHelper* helper); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsInterpreterDetail(const char* type); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); ROOT::ESTLTypeIsSTLCont(const char* type); intIsSTLCont(const char* type, int testAlloc); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); ROOT::ESTLTypeSTLKind(const char* type, size_t len = 0). Data Members. Class Charts; Function documentation; void Init(TClassEdit::TInterpreterLookupHelper* helper). ROOT::ESTLType STLKind(const char* type, size_t len = 0); Converts STL container name to number. vector -> 1, etc..; If len is greater than 0, only look at that many characters in the string. int STLArgs(int kind); Return number of arguments for STL container before allo",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:512,Availability,error,errorCode,512,". TClassEdit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  CORE;  METAUTILS;  TClassEdit. namespace TClassEdit. Function Members (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); char*DemangleName(const char* mangled_name, int& errorCode); char*DemangleTypeIdName(const type_info& ti, int& errorCode); TClassEdit::EComplexTypeGetComplexType(const char*); stringGetLong64_Name(const char* original); stringGetLong64_Name(const string& original); voidGetNormalizedName(string& norm_name, const char* name); intGetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone); const char*GetUnqualifiedName(const char* name); voidInit(TClassEdit::TInterpreterLookupHelper* helper); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsInterpreterDetail(const char* type); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); ROOT::ESTLTypeIsSTLCont(const char* type); intIsSTLCont(const char* type, int testAlloc); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); ROOT::ESTLTypeSTLKind(const char* type, size_t len = 0). Data Members. Class Charts; Function documentation; void Init(TClassEdit::TInterpreterLookupHelper* helper). ROOT::ESTLType STLKind(const char* type, size_t len = 0); Converts STL container name to number. vector -> 1, etc..; If len is greater than 0, only look at that many characters in the string. int STLArgs(int kind); Return number of arguments for STL container before allo",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:3820,Availability,redundant,redundant,3820,"etLong64_Name(const char* original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. string GetLong64_Name(const string& original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. const char * GetUnqualifiedName(const char* name); Return the start of the unqualified name include in 'original'. int GetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). Stores in output (after emptying it) the splited type.; Stores the location of the tail (nested names) in nestedLoc (0 indicates no tail).; Return the number of elements stored. First in list is the template name or is empty; ""vector<list<int>,alloc>**"" to ""vector"" ""list<int>"" ""alloc"" ""**""; or ""TNamed*"" to """" ""TNamed"" ""*"". string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). Cleanup type description, redundant blanks removed; and redundant tail ignored; return *tail = pointer to last used character; if (mode==0) keep keywords; if (mode==1) remove keywords outside the template params; if (mode>=2) remove the keywords everywhere.; if (tail!=0) cut before the trailing *. The keywords currently are: ""const"" , ""volatile"" removed. CleanType("" A<B, C< D, E> > *,F,G>"") returns ""A<B,C<D,E> >*"". string ShortType(const char* typeDesc, int mode). Return the absolute type of typeDesc.; E.g.: typeDesc = ""class const volatile TNamed**"", returns ""TNamed**"".; if (mode&1) remove last ""*""s returns ""TNamed""; if (mode&2) remove default allocators from STL containers; if (mode&4) remove all allocators from STL containers; if (mode&8) return inner class of stl container. list<innerClass>; if (mode&16) return deapest class of stl container. vector<list<deapest>>; if (mode&kDropAllDefault) remove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* typ",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:3850,Availability,redundant,redundant,3850,"etLong64_Name(const char* original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. string GetLong64_Name(const string& original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. const char * GetUnqualifiedName(const char* name); Return the start of the unqualified name include in 'original'. int GetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). Stores in output (after emptying it) the splited type.; Stores the location of the tail (nested names) in nestedLoc (0 indicates no tail).; Return the number of elements stored. First in list is the template name or is empty; ""vector<list<int>,alloc>**"" to ""vector"" ""list<int>"" ""alloc"" ""**""; or ""TNamed*"" to """" ""TNamed"" ""*"". string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). Cleanup type description, redundant blanks removed; and redundant tail ignored; return *tail = pointer to last used character; if (mode==0) keep keywords; if (mode==1) remove keywords outside the template params; if (mode>=2) remove the keywords everywhere.; if (tail!=0) cut before the trailing *. The keywords currently are: ""const"" , ""volatile"" removed. CleanType("" A<B, C< D, E> > *,F,G>"") returns ""A<B,C<D,E> >*"". string ShortType(const char* typeDesc, int mode). Return the absolute type of typeDesc.; E.g.: typeDesc = ""class const volatile TNamed**"", returns ""TNamed**"".; if (mode&1) remove last ""*""s returns ""TNamed""; if (mode&2) remove default allocators from STL containers; if (mode&4) remove all allocators from STL containers; if (mode&8) return inner class of stl container. list<innerClass>; if (mode&16) return deapest class of stl container. vector<list<deapest>>; if (mode&kDropAllDefault) remove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* typ",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:6032,Availability,error,errorCode,6032,"ove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* type); Return true is the name is std::bitset<number> or bitset<number>. ROOT::ESTLType IsSTLCont(const char* type); type : type name: vector<list<classA,allocator>,allocator>; result: 0 : not stl container; code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset. int IsSTLCont(const char* type, int testAlloc); type : type name: vector<list<classA,allocator>,allocator>; testAlloc: if true, we test allocator, if it is not default result is negative; result: 0 : not stl container; abs(result): code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset; positive val: we have a vector or list with default allocator to any depth; like vector<list<vector<int>>>; negative val: STL container other than vector or list, or non default allocator; For example: vector<deque<int>> has answer -1. bool IsStdClass(const char* type); return true if the class belond to the std namespace. bool IsVectorBool(const char* name). string ResolveTypedef(const char* tname, bool resolveAll = false). string InsertStd(const char* tname). char* DemangleTypeIdName(const type_info& ti, int& errorCode); Demangle in a portable way the type id name.; IMPORTANT: The caller is responsible for freeing the returned const char*. EComplexType GetComplexType(const char* ). char* DemangleName(const char* mangled_name, int& errorCode); Demangle in a portable way the name.; IMPORTANT: The caller is responsible for freeing the returned const char*.  Author: Victor Perev 10/04/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *;  Last changed: root/metautils:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:6258,Availability,error,errorCode,6258,"ove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* type); Return true is the name is std::bitset<number> or bitset<number>. ROOT::ESTLType IsSTLCont(const char* type); type : type name: vector<list<classA,allocator>,allocator>; result: 0 : not stl container; code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset. int IsSTLCont(const char* type, int testAlloc); type : type name: vector<list<classA,allocator>,allocator>; testAlloc: if true, we test allocator, if it is not default result is negative; result: 0 : not stl container; abs(result): code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset; positive val: we have a vector or list with default allocator to any depth; like vector<list<vector<int>>>; negative val: STL container other than vector or list, or non default allocator; For example: vector<deque<int>> has answer -1. bool IsStdClass(const char* type); return true if the class belond to the std namespace. bool IsVectorBool(const char* name). string ResolveTypedef(const char* tname, bool resolveAll = false). string InsertStd(const char* tname). char* DemangleTypeIdName(const type_info& ti, int& errorCode); Demangle in a portable way the type id name.; IMPORTANT: The caller is responsible for freeing the returned const char*. EComplexType GetComplexType(const char* ). char* DemangleName(const char* mangled_name, int& errorCode); Demangle in a portable way the name.; IMPORTANT: The caller is responsible for freeing the returned const char*.  Author: Victor Perev 10/04/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *;  Last changed: root/metautils:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:2850,Integrability,rout,routines,2850,"greater than 0, only look at that many characters in the string. int STLArgs(int kind); Return number of arguments for STL container before allocator. bool IsDefAlloc(const char* alloc, const char* classname); return whether or not 'allocname' is the STL default allocator for type; 'classname'. bool IsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); return whether or not 'allocname' is the STL default allocator for a key; of type 'keyclassname' and a value of type 'valueclassname'. bool IsDefComp(const char* comp, const char* classname); return whether or not 'compare' is the STL default comparator for type; 'classname'. void GetNormalizedName(string& norm_name, const char* name); Return the normalized name. See TMetaUtils::GetNormalizedName. Return the type name normalized for ROOT,; keeping only the ROOT opaque typedef (Double32_t, etc.) and; removing the STL collections default parameter if any. Compare to TMetaUtils::GetNormalizedName, this routines does not; and can not add default template parameters. string GetLong64_Name(const char* original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. string GetLong64_Name(const string& original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. const char * GetUnqualifiedName(const char* name); Return the start of the unqualified name include in 'original'. int GetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). Stores in output (after emptying it) the splited type.; Stores the location of the tail (nested names) in nestedLoc (0 indicates no tail).; Return the number of elements stored. First in list is the template name or is empty; ""vector<list<int>,alloc>**"" to ""vector"" ""list<int>"" ""alloc"" ""**""; or ""TNamed*"" to """" ""TNamed"" ""*"". string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). Cleanup type description, redundant blanks removed; and redundan",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:6058,Modifiability,portab,portable,6058,"ove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* type); Return true is the name is std::bitset<number> or bitset<number>. ROOT::ESTLType IsSTLCont(const char* type); type : type name: vector<list<classA,allocator>,allocator>; result: 0 : not stl container; code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset. int IsSTLCont(const char* type, int testAlloc); type : type name: vector<list<classA,allocator>,allocator>; testAlloc: if true, we test allocator, if it is not default result is negative; result: 0 : not stl container; abs(result): code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset; positive val: we have a vector or list with default allocator to any depth; like vector<list<vector<int>>>; negative val: STL container other than vector or list, or non default allocator; For example: vector<deque<int>> has answer -1. bool IsStdClass(const char* type); return true if the class belond to the std namespace. bool IsVectorBool(const char* name). string ResolveTypedef(const char* tname, bool resolveAll = false). string InsertStd(const char* tname). char* DemangleTypeIdName(const type_info& ti, int& errorCode); Demangle in a portable way the type id name.; IMPORTANT: The caller is responsible for freeing the returned const char*. EComplexType GetComplexType(const char* ). char* DemangleName(const char* mangled_name, int& errorCode); Demangle in a portable way the name.; IMPORTANT: The caller is responsible for freeing the returned const char*.  Author: Victor Perev 10/04/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *;  Last changed: root/metautils:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:6284,Modifiability,portab,portable,6284,"ove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* type); Return true is the name is std::bitset<number> or bitset<number>. ROOT::ESTLType IsSTLCont(const char* type); type : type name: vector<list<classA,allocator>,allocator>; result: 0 : not stl container; code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset. int IsSTLCont(const char* type, int testAlloc); type : type name: vector<list<classA,allocator>,allocator>; testAlloc: if true, we test allocator, if it is not default result is negative; result: 0 : not stl container; abs(result): code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset; positive val: we have a vector or list with default allocator to any depth; like vector<list<vector<int>>>; negative val: STL container other than vector or list, or non default allocator; For example: vector<deque<int>> has answer -1. bool IsStdClass(const char* type); return true if the class belond to the std namespace. bool IsVectorBool(const char* name). string ResolveTypedef(const char* tname, bool resolveAll = false). string InsertStd(const char* tname). char* DemangleTypeIdName(const type_info& ti, int& errorCode); Demangle in a portable way the type id name.; IMPORTANT: The caller is responsible for freeing the returned const char*. EComplexType GetComplexType(const char* ). char* DemangleName(const char* mangled_name, int& errorCode); Demangle in a portable way the name.; IMPORTANT: The caller is responsible for freeing the returned const char*.  Author: Victor Perev 10/04/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *;  Last changed: root/metautils:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:3820,Safety,redund,redundant,3820,"etLong64_Name(const char* original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. string GetLong64_Name(const string& original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. const char * GetUnqualifiedName(const char* name); Return the start of the unqualified name include in 'original'. int GetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). Stores in output (after emptying it) the splited type.; Stores the location of the tail (nested names) in nestedLoc (0 indicates no tail).; Return the number of elements stored. First in list is the template name or is empty; ""vector<list<int>,alloc>**"" to ""vector"" ""list<int>"" ""alloc"" ""**""; or ""TNamed*"" to """" ""TNamed"" ""*"". string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). Cleanup type description, redundant blanks removed; and redundant tail ignored; return *tail = pointer to last used character; if (mode==0) keep keywords; if (mode==1) remove keywords outside the template params; if (mode>=2) remove the keywords everywhere.; if (tail!=0) cut before the trailing *. The keywords currently are: ""const"" , ""volatile"" removed. CleanType("" A<B, C< D, E> > *,F,G>"") returns ""A<B,C<D,E> >*"". string ShortType(const char* typeDesc, int mode). Return the absolute type of typeDesc.; E.g.: typeDesc = ""class const volatile TNamed**"", returns ""TNamed**"".; if (mode&1) remove last ""*""s returns ""TNamed""; if (mode&2) remove default allocators from STL containers; if (mode&4) remove all allocators from STL containers; if (mode&8) return inner class of stl container. list<innerClass>; if (mode&16) return deapest class of stl container. vector<list<deapest>>; if (mode&kDropAllDefault) remove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* typ",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:3850,Safety,redund,redundant,3850,"etLong64_Name(const char* original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. string GetLong64_Name(const string& original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. const char * GetUnqualifiedName(const char* name); Return the start of the unqualified name include in 'original'. int GetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). Stores in output (after emptying it) the splited type.; Stores the location of the tail (nested names) in nestedLoc (0 indicates no tail).; Return the number of elements stored. First in list is the template name or is empty; ""vector<list<int>,alloc>**"" to ""vector"" ""list<int>"" ""alloc"" ""**""; or ""TNamed*"" to """" ""TNamed"" ""*"". string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). Cleanup type description, redundant blanks removed; and redundant tail ignored; return *tail = pointer to last used character; if (mode==0) keep keywords; if (mode==1) remove keywords outside the template params; if (mode>=2) remove the keywords everywhere.; if (tail!=0) cut before the trailing *. The keywords currently are: ""const"" , ""volatile"" removed. CleanType("" A<B, C< D, E> > *,F,G>"") returns ""A<B,C<D,E> >*"". string ShortType(const char* typeDesc, int mode). Return the absolute type of typeDesc.; E.g.: typeDesc = ""class const volatile TNamed**"", returns ""TNamed**"".; if (mode&1) remove last ""*""s returns ""TNamed""; if (mode&2) remove default allocators from STL containers; if (mode&4) remove all allocators from STL containers; if (mode&8) return inner class of stl container. list<innerClass>; if (mode&16) return deapest class of stl container. vector<list<deapest>>; if (mode&kDropAllDefault) remove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* typ",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:1379,Testability,test,testAlloc,1379,". TClassEdit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT;  CORE;  METAUTILS;  TClassEdit. namespace TClassEdit. Function Members (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); char*DemangleName(const char* mangled_name, int& errorCode); char*DemangleTypeIdName(const type_info& ti, int& errorCode); TClassEdit::EComplexTypeGetComplexType(const char*); stringGetLong64_Name(const char* original); stringGetLong64_Name(const string& original); voidGetNormalizedName(string& norm_name, const char* name); intGetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone); const char*GetUnqualifiedName(const char* name); voidInit(TClassEdit::TInterpreterLookupHelper* helper); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsInterpreterDetail(const char* type); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); ROOT::ESTLTypeIsSTLCont(const char* type); intIsSTLCont(const char* type, int testAlloc); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); ROOT::ESTLTypeSTLKind(const char* type, size_t len = 0). Data Members. Class Charts; Function documentation; void Init(TClassEdit::TInterpreterLookupHelper* helper). ROOT::ESTLType STLKind(const char* type, size_t len = 0); Converts STL container name to number. vector -> 1, etc..; If len is greater than 0, only look at that many characters in the string. int STLArgs(int kind); Return number of arguments for STL container before allo",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:5241,Testability,test,testAlloc,5241,"; if (mode&4) remove all allocators from STL containers; if (mode&8) return inner class of stl container. list<innerClass>; if (mode&16) return deapest class of stl container. vector<list<deapest>>; if (mode&kDropAllDefault) remove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* type); Return true is the name is std::bitset<number> or bitset<number>. ROOT::ESTLType IsSTLCont(const char* type); type : type name: vector<list<classA,allocator>,allocator>; result: 0 : not stl container; code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset. int IsSTLCont(const char* type, int testAlloc); type : type name: vector<list<classA,allocator>,allocator>; testAlloc: if true, we test allocator, if it is not default result is negative; result: 0 : not stl container; abs(result): code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset; positive val: we have a vector or list with default allocator to any depth; like vector<list<vector<int>>>; negative val: STL container other than vector or list, or non default allocator; For example: vector<deque<int>> has answer -1. bool IsStdClass(const char* type); return true if the class belond to the std namespace. bool IsVectorBool(const char* name). string ResolveTypedef(const char* tname, bool resolveAll = false). string InsertStd(const char* tname). char* DemangleTypeIdName(const type_info& ti, int& errorCode); Demangle in a portable way the type id name.; IMPORTANT: The caller is responsible for freeing the returned const char*. EComplexType GetComplexType(const char* ). char* DemangleName(const char* mangled_name, int& errorCode); Demangle in a portable way the name.; IMPORTANT: The caller is responsible for freeing the returned const char*.  Author: Victor Perev 10/04/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *;",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:5313,Testability,test,testAlloc,5313,"; if (mode&4) remove all allocators from STL containers; if (mode&8) return inner class of stl container. list<innerClass>; if (mode&16) return deapest class of stl container. vector<list<deapest>>; if (mode&kDropAllDefault) remove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* type); Return true is the name is std::bitset<number> or bitset<number>. ROOT::ESTLType IsSTLCont(const char* type); type : type name: vector<list<classA,allocator>,allocator>; result: 0 : not stl container; code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset. int IsSTLCont(const char* type, int testAlloc); type : type name: vector<list<classA,allocator>,allocator>; testAlloc: if true, we test allocator, if it is not default result is negative; result: 0 : not stl container; abs(result): code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset; positive val: we have a vector or list with default allocator to any depth; like vector<list<vector<int>>>; negative val: STL container other than vector or list, or non default allocator; For example: vector<deque<int>> has answer -1. bool IsStdClass(const char* type); return true if the class belond to the std namespace. bool IsVectorBool(const char* name). string ResolveTypedef(const char* tname, bool resolveAll = false). string InsertStd(const char* tname). char* DemangleTypeIdName(const type_info& ti, int& errorCode); Demangle in a portable way the type id name.; IMPORTANT: The caller is responsible for freeing the returned const char*. EComplexType GetComplexType(const char* ). char* DemangleName(const char* mangled_name, int& errorCode); Demangle in a portable way the name.; IMPORTANT: The caller is responsible for freeing the returned const char*.  Author: Victor Perev 10/04/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *;",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassEdit.html:5336,Testability,test,test,5336,"; if (mode&4) remove all allocators from STL containers; if (mode&8) return inner class of stl container. list<innerClass>; if (mode&16) return deapest class of stl container. vector<list<deapest>>; if (mode&kDropAllDefault) remove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* type); Return true is the name is std::bitset<number> or bitset<number>. ROOT::ESTLType IsSTLCont(const char* type); type : type name: vector<list<classA,allocator>,allocator>; result: 0 : not stl container; code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset. int IsSTLCont(const char* type, int testAlloc); type : type name: vector<list<classA,allocator>,allocator>; testAlloc: if true, we test allocator, if it is not default result is negative; result: 0 : not stl container; abs(result): code of container 1=vector,2=list,3=deque,4=map; 5=multimap,6=set,7=multiset; positive val: we have a vector or list with default allocator to any depth; like vector<list<vector<int>>>; negative val: STL container other than vector or list, or non default allocator; For example: vector<deque<int>> has answer -1. bool IsStdClass(const char* type); return true if the class belond to the std namespace. bool IsVectorBool(const char* name). string ResolveTypedef(const char* tname, bool resolveAll = false). string InsertStd(const char* tname). char* DemangleTypeIdName(const type_info& ti, int& errorCode); Demangle in a portable way the type id name.; IMPORTANT: The caller is responsible for freeing the returned const char*. EComplexType GetComplexType(const char* ). char* DemangleName(const char* mangled_name, int& errorCode); Demangle in a portable way the name.; IMPORTANT: The caller is responsible for freeing the returned const char*.  Author: Victor Perev 10/04/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *;",MatchSource.WIKI,root/html602/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassEdit.html
https://root.cern/root/html602/TClassGenerator.html:654,Availability,avail,available,654,". TClassGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TClassGenerator. class TClassGenerator: public TObject. TClassGenerator. Objects following this interface can be passed onto the TROOT object; to implement a user customized way to create the TClass objects. Use TROOT::AddClassGenerator to register a concrete instance. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:1471,Availability,Error,Error,1471," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:1600,Availability,error,error,1600," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:1684,Availability,error,error,1684," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Han",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:346,Integrability,interface,interface,346,". TClassGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TClassGenerator. class TClassGenerator: public TObject. TClassGenerator. Objects following this interface can be passed onto the TROOT object; to implement a user customized way to create the TClass objects. Use TROOT::AddClassGenerator to register a concrete instance. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:2846,Modifiability,Inherit,InheritsFrom,2846,"t*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:2912,Modifiability,Inherit,InheritsFrom,2912,"ject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TClassGenerator&operator=(const TClassGenerator&); ",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:6219,Modifiability,Inherit,Inheritance,6219,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual~TClassGenerator(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TClassGenerator(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClassGenerator(); { }. virtual ~TClassGenerator(); { }. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load).  Author: Philippe Canal 24/06/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *;  Last changed: root/base:$Id$  Last generated: 2015-06-02 13:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:6232,Modifiability,Inherit,Inherited,6232,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual~TClassGenerator(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TClassGenerator(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClassGenerator(); { }. virtual ~TClassGenerator(); { }. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load).  Author: Philippe Canal 24/06/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *;  Last changed: root/base:$Id$  Last generated: 2015-06-02 13:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:2016,Performance,load,load,2016,"virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UIn",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:2081,Performance,load,load,2081,"voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqua",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:2142,Performance,load,load,2142,"::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder(",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:2222,Performance,load,load,2222,"Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() co",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:6344,Performance,load,load,6344,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual~TClassGenerator(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TClassGenerator(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClassGenerator(); { }. virtual ~TClassGenerator(); { }. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load).  Author: Philippe Canal 24/06/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *;  Last changed: root/base:$Id$  Last generated: 2015-06-02 13:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:6500,Performance,load,load,6500,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual~TClassGenerator(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TClassGenerator(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClassGenerator(); { }. virtual ~TClassGenerator(); { }. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load).  Author: Philippe Canal 24/06/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *;  Last changed: root/base:$Id$  Last generated: 2015-06-02 13:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:6709,Performance,load,load,6709,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual~TClassGenerator(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TClassGenerator(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClassGenerator(); { }. virtual ~TClassGenerator(); { }. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load).  Author: Philippe Canal 24/06/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *;  Last changed: root/base:$Id$  Last generated: 2015-06-02 13:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:6768,Performance,load,load,6768,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual~TClassGenerator(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TClassGenerator(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClassGenerator(); { }. virtual ~TClassGenerator(); { }. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load).  Author: Philippe Canal 24/06/2003  Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *;  Last changed: root/base:$Id$  Last generated: 2015-06-02 13:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:2736,Security,Hash,Hash,2736,"ent, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:4905,Testability,Test,TestBit,4905,"tual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TClassGenerator&operator=(const TClassGenerator&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassGenerator(const TClassGenerator&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:4944,Testability,Test,TestBits,4944,"tual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TClassGenerator&operator=(const TClassGenerator&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassGenerator(const TClassGenerator&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassGenerator.html:931,Usability,Clear,Clear,931," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html602/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassGenerator.html
https://root.cern/root/html602/TClassMenuItem.html:1733,Availability,Error,Error,1733," virtual~TClassMenuItem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t eve",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:1862,Availability,error,error,1862," virtual~TClassMenuItem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t eve",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:1946,Availability,error,error,1946," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetArgs() const; virtual TObject*GetCalledObject() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetFunctionName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSelfObjectPos() const; virtual const char*GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* ",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:5037,Deployability,toggle,toggle,5037,"bject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCall(TObject* obj, const char* method, const char* args = """", Int_t selfobjposition = 0); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSelf(Bool_t self); virtual voidSetTitle(const char* title); virtual voidSetToggle(Bool_t toggle = kTRUE); virtual voidSetType(Int_t type); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassMenuItem(); TClassMenuItem(Int_t type, TClass* parent, const char* title = """", const char* functionname = """", TObject* obj = 0, const char* args = """", Int_t selfobjposition = -1, Bool_t self = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:7642,Deployability,toggle,toggle,7642,"s)kIsExternal; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TClassMenuItem::(anonymous)kIsSelf; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TClassMenuItem::EClassMenuItemTypekPopupSeparator; static TClassMenuItem::EClassMenuItemTypekPopupStandardList; static TClassMenuItem::EClassMenuItemTypekPopupUserFunction; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfArgsarguments type list *** NOT CHECKED ***; TObject*fCalledObjectobject to be called; TStringfFunctionNamename of the function or method to be called; TClass*fParentparent class; Bool_tfSelfflag to indicate that object to be called is the selected one; Int_tfSelfObjectPosrang in argument list corresponding to the object being clicked on; TList*fSubMenulist of submenu items; TStringfTitletitle if not standard; Bool_tfToggleflag toggle method; TClassMenuItem::EClassMenuItemTypefTypetype flag (EClassMenuItemType). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassMenuItem(); Default TClassMenuItem ctor. TClassMenuItems are constructed in TClass; with a standard content but may be customized later; fType = 0 : external method/function; fType = 1 : separator; fType = 2 : standard methods list. TClassMenuItem(Int_t type, TClass* parent, const char* title = """", const char* functionname = """", TObject* obj = 0, const char* args = """", Int_t selfobjposition = -1, Bool_t self = kFALSE); TClassMenuItem ctor. TClassMenuItems are constructed in TClass; with a standard content but may be customized later; type = 0 : external method/function; type = 1 : separator; type = 2 : standard methods list; self i",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:9925,Deployability,toggle,toggle,9925,"al method/function; type = 1 : separator; type = 2 : standard methods list; self indicates if the object to be called is the one selected; by the popup menu; selfobjposition, if non zero, indicates the position in the arguments; list of the argument corresponding to the selected (clicked) object.; This argument in the calling method should be a TObject*; Note: It is the responsability of the caller/creator to add to the; menu list. TClassMenuItem(const TClassMenuItem& ); copy constructor; Note: It is the responsability of the caller/creator to add to the; menu list. TClassMenuItem& operator=(const TClassMenuItem& ); assignement operator; Note: It is the responsability of the caller/creator to add to the; menu list. ~TClassMenuItem(); TClassMenuItem dtor. const char * GetTitle() const; { return fTitle; }. const char * GetFunctionName() const; { return fFunctionName; }. const char * GetArgs() const; { return fArgs; }. TObject * GetCalledObject() const; { return fCalledObject; }. Int_t GetType() const; { return fType; }. Int_t GetSelfObjectPos() const; { return fSelfObjectPos; }. Bool_t IsCallSelf() const; { return fSelf; }. Bool_t IsSeparator() const; { return fType==kPopupSeparator ? kTRUE : kFALSE; }. Bool_t IsStandardList() const; { return fType==kPopupStandardList ? kTRUE : kFALSE; }. Bool_t IsToggle() const; { return fToggle; }. void SetType(Int_t type); { fType = (EClassMenuItemType) type; }. void SetTitle(const char* title); { fTitle = title; }. void SetSelf(Bool_t self); { fSelf = self; }. void SetToggle(Bool_t toggle = kTRUE); { fToggle = toggle; }. void SetCall(TObject* obj, const char* method, const char* args = """", Int_t selfobjposition = 0).  Author: Damir Buskulic 23/11/2001  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:9954,Deployability,toggle,toggle,9954,"al method/function; type = 1 : separator; type = 2 : standard methods list; self indicates if the object to be called is the one selected; by the popup menu; selfobjposition, if non zero, indicates the position in the arguments; list of the argument corresponding to the selected (clicked) object.; This argument in the calling method should be a TObject*; Note: It is the responsability of the caller/creator to add to the; menu list. TClassMenuItem(const TClassMenuItem& ); copy constructor; Note: It is the responsability of the caller/creator to add to the; menu list. TClassMenuItem& operator=(const TClassMenuItem& ); assignement operator; Note: It is the responsability of the caller/creator to add to the; menu list. ~TClassMenuItem(); TClassMenuItem dtor. const char * GetTitle() const; { return fTitle; }. const char * GetFunctionName() const; { return fFunctionName; }. const char * GetArgs() const; { return fArgs; }. TObject * GetCalledObject() const; { return fCalledObject; }. Int_t GetType() const; { return fType; }. Int_t GetSelfObjectPos() const; { return fSelfObjectPos; }. Bool_t IsCallSelf() const; { return fSelf; }. Bool_t IsSeparator() const; { return fType==kPopupSeparator ? kTRUE : kFALSE; }. Bool_t IsStandardList() const; { return fType==kPopupStandardList ? kTRUE : kFALSE; }. Bool_t IsToggle() const; { return fToggle; }. void SetType(Int_t type); { fType = (EClassMenuItemType) type; }. void SetTitle(const char* title); { fTitle = title; }. void SetSelf(Bool_t self); { fSelf = self; }. void SetToggle(Bool_t toggle = kTRUE); { fToggle = toggle; }. void SetCall(TObject* obj, const char* method, const char* args = """", Int_t selfobjposition = 0).  Author: Damir Buskulic 23/11/2001  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:3007,Modifiability,Inherit,InheritsFrom,3007,", Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetArgs() const; virtual TObject*GetCalledObject() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetFunctionName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSelfObjectPos() const; virtual const char*GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsCallSelf() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSeparator() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsStandardList() const; virtual Bool_tIsToggle() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:3073,Modifiability,Inherit,InheritsFrom,3073,"char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetArgs() const; virtual TObject*GetCalledObject() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetFunctionName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSelfObjectPos() const; virtual const char*GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsCallSelf() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSeparator() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsStandardList() const; virtual Bool_tIsToggle() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:7742,Modifiability,Inherit,Inheritance,7742,"ed; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TClassMenuItem::EClassMenuItemTypekPopupSeparator; static TClassMenuItem::EClassMenuItemTypekPopupStandardList; static TClassMenuItem::EClassMenuItemTypekPopupUserFunction; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfArgsarguments type list *** NOT CHECKED ***; TObject*fCalledObjectobject to be called; TStringfFunctionNamename of the function or method to be called; TClass*fParentparent class; Bool_tfSelfflag to indicate that object to be called is the selected one; Int_tfSelfObjectPosrang in argument list corresponding to the object being clicked on; TList*fSubMenulist of submenu items; TStringfTitletitle if not standard; Bool_tfToggleflag toggle method; TClassMenuItem::EClassMenuItemTypefTypetype flag (EClassMenuItemType). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassMenuItem(); Default TClassMenuItem ctor. TClassMenuItems are constructed in TClass; with a standard content but may be customized later; fType = 0 : external method/function; fType = 1 : separator; fType = 2 : standard methods list. TClassMenuItem(Int_t type, TClass* parent, const char* title = """", const char* functionname = """", TObject* obj = 0, const char* args = """", Int_t selfobjposition = -1, Bool_t self = kFALSE); TClassMenuItem ctor. TClassMenuItems are constructed in TClass; with a standard content but may be customized later; type = 0 : external method/function; type = 1 : separator; type = 2 : standard methods list; self indicates if the object to be called is the one selected; by the popup menu; selfobjposition, if non zero, indicates the position in the arguments; list of the argument corresponding to the selected (clicked) object.; This argument in the calling method should be a TObject*; Note: It is the responsabilit",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:7755,Modifiability,Inherit,Inherited,7755,"ed; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TClassMenuItem::EClassMenuItemTypekPopupSeparator; static TClassMenuItem::EClassMenuItemTypekPopupStandardList; static TClassMenuItem::EClassMenuItemTypekPopupUserFunction; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfArgsarguments type list *** NOT CHECKED ***; TObject*fCalledObjectobject to be called; TStringfFunctionNamename of the function or method to be called; TClass*fParentparent class; Bool_tfSelfflag to indicate that object to be called is the selected one; Int_tfSelfObjectPosrang in argument list corresponding to the object being clicked on; TList*fSubMenulist of submenu items; TStringfTitletitle if not standard; Bool_tfToggleflag toggle method; TClassMenuItem::EClassMenuItemTypefTypetype flag (EClassMenuItemType). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassMenuItem(); Default TClassMenuItem ctor. TClassMenuItems are constructed in TClass; with a standard content but may be customized later; fType = 0 : external method/function; fType = 1 : separator; fType = 2 : standard methods list. TClassMenuItem(Int_t type, TClass* parent, const char* title = """", const char* functionname = """", TObject* obj = 0, const char* args = """", Int_t selfobjposition = -1, Bool_t self = kFALSE); TClassMenuItem ctor. TClassMenuItems are constructed in TClass; with a standard content but may be customized later; type = 0 : external method/function; type = 1 : separator; type = 2 : standard methods list; self indicates if the object to be called is the one selected; by the popup menu; selfobjposition, if non zero, indicates the position in the arguments; list of the argument corresponding to the selected (clicked) object.; This argument in the calling method should be a TObject*; Note: It is the responsabilit",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:2897,Security,Hash,Hash,2897,"ute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetArgs() const; virtual TObject*GetCalledObject() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetFunctionName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSelfObjectPos() const; virtual const char*GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsCallSelf() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSeparator() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsStandardList() const; virtual Bool_tIsToggle() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObj",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:5580,Testability,Test,TestBit,5580,"bject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCall(TObject* obj, const char* method, const char* args = """", Int_t selfobjposition = 0); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSelf(Bool_t self); virtual voidSetTitle(const char* title); virtual voidSetToggle(Bool_t toggle = kTRUE); virtual voidSetType(Int_t type); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassMenuItem(); TClassMenuItem(Int_t type, TClass* parent, const char* title = """", const char* functionname = """", TObject* obj = 0, const char* args = """", Int_t selfobjposition = -1, Bool_t self = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:5619,Testability,Test,TestBits,5619,"bject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCall(TObject* obj, const char* method, const char* args = """", Int_t selfobjposition = 0); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSelf(Bool_t self); virtual voidSetTitle(const char* title); virtual voidSetToggle(Bool_t toggle = kTRUE); virtual voidSetType(Int_t type); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassMenuItem(); TClassMenuItem(Int_t type, TClass* parent, const char* title = """", const char* functionname = """", TObject* obj = 0, const char* args = """", Int_t selfobjposition = -1, Bool_t self = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassMenuItem.html:1193,Usability,Clear,Clear,1193," virtual~TClassMenuItem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t eve",MatchSource.WIKI,root/html602/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassMenuItem.html
https://root.cern/root/html602/TClassRef.html:1898,Integrability,rout,routines,1898,"const; TClass*operator->() const; TClassRef&operator=(const TClassRef& rhs); TClassRef&operator=(TClass* rhs); voidReset(); voidSetName(const char* new_name); TClassRef(); TClassRef(TClass* cl); TClassRef(const char* classname); TClassRef(const TClassRef&). private:. voidAssign(const TClassRef&); voidAssign(TClass*); TClass*InternalGetClass() const. Data Members; private:. stringfClassNameName of referenced class; TClass*const*fClassPtr! Ptr to the permanent TClass ptr/reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassRef(const TClassRef& ); Copy ctor, increases reference count to original TClass object. TClassRef(const char* classname); Create reference to specified class name, but don't set referenced; class object. TClassRef(TClass* cl); Add reference to specified class object. void Assign(const TClassRef& ); Assignment operator implementation, increases reference count to original class object.; This routines assumes that the copy actually need to be done. void Assign(TClass* ); Assignment operator, increases reference count to original class object.; This routines assumes that the copy actually need to be done. TClass * InternalGetClass() const; Return the current TClass object corresponding to fClassName. TClassRef(); {}. TClassRef & operator=(const TClassRef& rhs); Inline implementation of operator= to speed the no-op case. TClassRef & operator=(TClass* rhs); Inline implementation of operator= to speed the no-op case. ~TClassRef(); { }. void SetName(const char* new_name). const char * GetClassName(); { return fClassName.c_str(); }. TClass * GetClass() const; { return (fClassPtr && *fClassPtr) ? *fClassPtr : InternalGetClass(); }. void Reset(); { fClassPtr = 0; }. TClass* operator->() const; { return (fClassPtr && *fClassPtr) ? *fClassPtr : InternalGetClass(); }.  Author: Philippe Canal 15/03/2005  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id$  Last generate",MatchSource.WIKI,root/html602/TClassRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassRef.html
https://root.cern/root/html602/TClassRef.html:2057,Integrability,rout,routines,2057,"TClassRef(); TClassRef(TClass* cl); TClassRef(const char* classname); TClassRef(const TClassRef&). private:. voidAssign(const TClassRef&); voidAssign(TClass*); TClass*InternalGetClass() const. Data Members; private:. stringfClassNameName of referenced class; TClass*const*fClassPtr! Ptr to the permanent TClass ptr/reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassRef(const TClassRef& ); Copy ctor, increases reference count to original TClass object. TClassRef(const char* classname); Create reference to specified class name, but don't set referenced; class object. TClassRef(TClass* cl); Add reference to specified class object. void Assign(const TClassRef& ); Assignment operator implementation, increases reference count to original class object.; This routines assumes that the copy actually need to be done. void Assign(TClass* ); Assignment operator, increases reference count to original class object.; This routines assumes that the copy actually need to be done. TClass * InternalGetClass() const; Return the current TClass object corresponding to fClassName. TClassRef(); {}. TClassRef & operator=(const TClassRef& rhs); Inline implementation of operator= to speed the no-op case. TClassRef & operator=(TClass* rhs); Inline implementation of operator= to speed the no-op case. ~TClassRef(); { }. void SetName(const char* new_name). const char * GetClassName(); { return fClassName.c_str(); }. TClass * GetClass() const; { return (fClassPtr && *fClassPtr) ? *fClassPtr : InternalGetClass(); }. void Reset(); { fClassPtr = 0; }. TClass* operator->() const; { return (fClassPtr && *fClassPtr) ? *fClassPtr : InternalGetClass(); }.  Author: Philippe Canal 15/03/2005  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail ",MatchSource.WIKI,root/html602/TClassRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassRef.html
https://root.cern/root/html602/TClassRef.html:1421,Modifiability,Inherit,Inheritance,1421,"ation usually happens; when a library containing the described class is loaded after a; file containing an instance of this class has been opened. The references kept track of using an intrusive double linked list.; The intrusive list is maintained by TClass::AddRef and; TClass::RemoveRef. The 'start' of the list is held in; TClass::fRefStart. Function Members (Methods); public:. ~TClassRef(); TClass*GetClass() const; const char*GetClassName(); TClass*operator TClass *() const; TClass*operator->() const; TClassRef&operator=(const TClassRef& rhs); TClassRef&operator=(TClass* rhs); voidReset(); voidSetName(const char* new_name); TClassRef(); TClassRef(TClass* cl); TClassRef(const char* classname); TClassRef(const TClassRef&). private:. voidAssign(const TClassRef&); voidAssign(TClass*); TClass*InternalGetClass() const. Data Members; private:. stringfClassNameName of referenced class; TClass*const*fClassPtr! Ptr to the permanent TClass ptr/reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassRef(const TClassRef& ); Copy ctor, increases reference count to original TClass object. TClassRef(const char* classname); Create reference to specified class name, but don't set referenced; class object. TClassRef(TClass* cl); Add reference to specified class object. void Assign(const TClassRef& ); Assignment operator implementation, increases reference count to original class object.; This routines assumes that the copy actually need to be done. void Assign(TClass* ); Assignment operator, increases reference count to original class object.; This routines assumes that the copy actually need to be done. TClass * InternalGetClass() const; Return the current TClass object corresponding to fClassName. TClassRef(); {}. TClassRef & operator=(const TClassRef& rhs); Inline implementation of operator= to speed the no-op case. TClassRef & operator=(TClass* rhs); Inline implementation of operator= to speed the no-op case. ~TClassRef(); { }.",MatchSource.WIKI,root/html602/TClassRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassRef.html
https://root.cern/root/html602/TClassRef.html:1434,Modifiability,Inherit,Inherited,1434,"ation usually happens; when a library containing the described class is loaded after a; file containing an instance of this class has been opened. The references kept track of using an intrusive double linked list.; The intrusive list is maintained by TClass::AddRef and; TClass::RemoveRef. The 'start' of the list is held in; TClass::fRefStart. Function Members (Methods); public:. ~TClassRef(); TClass*GetClass() const; const char*GetClassName(); TClass*operator TClass *() const; TClass*operator->() const; TClassRef&operator=(const TClassRef& rhs); TClassRef&operator=(TClass* rhs); voidReset(); voidSetName(const char* new_name); TClassRef(); TClassRef(TClass* cl); TClassRef(const char* classname); TClassRef(const TClassRef&). private:. voidAssign(const TClassRef&); voidAssign(TClass*); TClass*InternalGetClass() const. Data Members; private:. stringfClassNameName of referenced class; TClass*const*fClassPtr! Ptr to the permanent TClass ptr/reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassRef(const TClassRef& ); Copy ctor, increases reference count to original TClass object. TClassRef(const char* classname); Create reference to specified class name, but don't set referenced; class object. TClassRef(TClass* cl); Add reference to specified class object. void Assign(const TClassRef& ); Assignment operator implementation, increases reference count to original class object.; This routines assumes that the copy actually need to be done. void Assign(TClass* ); Assignment operator, increases reference count to original class object.; This routines assumes that the copy actually need to be done. TClass * InternalGetClass() const; Return the current TClass object corresponding to fClassName. TClassRef(); {}. TClassRef & operator=(const TClassRef& rhs); Inline implementation of operator= to speed the no-op case. TClassRef & operator=(TClass* rhs); Inline implementation of operator= to speed the no-op case. ~TClassRef(); { }.",MatchSource.WIKI,root/html602/TClassRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassRef.html
https://root.cern/root/html602/TClassRef.html:518,Performance,load,loaded,518,". TClassRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TClassRef. class TClassRef. TClassRef is used to implement a permanent reference to a TClass; object. In particular this reference will change if and when the; TClass object is regenerated. This regeneration usually happens; when a library containing the described class is loaded after a; file containing an instance of this class has been opened. The references kept track of using an intrusive double linked list.; The intrusive list is maintained by TClass::AddRef and; TClass::RemoveRef. The 'start' of the list is held in; TClass::fRefStart. Function Members (Methods); public:. ~TClassRef(); TClass*GetClass() const; const char*GetClassName(); TClass*operator TClass *() const; TClass*operator->() const; TClassRef&operator=(const TClassRef& rhs); TClassRef&operator=(TClass* rhs); voidReset(); voidSetName(const char* new_name); TClassRef(); TClassRef(TClass* cl); TClassRef(const char* classname); TClassRef(const TClassRef&). private:. voidAssign(const TClassRef&); voidAssign(TClass*); TClass*InternalGetClass() const. Data Members; private:. stringfClassNameName of referenced class; TClass*const*fClassPtr! Ptr to the permanent TClass ptr/reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassRef(const TClassRef& ); Copy ctor, increases reference count to original TClass object. TClassRef(const char* classname); Create reference to specified class name, but don't set referenced; class object. TClassRef(TClass* cl); Add reference to specified class object. void Assign(const TClassRef& ); Assignment operator implementation, increases reference count to original class object.; This routines assumes that the copy actually need to be done. void Assign(TClass* ); Assignment operator, in",MatchSource.WIKI,root/html602/TClassRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassRef.html
https://root.cern/root/html602/TClassStreamer.html:1849,Integrability,rout,routine,1849," address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass); TClassStreamer(ClassStreamerFunc_t pointer). protected:. TClassStreamer&operator=(const TClassStreamer& rhs); TClassStreamer(); TClassStreamer(const TClassStreamer& rhs). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(const TClassStreamer& rhs); {}. TClassStreamer & operator=(const TClassStreamer& rhs); { fOnFileClass = rhs.fOnFileClass; fStreamer = rhs.fStreamer; return *this; }. TClassStreamer(ClassStreamerFunc_t pointer); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member.  Author: Victor Perev and Philippe Canal 08/05/02  Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassStreamer.html
https://root.cern/root/html602/TClassStreamer.html:997,Modifiability,Inherit,Inheritance,997,"k Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TClassStreamer. class TClassStreamer. TClassStreamer is used to stream an object of a specific class. The address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass); TClassStreamer(ClassStreamerFunc_t pointer). protected:. TClassStreamer&operator=(const TClassStreamer& rhs); TClassStreamer(); TClassStreamer(const TClassStreamer& rhs). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(const TClassStreamer& rhs); {}. TClassStreamer & operator=(const TClassStreamer& rhs); { fOnFileClass = rhs.fOnFileClass; fStreamer = rhs.fStreamer; return *this; }. TClassStreamer(ClassStreamerFunc_t pointer); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member.  Author: Victor Perev and Phil",MatchSource.WIKI,root/html602/TClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassStreamer.html
https://root.cern/root/html602/TClassStreamer.html:1010,Modifiability,Inherit,Inherited,1010,"k Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TClassStreamer. class TClassStreamer. TClassStreamer is used to stream an object of a specific class. The address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass); TClassStreamer(ClassStreamerFunc_t pointer). protected:. TClassStreamer&operator=(const TClassStreamer& rhs); TClassStreamer(); TClassStreamer(const TClassStreamer& rhs). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(const TClassStreamer& rhs); {}. TClassStreamer & operator=(const TClassStreamer& rhs); { fOnFileClass = rhs.fOnFileClass; fStreamer = rhs.fStreamer; return *this; }. TClassStreamer(ClassStreamerFunc_t pointer); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member.  Author: Victor Perev and Phil",MatchSource.WIKI,root/html602/TClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassStreamer.html
https://root.cern/root/html602/TClassStreamer.html:1884,Performance,optimiz,optimize,1884," address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass); TClassStreamer(ClassStreamerFunc_t pointer). protected:. TClassStreamer&operator=(const TClassStreamer& rhs); TClassStreamer(); TClassStreamer(const TClassStreamer& rhs). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(const TClassStreamer& rhs); {}. TClassStreamer & operator=(const TClassStreamer& rhs); { fOnFileClass = rhs.fOnFileClass; fStreamer = rhs.fStreamer; return *this; }. TClassStreamer(ClassStreamerFunc_t pointer); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member.  Author: Victor Perev and Philippe Canal 08/05/02  Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassStreamer.html
https://root.cern/root/html602/TClassTable.html:1721,Availability,Error,Error,1721,"dd(const char* cname, Version_t id, const type_info& info, DictFuncPtr_t dict, Int_t pragmabits); static voidAddAlternate(const char* normname, const char* alternate); virtual voidTObject::AppendPad(Option_t* option = """"); static char*At(UInt_t index); virtual voidTObject::Browse(TBrowser* b); static Bool_tCheck(const char* cname, string& normname); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static DictFuncPtr_tGetDictNorm(const char* cname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static Version_tGetID(const char* cname); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption(",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:1850,Availability,error,error,1850,"har* normname, const char* alternate); virtual voidTObject::AppendPad(Option_t* option = """"); static char*At(UInt_t index); virtual voidTObject::Browse(TBrowser* b); static Bool_tCheck(const char* cname, string& normname); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static DictFuncPtr_tGetDictNorm(const char* cname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static Version_tGetID(const char* cname); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static Int_tGetPragmaBits(const char* name); static TProtoClass*GetProto(const char* cname); static TProtoClass*GetProto",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:1934,Availability,error,error,1934,"on = """"); static char*At(UInt_t index); virtual voidTObject::Browse(TBrowser* b); static Bool_tCheck(const char* cname, string& normname); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static DictFuncPtr_tGetDictNorm(const char* cname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static Version_tGetID(const char* cname); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static Int_tGetPragmaBits(const char* name); static TProtoClass*GetProto(const char* cname); static TProtoClass*GetProtoNorm(const char* cname); virtual const char*TObject::GetTitle() const; virtual UInt_",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:3153,Modifiability,Inherit,InheritsFrom,3153,"bject*TObject::FindObject(const TObject* obj) const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static DictFuncPtr_tGetDictNorm(const char* cname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static Version_tGetID(const char* cname); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static Int_tGetPragmaBits(const char* name); static TProtoClass*GetProto(const char* cname); static TProtoClass*GetProtoNorm(const char* cname); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static voidInit(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static char*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:3219,Modifiability,Inherit,InheritsFrom,3219,"ncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static DictFuncPtr_tGetDictNorm(const char* cname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static Version_tGetID(const char* cname); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static Int_tGetPragmaBits(const char* name); static TProtoClass*GetProto(const char* cname); static TProtoClass*GetProtoNorm(const char* cname); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static voidInit(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static char*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TClassTable&",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:7268,Modifiability,Inherit,Inheritance,7268,"bject::EStatusBitsTObject::kHasUUID; static TClassTable::(anonymous)kHasVersion; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TClassTable::(anonymous)kNoInputOperator; static TClassTable::(anonymous)kNoStreamer; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. static ROOT::TClassAlt**fgAlternate; static UInt_tfgCursor; static TClassTable::IdMap_t*fgIdMap; static UInt_tfgSize; static Bool_tfgSorted; static ROOT::TClassRec**fgSortedTable; static ROOT::TClassRec**fgTable; static UInt_tfgTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTable(); TClassTable is a singleton (i.e. only one can exist per application). ~TClassTable(); TClassTable singleton is deleted in Terminate(). void Print(Option_t* option = """") const; Print the class table. Before printing the table is sorted; alphabetically. Only classes specified in option are listed.; The default is to list all classes.; Standard wilcarding notation supported. char * At(UInt_t index); Returns class at index from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc.; Returns 0 if index points beyond last class name. int Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, DictFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function).; Note that the given cname *must* be already normal",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:7281,Modifiability,Inherit,Inherited,7281,"bject::EStatusBitsTObject::kHasUUID; static TClassTable::(anonymous)kHasVersion; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TClassTable::(anonymous)kNoInputOperator; static TClassTable::(anonymous)kNoStreamer; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. static ROOT::TClassAlt**fgAlternate; static UInt_tfgCursor; static TClassTable::IdMap_t*fgIdMap; static UInt_tfgSize; static Bool_tfgSorted; static ROOT::TClassRec**fgSortedTable; static ROOT::TClassRec**fgTable; static UInt_tfgTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTable(); TClassTable is a singleton (i.e. only one can exist per application). ~TClassTable(); TClassTable singleton is deleted in Terminate(). void Print(Option_t* option = """") const; Print the class table. Before printing the table is sorted; alphabetically. Only classes specified in option are listed.; The default is to list all classes.; Standard wilcarding notation supported. char * At(UInt_t index); Returns class at index from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc.; Returns 0 if index points beyond last class name. int Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, DictFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function).; Note that the given cname *must* be already normal",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:376,Security,hash,hash,376,". TClassTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TClassTable. class TClassTable: public TObject. This class registers for all classes their name, id and dictionary; function in a hash table. Classes are automatically added by the; ctor of a special init class when a global of this init class is; initialized when the program starts (see the ClassImp macro). Function Members (Methods); public:. virtual~TClassTable(); voidTObject::AbstractMethod(const char* method) const; static voidAdd(TProtoClass* protoClass); static voidAdd(const char* cname, Version_t id, const type_info& info, DictFuncPtr_t dict, Int_t pragmabits); static voidAddAlternate(const char* normname, const char* alternate); virtual voidTObject::AppendPad(Option_t* option = """"); static char*At(UInt_t index); virtual voidTObject::Browse(TBrowser* b); static Bool_tCheck(const char* cname, string& normname); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:3043,Security,Hash,Hash,3043,"t char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static DictFuncPtr_tGetDictNorm(const char* cname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static Version_tGetID(const char* cname); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static Int_tGetPragmaBits(const char* name); static TProtoClass*GetProto(const char* cname); static TProtoClass*GetProtoNorm(const char* cname); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static voidInit(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static char*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:8794,Security,hash,hash,8794,"UInt_t index); Returns class at index from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc.; Returns 0 if index points beyond last class name. int Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, DictFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function).; Note that the given cname *must* be already normalized. void Add(TProtoClass* protoClass); Add a class to the class table (this is a static function). void AddAlternate(const char* normname, const char* alternate). Bool_t Check(const char* cname, string& normname). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncP",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:9053,Security,hash,hash,9053,"Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, DictFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function).; Note that the given cname *must* be already normalized. void Add(TProtoClass* protoClass); Add a class to the class table (this is a static function). void AddAlternate(const char* normname, const char* alternate). Bool_t Check(const char* cname, string& normname). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncPtr_t GetDictNorm(const char* cname); Given the normalized class name returns the Dictionary() function of a class; (uses hash of name). TProtoClass * GetProto(const char* cname); Given the class name returns the TClassProto object for the class.; (uses has",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:9576,Security,hash,hash,9576,"st char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncPtr_t GetDictNorm(const char* cname); Given the normalized class name returns the Dictionary() function of a class; (uses hash of name). TProtoClass * GetProto(const char* cname); Given the class name returns the TClassProto object for the class.; (uses hash of name). TProtoClass * GetProtoNorm(const char* cname); Given the class normalized name returns the TClassProto object for the class.; (uses hash of name). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Te",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:9709,Security,hash,hash,9709,"objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncPtr_t GetDictNorm(const char* cname); Given the normalized class name returns the Dictionary() function of a class; (uses hash of name). TProtoClass * GetProto(const char* cname); Given the class name returns the TClassProto object for the class.; (uses hash of name). TProtoClass * GetProtoNorm(const char* cname); Given the class normalized name returns the TClassProto object for the class.; (uses hash of name). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable().  Author: Fons Rademakers 11/08/95  Copyri",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:9867,Security,hash,hash,9867," Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncPtr_t GetDictNorm(const char* cname); Given the normalized class name returns the Dictionary() function of a class; (uses hash of name). TProtoClass * GetProto(const char* cname); Given the class name returns the TClassProto object for the class.; (uses hash of name). TProtoClass * GetProtoNorm(const char* cname); Given the class normalized name returns the TClassProto object for the class.; (uses hash of name). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable().  Author: Fons Rademakers 11/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 2015-06-30 14:41; This page has been automat",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:9999,Security,hash,hash,9999,"TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncPtr_t GetDictNorm(const char* cname); Given the normalized class name returns the Dictionary() function of a class; (uses hash of name). TProtoClass * GetProto(const char* cname); Given the class name returns the TClassProto object for the class.; (uses hash of name). TProtoClass * GetProtoNorm(const char* cname); Given the class normalized name returns the TClassProto object for the class.; (uses hash of name). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable().  Author: Fons Rademakers 11/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:10146,Security,hash,hash,10146,"TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncPtr_t GetDictNorm(const char* cname); Given the normalized class name returns the Dictionary() function of a class; (uses hash of name). TProtoClass * GetProto(const char* cname); Given the class name returns the TClassProto object for the class.; (uses hash of name). TProtoClass * GetProtoNorm(const char* cname); Given the class normalized name returns the TClassProto object for the class.; (uses hash of name). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable().  Author: Fons Rademakers 11/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:5313,Testability,Test,TestBit,5313,"ar* method) const; static char*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TClassTable&operator=(const TClassTable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; static voidPrintTable(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static voidRemove(const char* cname); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassTable(const TClassTable&); static voidTerminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:5352,Testability,Test,TestBits,5352,"ar* method) const; static char*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TClassTable&operator=(const TClassTable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; static voidPrintTable(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static voidRemove(const char* cname); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassTable(const TClassTable&); static voidTerminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTable.html:1181,Usability,Clear,Clear,1181," virtual~TClassTable(); voidTObject::AbstractMethod(const char* method) const; static voidAdd(TProtoClass* protoClass); static voidAdd(const char* cname, Version_t id, const type_info& info, DictFuncPtr_t dict, Int_t pragmabits); static voidAddAlternate(const char* normname, const char* alternate); virtual voidTObject::AppendPad(Option_t* option = """"); static char*At(UInt_t index); virtual voidTObject::Browse(TBrowser* b); static Bool_tCheck(const char* cname, string& normname); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px",MatchSource.WIKI,root/html602/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTable.html
https://root.cern/root/html602/TClassTree.html:749,Availability,down,down,749,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GPAD;  TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:5441,Availability,Error,Error,5441,,MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:5570,Availability,error,error,5570,,MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:5654,Availability,error,error,5654,"e(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindClass(const char* classname); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClasses() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetSourceDir() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:13596,Deployability,configurat,configuration,13596,"d examples. Int_t FindClass(const char* classname); Find class number corresponding to classname in list of local classes. void FindClassesUsedBy(Int_t iclass); Select all classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of c",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:3321,Energy Efficiency,green,green,3321,"; It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree tc1(""tc1"",""TObject"");; tc1.SetShowLinks(""HMR"");. /*. */. Note that in case of embedded classes or pointers to classes,; the corresponding dashed lines or arrows respectively start; in the TPaveClass object at an X position reflecting the position; in the list of data members. - References by data members to other classes are show with a full red line; - Multiple inheritance is shown with a dashed blue line; - ""Has a"" relation is shown with a dotted cyan line; - References from code is shown by a full green line. Use TClassTree::SetSourceDir to specify the search path for source files.; By default the search path includes the ROOTSYS/src directory, the current; directory and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the fi",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:4439,Integrability,depend,dependencies,4439,"ry and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the file myClass.root to a colleague who can; run the following Root basic session; TFile f(""myClass.root""); //connect the file; tt.ls(); //to list all classes and titles; tt.Draw(""ATLFDisplay"") //show class ATLFDisplay with all its dependencies; At this point, one has still access to all the classes present; in the original session and select any combination of these classes; to be displayed. Function Members (Methods); public:. virtual~TClassTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:13867,Integrability,message,message,13867,"lect all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:13920,Integrability,message,message,13920," class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set link options in the Cla",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:297,Modifiability,inherit,inheritance,297,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GPAD;  TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:403,Modifiability,inherit,inheritance,403,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GPAD;  TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:437,Modifiability,inherit,inheritance,437,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GPAD;  TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:942,Modifiability,inherit,inheritance,942,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:1035,Modifiability,inherit,inheritance,1035,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:1131,Modifiability,inherit,inheritance,1131,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:1218,Modifiability,inherit,inheritance,1218,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:1341,Modifiability,inherit,inheritance,1341,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:1479,Modifiability,inherit,inheritance,1479,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:1552,Modifiability,inherit,inheritance,1552,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:1683,Modifiability,inherit,inheritance,1683,"rted from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:1818,Modifiability,inherit,inheritance,1818,"ted by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree t",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:1984,Modifiability,inherit,inheritance,1984," referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree tc1(""tc1"",""TObject"");; tc1.SetShowLinks(""HMR"");. /*. */. Note that in case of embedded classes or pointers to classes,; the corresponding dashed lines or arrows respectively",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:3180,Modifiability,inherit,inheritance,3180,"; It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree tc1(""tc1"",""TObject"");; tc1.SetShowLinks(""HMR"");. /*. */. Note that in case of embedded classes or pointers to classes,; the corresponding dashed lines or arrows respectively start; in the TPaveClass object at an X position reflecting the position; in the list of data members. - References by data members to other classes are show with a full red line; - Multiple inheritance is shown with a dashed blue line; - ""Has a"" relation is shown with a dotted cyan line; - References from code is shown by a full green line. Use TClassTree::SetSourceDir to specify the search path for source files.; By default the search path includes the ROOTSYS/src directory, the current; directory and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the fi",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:6697,Modifiability,Inherit,InheritsFrom,6697,"_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindClass(const char* classname); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClasses() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetSourceDir() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* ",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:6763,Modifiability,Inherit,InheritsFrom,6763,"ar* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindClass(const char* classname); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClasses() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetSourceDir() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TClassTree&operator=(const TClassTree&); virtual voidPaint(Op",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:11976,Modifiability,inherit,inheritance,11976,"t::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfClassesList of classes to be drawn; TString**fCnames![fNclasses] class names; Int_t*fCparent!parent number of classes (temporary); TClass**fCpointer![fNclasses] pointers to the TClass objects; Int_t*fCstatus[fNclasses] classes status; TString**fCtitles![fNclasses] class titles; char**fDerived![fNclasses] table to indicate if i derives from j; Float_tfLabelDxwidth along x of TPaveLabels in per cent of pad; TList**fLinks![fNclasses] for each class, the list of referenced(ing) classes; TStringTNamed::fNameobject identifier; Int_tfNclassescurrent number of classes; Int_t*fNdata[fNclasses] Number of data members per class; TString**fOptions![fNclasses] List of options per class; Int_t*fParents[fNclasses] parent number of classes (permanent); Int_tfShowCodif 1 show classes referenced by implementation; Int_tfShowHasif 1 show ""has a"" relationship; Int_tfShowMulif 1 show multiple inheritance; Int_tfShowRefif 1 show classes relationship other than inheritance; TStringfSourceDirConcatenated source directories; TStringTNamed::fTitleobject title; Float_tfYoffsetoffset at top of picture in per cent of pad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTree(); TClassTree default constructor. TClassTree(const char* name, const char* classes = """"); TClassTree constructor. ~TClassTree(); TClassTree default destructor. void Draw(const char* classes = """"); Draw the inheritance tree and relations for the list of classes; see this class header for the syntax and examples. Int_t FindClass(const ch",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:12044,Modifiability,inherit,inheritance,12044,"t::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfClassesList of classes to be drawn; TString**fCnames![fNclasses] class names; Int_t*fCparent!parent number of classes (temporary); TClass**fCpointer![fNclasses] pointers to the TClass objects; Int_t*fCstatus[fNclasses] classes status; TString**fCtitles![fNclasses] class titles; char**fDerived![fNclasses] table to indicate if i derives from j; Float_tfLabelDxwidth along x of TPaveLabels in per cent of pad; TList**fLinks![fNclasses] for each class, the list of referenced(ing) classes; TStringTNamed::fNameobject identifier; Int_tfNclassescurrent number of classes; Int_t*fNdata[fNclasses] Number of data members per class; TString**fOptions![fNclasses] List of options per class; Int_t*fParents[fNclasses] parent number of classes (permanent); Int_tfShowCodif 1 show classes referenced by implementation; Int_tfShowHasif 1 show ""has a"" relationship; Int_tfShowMulif 1 show multiple inheritance; Int_tfShowRefif 1 show classes relationship other than inheritance; TStringfSourceDirConcatenated source directories; TStringTNamed::fTitleobject title; Float_tfYoffsetoffset at top of picture in per cent of pad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTree(); TClassTree default constructor. TClassTree(const char* name, const char* classes = """"); TClassTree constructor. ~TClassTree(); TClassTree default destructor. void Draw(const char* classes = """"); Draw the inheritance tree and relations for the list of classes; see this class header for the syntax and examples. Int_t FindClass(const ch",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:12216,Modifiability,Inherit,Inheritance,12216,"fNclasses] pointers to the TClass objects; Int_t*fCstatus[fNclasses] classes status; TString**fCtitles![fNclasses] class titles; char**fDerived![fNclasses] table to indicate if i derives from j; Float_tfLabelDxwidth along x of TPaveLabels in per cent of pad; TList**fLinks![fNclasses] for each class, the list of referenced(ing) classes; TStringTNamed::fNameobject identifier; Int_tfNclassescurrent number of classes; Int_t*fNdata[fNclasses] Number of data members per class; TString**fOptions![fNclasses] List of options per class; Int_t*fParents[fNclasses] parent number of classes (permanent); Int_tfShowCodif 1 show classes referenced by implementation; Int_tfShowHasif 1 show ""has a"" relationship; Int_tfShowMulif 1 show multiple inheritance; Int_tfShowRefif 1 show classes relationship other than inheritance; TStringfSourceDirConcatenated source directories; TStringTNamed::fTitleobject title; Float_tfYoffsetoffset at top of picture in per cent of pad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTree(); TClassTree default constructor. TClassTree(const char* name, const char* classes = """"); TClassTree constructor. ~TClassTree(); TClassTree default destructor. void Draw(const char* classes = """"); Draw the inheritance tree and relations for the list of classes; see this class header for the syntax and examples. Int_t FindClass(const char* classname); Find class number corresponding to classname in list of local classes. void FindClassesUsedBy(Int_t iclass); Select all classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:12229,Modifiability,Inherit,Inherited,12229,"fNclasses] pointers to the TClass objects; Int_t*fCstatus[fNclasses] classes status; TString**fCtitles![fNclasses] class titles; char**fDerived![fNclasses] table to indicate if i derives from j; Float_tfLabelDxwidth along x of TPaveLabels in per cent of pad; TList**fLinks![fNclasses] for each class, the list of referenced(ing) classes; TStringTNamed::fNameobject identifier; Int_tfNclassescurrent number of classes; Int_t*fNdata[fNclasses] Number of data members per class; TString**fOptions![fNclasses] List of options per class; Int_t*fParents[fNclasses] parent number of classes (permanent); Int_tfShowCodif 1 show classes referenced by implementation; Int_tfShowHasif 1 show ""has a"" relationship; Int_tfShowMulif 1 show multiple inheritance; Int_tfShowRefif 1 show classes relationship other than inheritance; TStringfSourceDirConcatenated source directories; TStringTNamed::fTitleobject title; Float_tfYoffsetoffset at top of picture in per cent of pad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTree(); TClassTree default constructor. TClassTree(const char* name, const char* classes = """"); TClassTree constructor. ~TClassTree(); TClassTree default destructor. void Draw(const char* classes = """"); Draw the inheritance tree and relations for the list of classes; see this class header for the syntax and examples. Int_t FindClass(const char* classname); Find class number corresponding to classname in list of local classes. void FindClassesUsedBy(Int_t iclass); Select all classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:12511,Modifiability,inherit,inheritance,12511,", the list of referenced(ing) classes; TStringTNamed::fNameobject identifier; Int_tfNclassescurrent number of classes; Int_t*fNdata[fNclasses] Number of data members per class; TString**fOptions![fNclasses] List of options per class; Int_t*fParents[fNclasses] parent number of classes (permanent); Int_tfShowCodif 1 show classes referenced by implementation; Int_tfShowHasif 1 show ""has a"" relationship; Int_tfShowMulif 1 show multiple inheritance; Int_tfShowRefif 1 show classes relationship other than inheritance; TStringfSourceDirConcatenated source directories; TStringTNamed::fTitleobject title; Float_tfYoffsetoffset at top of picture in per cent of pad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTree(); TClassTree default constructor. TClassTree(const char* name, const char* classes = """"); TClassTree constructor. ~TClassTree(); TClassTree default destructor. void Draw(const char* classes = """"); Draw the inheritance tree and relations for the list of classes; see this class header for the syntax and examples. Int_t FindClass(const char* classname); Find class number corresponding to classname in list of local classes. void FindClassesUsedBy(Int_t iclass); Select all classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* fil",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:13596,Modifiability,config,configuration,13596,"d examples. Int_t FindClass(const char* classname); Find class number corresponding to classname in list of local classes. void FindClassesUsedBy(Int_t iclass); Select all classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of c",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:14503,Modifiability,inherit,inheriting,14503,"id PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set link options in the ClassTree object. ""C"" show References from code; ""H"" show Has a relations; ""M"" show Multiple Inheritance; ""R"" show References from data members. void ShowMul(); Draw the Multiple inheritance relationships. void ShowRef(); Draw the References relationships (other than inheritance or composition). void Streamer(TBuffer& ); Stream an object of class TClassTree.; the status of the object is saved and can be replayed in a subsequent session. TClassTree(). const char * GetClasses() const; {return fClasses.Data();}. const char * GetS",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:14997,Modifiability,Inherit,Inheritance,14997,"ault a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set link options in the ClassTree object. ""C"" show References from code; ""H"" show Has a relations; ""M"" show Multiple Inheritance; ""R"" show References from data members. void ShowMul(); Draw the Multiple inheritance relationships. void ShowRef(); Draw the References relationships (other than inheritance or composition). void Streamer(TBuffer& ); Stream an object of class TClassTree.; the status of the object is saved and can be replayed in a subsequent session. TClassTree(). const char * GetClasses() const; {return fClasses.Data();}. const char * GetSourceDir() const; {return fSourceDir.Data();}. void SetSourceDir(const char* dir = ""src""); {fSourceDir = dir;}.  Author: Rene Brun 01/12/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gpad:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:15083,Modifiability,inherit,inheritance,15083,"ault a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set link options in the ClassTree object. ""C"" show References from code; ""H"" show Has a relations; ""M"" show Multiple Inheritance; ""R"" show References from data members. void ShowMul(); Draw the Multiple inheritance relationships. void ShowRef(); Draw the References relationships (other than inheritance or composition). void Streamer(TBuffer& ); Stream an object of class TClassTree.; the status of the object is saved and can be replayed in a subsequent session. TClassTree(). const char * GetClasses() const; {return fClasses.Data();}. const char * GetSourceDir() const; {return fSourceDir.Data();}. void SetSourceDir(const char* dir = ""src""); {fSourceDir = dir;}.  Author: Rene Brun 01/12/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gpad:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:15172,Modifiability,inherit,inheritance,15172,"ault a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set link options in the ClassTree object. ""C"" show References from code; ""H"" show Has a relations; ""M"" show Multiple Inheritance; ""R"" show References from data members. void ShowMul(); Draw the Multiple inheritance relationships. void ShowRef(); Draw the References relationships (other than inheritance or composition). void Streamer(TBuffer& ); Stream an object of class TClassTree.; the status of the object is saved and can be replayed in a subsequent session. TClassTree(). const char * GetClasses() const; {return fClasses.Data();}. const char * GetSourceDir() const; {return fSourceDir.Data();}. void SetSourceDir(const char* dir = ""src""); {fSourceDir = dir;}.  Author: Rene Brun 01/12/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gpad:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:4482,Security,access,access,4482,"ry and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the file myClass.root to a colleague who can; run the following Root basic session; TFile f(""myClass.root""); //connect the file; tt.ls(); //to list all classes and titles; tt.Draw(""ATLFDisplay"") //show class ATLFDisplay with all its dependencies; At this point, one has still access to all the classes present; in the original session and select any combination of these classes; to be displayed. Function Members (Methods); public:. virtual~TClassTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:6587,Security,Hash,Hash,6587," voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindClass(const char* classname); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClasses() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetSourceDir() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:13821,Security,access,access,13821,"l classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References r",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:9371,Testability,Test,TestBit,9371,"oidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetClasses(const char* classes, Option_t* option = ""ID""); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLabelDx(Float_t labeldx = 0.14999999999999999); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSourceDir(const char* dir = ""src""); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetYoffset(Float_t offset = 0); virtual voidShowClassesUsedBy(const char* classes); virtual voidShowClassesUsing(const char* classes); virtual voidShowLinks(Option_t* option = ""HMR""); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassTree(); TClassTree(const TClassTree&); TClassTree(const char* name, const char* classes = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidFindClassesUsedBy(Int_t iclass); virtual voidFindClassesUsing(Int_t iclass); virtual voidFindClassPosition(const char* classname, Float_t& x, Float_t& y); virtual voidInit(); voidTObject::MakeZombie(); TObjString*Mark(const char* classn",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:9410,Testability,Test,TestBits,9410,"oidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetClasses(const char* classes, Option_t* option = ""ID""); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLabelDx(Float_t labeldx = 0.14999999999999999); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSourceDir(const char* dir = ""src""); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetYoffset(Float_t offset = 0); virtual voidShowClassesUsedBy(const char* classes); virtual voidShowClassesUsing(const char* classes); virtual voidShowLinks(Option_t* option = ""HMR""); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClassTree(); TClassTree(const TClassTree&); TClassTree(const char* name, const char* classes = """"); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidFindClassesUsedBy(Int_t iclass); virtual voidFindClassesUsing(Int_t iclass); virtual voidFindClassPosition(const char* classname, Float_t& x, Float_t& y); virtual voidInit(); voidTObject::MakeZombie(); TObjString*Mark(const char* classn",MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClassTree.html:4904,Usability,Clear,Clear,4904,,MatchSource.WIKI,root/html602/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClassTree.html
https://root.cern/root/html602/TClonesArray.html:2142,Availability,error,error,2142,",y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClones",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2304,Availability,recover,recovered,2304,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2515,Availability,error,errors,2515," *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more me",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:6552,Availability,Error,Error,6552,"_tCanBypassStreamer() const; Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); TObject*ConstructedAt(Int_t idx); TObject*ConstructedAt(Int_t idx, Option_t* clear_options); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidExpandCreate(Int_t n); virtual voidExpandCreateFast(Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; vir",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:6681,Availability,error,error,6681,"onst; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); TObject*ConstructedAt(Int_t idx); TObject*ConstructedAt(Int_t idx, Option_t* clear_options); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidExpandCreate(Int_t n); virtual voidExpandCreateFast(Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t ",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:6765,Availability,error,error,6765,"onst char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); TObject*ConstructedAt(Int_t idx); TObject*ConstructedAt(Int_t idx, Option_t* clear_options); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidExpandCreate(Int_t n); virtual voidExpandCreateFast(Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObj",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:24023,Availability,error,error,24023,"Int_t upto = kMaxInt); If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort array. void Streamer(TBuffer& ); Write all objects in array to the I/O buffer. ATTENTION: empty slots; are also stored (using one byte per slot). If you don't want this; use a TOrdCollection or TList. TObject *& operator[](Int_t idx); Return pointer to reserved area in which a new object of clones; class can be constructed. This operator should not be used for; lefthand side assignments, like a[2] = xxx. Only like,; new (a[2]) myClass, or xxx = a[2]. Of course right hand side usage; is only legal after the object has been constructed via the; new operator or via the New() method. To remove elements from; the clones array use Remove() or RemoveAt(). TObject * operator[](Int_t idx) const; Return the object at position idx. Returns 0 if idx is out of bounds. TObject * New(Int_t idx); Create an object of type fClass with the default ctor at the specified; index. Returns 0 in case of error. void AbsorbObjects(TClonesArray* tc); Directly move the object pointers from tc without cloning (copying).; This TClonesArray takes over ownership of all of tc's object; pointers. The tc array is left empty upon return. void AbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); Directly move the range of object pointers from tc without cloning; (copying).; This TClonesArray takes over ownership of all of tc's object pointers; from idx1 to idx2. The tc array is re-arranged by return. void MultiSort(Int_t nTCs, TClonesArray** tcs, Int_t upto = kMaxInt); Sort multiple TClonesArrays simultaneously with this array.; If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort array. TObject * AddrAt(Int_t idx). TClass * GetClass() const; { return fClass; }. void AddFirst(TObject* ); { MayNotUse(""AddFirst""); }. void AddLast(TObject* ); { MayNotUse(""AddLast""); }. void AddAt(TObject* , Int_t ); { MayNotUse(""AddAt""); }. void AddAtAndExpand(TObje",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:385,Energy Efficiency,allocate,allocated,385,". TClonesArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save abo",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:548,Energy Efficiency,reduce,reduce,548,". TClonesArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save abo",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:898,Energy Efficiency,reduce,reduces,898,". TClonesArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save abo",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:1196,Energy Efficiency,reduce,reduce,1196,"clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovere",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2108,Energy Efficiency,allocate,allocated,2108,",y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClones",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2281,Energy Efficiency,allocate,allocated,2281,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2331,Energy Efficiency,efficient,efficiently,2331,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2424,Energy Efficiency,allocate,allocate,2424,"or once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do n",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2630,Energy Efficiency,reduce,reduce,2630," *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more me",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3144,Energy Efficiency,allocate,allocated,3144,"mory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3860,Energy Efficiency,allocate,allocate,3860,"ou to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndEx",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:4231,Energy Efficiency,reduce,reduce,4231,"onesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(const TObject*, TObject*); virtual voidAddFirst(TObject*); virtual voidAddLast(TObject*); TObject*AddrAt(Int_t idx); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t idx",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:18675,Energy Efficiency,allocate,allocated,18675,"ptimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the o",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:18722,Energy Efficiency,allocate,allocated,18722,"ptimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the o",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:19190,Energy Efficiency,allocate,allocate,19190,"quence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Cle",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:19443,Energy Efficiency,allocate,allocated,19443,"imized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:19490,Energy Efficiency,allocate,allocated,19490,"imized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:19886,Energy Efficiency,allocate,allocate,19886," the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. vo",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20080,Energy Efficiency,allocate,allocate,20080," not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shr",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20378,Energy Efficiency,allocate,allocated,20378," index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or sh",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20680,Energy Efficiency,allocate,allocate,20680,"object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""ne",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20758,Energy Efficiency,allocate,allocate,20758,"ass constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:21096,Energy Efficiency,allocate,allocated,21096,"'t; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create ",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:21512,Energy Efficiency,allocate,allocated,21512,"with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the ",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20047,Integrability,rout,routine,20047," not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shr",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20654,Integrability,rout,routine,20654,"object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""ne",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:21128,Integrability,rout,routine,21128,"nction; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:21550,Integrability,rout,routine,21550,"; Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called ",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:8333,Modifiability,Inherit,InheritsFrom,8333,"l Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObjArray::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tTObjArray::IndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; virtual Bool_tTObjArray::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*TObjArray::Last() const; Int_tTSeqCollection::LastIndex() const; Int_tTObjArray::LowerBound() const; virtual voidTCollection::ls(Option_t* option = """") const; virtual TIterator*TObjArray::MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*TCollection::MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; Long64_tTSeqCollecti",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:8399,Modifiability,Inherit,InheritsFrom,8399,"etDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObjArray::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tTObjArray::IndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; virtual Bool_tTObjArray::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*TObjArray::Last() const; Int_tTSeqCollection::LastIndex() const; Int_tTObjArray::LowerBound() const; virtual voidTCollection::ls(Option_t* option = """") const; virtual TIterator*TObjArray::MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*TCollection::MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; Long64_tTSeqCollection::Merge(TCollection* list); voidMultiSort(Int_t nTCs, TClonesArr",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:15351,Modifiability,Inherit,Inheritance,15351,"sTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TClonesArray::(anonymous)kNoSplit; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TClass*fClass!Pointer to the class of the elements; TObject**TObjArray::fCont!Array contents; TObjArray*fKeep!Saved copies of pointers to objects; Int_tTObjArray::fLastLast element in array containing an object; Int_tTObjArray::fLowerBoundLower bound of the array; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClonesArray(); Default Constructor. TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of classname. The class must inherit from; TObject. If the class defines its own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; ",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:15364,Modifiability,Inherit,Inherited,15364,"sTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TClonesArray::(anonymous)kNoSplit; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TClass*fClass!Pointer to the class of the elements; TObject**TObjArray::fCont!Array contents; TObjArray*fKeep!Saved copies of pointers to objects; Int_tTObjArray::fLastLast element in array containing an object; Int_tTObjArray::fLowerBoundLower bound of the array; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClonesArray(); Default Constructor. TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of classname. The class must inherit from; TObject. If the class defines its own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; ",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:15610,Modifiability,inherit,inherit,15610,"atusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TClass*fClass!Pointer to the class of the elements; TObject**TObjArray::fCont!Array contents; TObjArray*fKeep!Saved copies of pointers to objects; Int_tTObjArray::fLastLast element in array containing an object; Int_tTObjArray::fLowerBoundLower bound of the array; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClonesArray(); Default Constructor. TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of classname. The class must inherit from; TObject. If the class defines its own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate num",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:16291,Modifiability,inherit,inherit,16291,"lection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClonesArray(); Default Constructor. TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of classname. The class must inherit from; TObject. If the class defines its own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TC",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20711,Modifiability,inherit,inheriting,20711,"ass constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:22130,Modifiability,inherit,inherit,22130,"ne is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called in the TClonesArray is already; initialized with a class. void SetClass(const char* classname, Int_t size = 1000); see TClonesArray::SetClass(const TClass*). void SetOwner(Bool_t enable = kTRUE); A TClonesArray is always the owner of the object it contains.; However the collection its inherits from (TObjArray) does not.; Hence this member function needs to be a nop for TClonesArray. void Sort(Int_t upto = kMaxInt); If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort ar",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:22905,Modifiability,inherit,inherits,22905,"bject from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called in the TClonesArray is already; initialized with a class. void SetClass(const char* classname, Int_t size = 1000); see TClonesArray::SetClass(const TClass*). void SetOwner(Bool_t enable = kTRUE); A TClonesArray is always the owner of the object it contains.; However the collection its inherits from (TObjArray) does not.; Hence this member function needs to be a nop for TClonesArray. void Sort(Int_t upto = kMaxInt); If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort array. void Streamer(TBuffer& ); Write all objects in array to the I/O buffer. ATTENTION: empty slots; are also stored (using one byte per slot). If you don't want this; use a TOrdCollection or TList. TObject *& operator[](Int_t idx); Return pointer to reserved area in which a new object of clones; class can be constructed. This operator should not be used for; lefthand side assignments, like a[2] = xxx. Only like,; new (a[2]) myClass, or xxx = a[2]. Of course right hand side usage; is only legal after the object has been constructed via the; new operator or via the New() method. To remove elements from; the clones array use Remove() or RemoveAt(). TObject * operator[](Int_t idx) const; Return the object at position idx. Returns 0 if idx is out of bounds. TObject * N",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2966,Performance,perform,performance,2966,"; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid caus",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:17188,Performance,perform,performance,17188,"Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the rig",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:17403,Performance,optimiz,optimized,17403," make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be c",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:17698,Performance,optimiz,optimized,17698,"tically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; all",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:17805,Performance,perform,performance,17805,"tically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; all",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:18002,Performance,optimiz,optimization,18002," Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to s",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:18052,Performance,optimiz,optimized,18052,"lly; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not,",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:18464,Performance,optimiz,optimized,18464,"use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be ",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2304,Safety,recover,recovered,2304,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2899,Safety,avoid,avoiding,2899,"; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid caus",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3417,Safety,avoid,avoid,3417,"ic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArra",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3881,Safety,avoid,avoid,3881,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(c",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:2662,Security,access,access,2662," *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more me",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:8164,Security,Hash,Hash,8164,"bject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObjArray::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTCollection::GrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTCollection::Hash() const; virtual Int_tTObjArray::IndexOf(const TObject* obj) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTCollection::IsArgNull(const char* where, const TObject* obj) const; virtual Bool_tTObjArray::IsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTCollection::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tTObject::IsZombie() const; virtual TObject*TObjArray::Last() const; Int_tTSeqCollection::LastIndex() const; Int_tTObjArray::LowerBound() const; virtual voidTCollection::ls(Option_t* option = """") const; virtual TIterator*TObjArray::Make",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:5215,Testability,Assert,AssertClass,5215,,MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:12727,Testability,Test,TestBit,12727,"tion::RemoveAll(TCollection* col); virtual TObject*RemoveAt(Int_t idx); virtual voidTSeqCollection::RemoveBefore(TObject* before); virtual voidTSeqCollection::RemoveFirst(); virtual voidTSeqCollection::RemoveLast(); virtual voidRemoveRange(Int_t idx1, Int_t idx2); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetClass(const char* classname, Int_t size = 1000); voidSetClass(const TClass* cl, Int_t size = 1000); voidTCollection::SetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTObjArray::SetLast(Int_t last); voidTCollection::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOwner(Bool_t enable = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSort(Int_t upto = kMaxInt); static voidTCollection::StartGarbageCollection(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TObject*TObjArray::UncheckedAt(Int_t i) const; voidTSeqCollection::UnSort(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:12766,Testability,Test,TestBits,12766,"tion::RemoveAll(TCollection* col); virtual TObject*RemoveAt(Int_t idx); virtual voidTSeqCollection::RemoveBefore(TObject* before); virtual voidTSeqCollection::RemoveFirst(); virtual voidTSeqCollection::RemoveLast(); virtual voidRemoveRange(Int_t idx1, Int_t idx2); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetClass(const char* classname, Int_t size = 1000); voidSetClass(const TClass* cl, Int_t size = 1000); voidTCollection::SetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTObjArray::SetLast(Int_t last); voidTCollection::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOwner(Bool_t enable = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSort(Int_t upto = kMaxInt); static voidTCollection::StartGarbageCollection(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TObject*TObjArray::UncheckedAt(Int_t i) const; voidTSeqCollection::UnSort(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:18922,Testability,Test,Tests,18922,"treamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in thei",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:19618,Testability,Test,Tests,19618," might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:25318,Testability,Test,TestBit,25318,"constructed via the; new operator or via the New() method. To remove elements from; the clones array use Remove() or RemoveAt(). TObject * operator[](Int_t idx) const; Return the object at position idx. Returns 0 if idx is out of bounds. TObject * New(Int_t idx); Create an object of type fClass with the default ctor at the specified; index. Returns 0 in case of error. void AbsorbObjects(TClonesArray* tc); Directly move the object pointers from tc without cloning (copying).; This TClonesArray takes over ownership of all of tc's object; pointers. The tc array is left empty upon return. void AbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); Directly move the range of object pointers from tc without cloning; (copying).; This TClonesArray takes over ownership of all of tc's object pointers; from idx1 to idx2. The tc array is re-arranged by return. void MultiSort(Int_t nTCs, TClonesArray** tcs, Int_t upto = kMaxInt); Sort multiple TClonesArrays simultaneously with this array.; If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort array. TObject * AddrAt(Int_t idx). TClass * GetClass() const; { return fClass; }. void AddFirst(TObject* ); { MayNotUse(""AddFirst""); }. void AddLast(TObject* ); { MayNotUse(""AddLast""); }. void AddAt(TObject* , Int_t ); { MayNotUse(""AddAt""); }. void AddAtAndExpand(TObject* , Int_t ); { MayNotUse(""AddAtAndExpand""); }. Int_t AddAtFree(TObject* ); { MayNotUse(""AddAtFree""); return 0; }. void AddAfter(const TObject* , TObject* ); { MayNotUse(""AddAfter""); }. void AddBefore(const TObject* , TObject* ); { MayNotUse(""AddBefore""); }. Bool_t CanBypassStreamer() const; { return TestBit(kBypassStreamer); }.  Author: Rene Brun 11/02/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:1165,Usability,Clear,Clear,1165,"tion; function members; data members; class charts. ROOT;  CORE;  CONT;  TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"",",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:1178,Usability,Clear,Clear,1178," members; data members; class charts. ROOT;  CORE;  CONT;  TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the mem",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:1663,Usability,Clear,Clear,1663,"bjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; th",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:1680,Usability,Clear,Clear,1680,";; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""me",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3068,Usability,Clear,Clear,3068,"lity of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method ",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3313,Usability,Clear,Clear,3313,"memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClon",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3723,Usability,Clear,Clear,3723,"nsive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTC",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3734,Usability,Clear,Clear,3734,"nsive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTC",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3917,Usability,Clear,Clear,3917,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(c",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:3946,Usability,clear,clearing,3946,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(c",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:4032,Usability,Clear,Clear,4032," TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(const TObject*, TObject*); virtual voidAddFirst(TObject*); virtual voidAddLast(TObject*); TObject*AddrAt(Int_t",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:18888,Usability,Clear,Clear,18888,"m, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; Th",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:19258,Usability,Clear,Clear,19258,"quence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Cle",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:19555,Usability,Clear,Clear,19555,"; Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:19954,Usability,Clear,Clear,19954," the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. vo",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:19979,Usability,Clear,Clear,19979,"object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20009,Usability,Clear,Clear,20009,"object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20205,Usability,Clear,Clear,20205,"set (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20262,Usability,Clear,Clear,20262,"set (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20327,Usability,Clear,Clear,20327," index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or sh",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20554,Usability,clear,cleared,20554,"the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20621,Usability,Clear,Clear,20621,"s'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; on",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:20798,Usability,Clear,Clear,20798,"er to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree me",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TClonesArray.html:21745,Usability,simpl,simplified,21745,"ory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called in the TClonesArray is already; initialized with a class. void SetClass(const char* classname, Int_t size = 1000); see TClonesArray::SetClass(const TCla",MatchSource.WIKI,root/html602/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TClonesArray.html
https://root.cern/root/html602/TCollection.html:1344,Availability,avail,available,1344," describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; TIterbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ;",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:2440,Availability,Error,Error,2440,"thod) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; TIterbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; static voidEmptyGarbageCollection(); TIterend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidGarbageCollect(TObject* obj); static TCollection*GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual ",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:2569,Availability,error,error,2569,"dTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; TIterbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; static voidEmptyGarbageCollection(); TIterend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidGarbageCollect(TObject* obj); static TCollection*GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGrowBy(Int_t delta) const; virtual",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:2653,Availability,error,error,2653,"erbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; static voidEmptyGarbageCollection(); TIterend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidGarbageCollect(TObject* obj); static TCollection*GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voi",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:1154,Deployability,release,release,1154,"ion; function members; data members; class charts. ROOT;  CORE;  CONT;  TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; TIterbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, I",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:10087,Energy Efficiency,efficient,efficient,10087,"= """") const; Make a clone of an collection using the Streamer facility.; If newname is specified, this will be the name of the new collection. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this collection. void Dump() const; Dump all objects in this collection. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * operator()(const char* name) const; Find an object in this collection by name. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Optio",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:357,Integrability,protocol,protocol,357,". TCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; TIterbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(co",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:925,Integrability,Depend,Depending,925,". TCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; TIterbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(co",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:14607,Integrability,depend,depending,14607,"bufsize = 0); Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). TIter begin() const; { return ++(TIter(this)); }. TIter end() const; { return TIter::End(); }. TCollection(const TCollection& ). void operator=(const TCollection& ). TCollection(); { }. virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* option = """"). Int_t GetEntries() const; { return GetSize(); }. TObject ** GetObjectRef(const TObject* obj) const. Int_t GetSize() const; { return fSize; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsEmpty() const; { return GetSize() <= 0; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsOwner() const; { return TestBit(kIsOwner); }. Bool_t IsSortable() const; { return kTRUE; }. TIterator * MakeIterator(Bool_t dir = kIterForward) cons",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:475,Modifiability,inherit,inherit,475,". TCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; TIterbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(co",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:1059,Modifiability,inherit,inherits,1059,"der file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; TIterbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:3741,Modifiability,Inherit,InheritsFrom,3741,"bject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidGarbageCollect(TObject* obj); static TCollection*GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsArgNull(const char* where, const TObject* obj) const; virtual Bool_tIsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; virtual TIterator*MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::oper",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:3807,Modifiability,Inherit,InheritsFrom,3807,"l TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidGarbageCollect(TObject* obj); static TCollection*GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsArgNull(const char* where, const TObject* obj) const; virtual Bool_tIsEmpty() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; virtual TIterator*MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(siz",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:8426,Modifiability,Inherit,Inheritance,8426,"(anonymous)kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfNamename of the collection; Int_tfSizenumber of elements in collection; static TCollection::(anonymous)kIsOwner. private:. static TCollection*fgCurrentCollectionused by macro R__FOR_EACH; static Bool_tfgEmptyingGarbageused by garbage collector; static TObjectTable*fgGarbageCollectionused by garbage collector; static Int_tfgGarbageStackused by garbage collector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAll(const TCollection* col); Add all objects from collection col to this collection. void AddVector(TObject *va_(obj1), ...); Add all arguments to the collection. The list of objects must be; temrinated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);. Bool_t AssertClass(TClass* cl) const; Make sure all objects in this collection inherit from class cl. void Browse(TBrowser* b); Browse this collection (called by TBrowser).; If b=0, there is no Browse call TObject::Browse(0) instead.; This means TObject::Inspect() will be invoked indirectly. TObject * Clone(const char* newname = """") const; Make a clone of an collection using the Streamer facility.; If newname is specified, this will be the name of the new collection. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this colle",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:8439,Modifiability,Inherit,Inherited,8439,"(anonymous)kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfNamename of the collection; Int_tfSizenumber of elements in collection; static TCollection::(anonymous)kIsOwner. private:. static TCollection*fgCurrentCollectionused by macro R__FOR_EACH; static Bool_tfgEmptyingGarbageused by garbage collector; static TObjectTable*fgGarbageCollectionused by garbage collector; static Int_tfgGarbageStackused by garbage collector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAll(const TCollection* col); Add all objects from collection col to this collection. void AddVector(TObject *va_(obj1), ...); Add all arguments to the collection. The list of objects must be; temrinated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);. Bool_t AssertClass(TClass* cl) const; Make sure all objects in this collection inherit from class cl. void Browse(TBrowser* b); Browse this collection (called by TBrowser).; If b=0, there is no Browse call TObject::Browse(0) instead.; This means TObject::Inspect() will be invoked indirectly. TObject * Clone(const char* newname = """") const; Make a clone of an collection using the Streamer facility.; If newname is specified, this will be the name of the new collection. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this colle",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:8838,Modifiability,inherit,inherit,8838,"sBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfNamename of the collection; Int_tfSizenumber of elements in collection; static TCollection::(anonymous)kIsOwner. private:. static TCollection*fgCurrentCollectionused by macro R__FOR_EACH; static Bool_tfgEmptyingGarbageused by garbage collector; static TObjectTable*fgGarbageCollectionused by garbage collector; static Int_tfgGarbageStackused by garbage collector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAll(const TCollection* col); Add all objects from collection col to this collection. void AddVector(TObject *va_(obj1), ...); Add all arguments to the collection. The list of objects must be; temrinated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);. Bool_t AssertClass(TClass* cl) const; Make sure all objects in this collection inherit from class cl. void Browse(TBrowser* b); Browse this collection (called by TBrowser).; If b=0, there is no Browse call TObject::Browse(0) instead.; This means TObject::Inspect() will be invoked indirectly. TObject * Clone(const char* newname = """") const; Make a clone of an collection using the Streamer facility.; If newname is specified, this will be the name of the new collection. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this collection. void Dump() const; Dump all objects in this collection. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * operator()(const char* name) const; Find an object in this collection by ",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:10924,Performance,perform,perform,10924,"Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Option_t* option = """") const; Defualt print for collections, calls Print(option, 1).; This will print the collection header and Print() methods of; all the collection entries. If you want to override Print() for a collection class, first; see if you can accomplish it by overriding the following protected; methods:; void PrintCollectionHeader(Option_t* option) const;; const char* GetCollectionEntryName(TObject* entry) const;; void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const;; Otherwise override the Print(Option_t *option, Int_t); variant. Remember to declare:; using TCollection::Print;; somewhere close to the method declaration. void Print(Option_t* option, Int_t recurse) const; Print the collection header and its elements. If recurse is n",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:14003,Security,access,accessible,14003,"on col from this collection. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). TIter begin() const; { return ++(TIter(this)); }. TIter end() const; { return TIter::End(); }. TCollection(const TCollection& ). void operator=(const TCollection& ). TCollection(); { }. virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* nam",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:15293,Security,Hash,Hash,15293,"llection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). TIter begin() const; { return ++(TIter(this)); }. TIter end() const; { return TIter::End(); }. TCollection(const TCollection& ). void operator=(const TCollection& ). TCollection(); { }. virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* option = """"). Int_t GetEntries() const; { return GetSize(); }. TObject ** GetObjectRef(const TObject* obj) const. Int_t GetSize() const; { return fSize; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsEmpty() const; { return GetSize() <= 0; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsOwner() const; { return TestBit(kIsOwner); }. Bool_t IsSortable() const; { return kTRUE; }. TIterator * MakeIterator(Bool_t dir = kIterForward) const. TIterator * MakeReverseIterator() const; { return MakeIterator(kIterBackward); }. TObject * Remove(TObject* obj). void RemoveAll(TCollection* col). void SetName(const char* name); { fName = name; }.  Author: Fons Rademakers 13/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:15322,Security,Hash,Hash,15322,"llection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). TIter begin() const; { return ++(TIter(this)); }. TIter end() const; { return TIter::End(); }. TCollection(const TCollection& ). void operator=(const TCollection& ). TCollection(); { }. virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* option = """"). Int_t GetEntries() const; { return GetSize(); }. TObject ** GetObjectRef(const TObject* obj) const. Int_t GetSize() const; { return fSize; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsEmpty() const; { return GetSize() <= 0; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsOwner() const; { return TestBit(kIsOwner); }. Bool_t IsSortable() const; { return kTRUE; }. TIterator * MakeIterator(Bool_t dir = kIterForward) const. TIterator * MakeReverseIterator() const; { return MakeIterator(kIterBackward); }. TObject * Remove(TObject* obj). void RemoveAll(TCollection* col). void SetName(const char* name); { fName = name; }.  Author: Fons Rademakers 13/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:6385,Testability,Test,TestBit,6385,"); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject*operator()(const char* name) const; virtual voidPaint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual voidPrint(Option_t* option, Int_t recurse) const; virtual voidPrint(Option_t* option, const char* wildcard, Int_t recurse = 1) const; virtual voidPrint(Option_t* option, TPRegexp& regexp, Int_t recurse = 1) const; virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); virtual TObject*Remove(TObject* obj); voidRemoveAll(); virtual voidRemoveAll(TCollection* col); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOwner(Bool_t enable = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; static voidStartGarbageCollection(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:6424,Testability,Test,TestBits,6424,"); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject*operator()(const char* name) const; virtual voidPaint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual voidPrint(Option_t* option, Int_t recurse) const; virtual voidPrint(Option_t* option, const char* wildcard, Int_t recurse = 1) const; virtual voidPrint(Option_t* option, TPRegexp& regexp, Int_t recurse = 1) const; virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); virtual TObject*Remove(TObject* obj); voidRemoveAll(); virtual voidRemoveAll(TCollection* col); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentCollection(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOwner(Bool_t enable = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; static voidStartGarbageCollection(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:8766,Testability,Assert,AssertClass,8766,"sBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfNamename of the collection; Int_tfSizenumber of elements in collection; static TCollection::(anonymous)kIsOwner. private:. static TCollection*fgCurrentCollectionused by macro R__FOR_EACH; static Bool_tfgEmptyingGarbageused by garbage collector; static TObjectTable*fgGarbageCollectionused by garbage collector; static Int_tfgGarbageStackused by garbage collector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAll(const TCollection* col); Add all objects from collection col to this collection. void AddVector(TObject *va_(obj1), ...); Add all arguments to the collection. The list of objects must be; temrinated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);. Bool_t AssertClass(TClass* cl) const; Make sure all objects in this collection inherit from class cl. void Browse(TBrowser* b); Browse this collection (called by TBrowser).; If b=0, there is no Browse call TObject::Browse(0) instead.; This means TObject::Inspect() will be invoked indirectly. TObject * Clone(const char* newname = """") const; Make a clone of an collection using the Streamer facility.; If newname is specified, this will be the name of the new collection. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this collection. void Dump() const; Dump all objects in this collection. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * operator()(const char* name) const; Find an object in this collection by ",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:15462,Testability,Test,TestBit,15462,"llection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). TIter begin() const; { return ++(TIter(this)); }. TIter end() const; { return TIter::End(); }. TCollection(const TCollection& ). void operator=(const TCollection& ). TCollection(); { }. virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* option = """"). Int_t GetEntries() const; { return GetSize(); }. TObject ** GetObjectRef(const TObject* obj) const. Int_t GetSize() const; { return fSize; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsEmpty() const; { return GetSize() <= 0; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsOwner() const; { return TestBit(kIsOwner); }. Bool_t IsSortable() const; { return kTRUE; }. TIterator * MakeIterator(Bool_t dir = kIterForward) const. TIterator * MakeReverseIterator() const; { return MakeIterator(kIterBackward); }. TObject * Remove(TObject* obj). void RemoveAll(TCollection* col). void SetName(const char* name); { fName = name; }.  Author: Fons Rademakers 13/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:14589,Usability,Clear,Clear,14589,"bufsize = 0); Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). TIter begin() const; { return ++(TIter(this)); }. TIter end() const; { return TIter::End(); }. TCollection(const TCollection& ). void operator=(const TCollection& ). TCollection(); { }. virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* option = """"). Int_t GetEntries() const; { return GetSize(); }. TObject ** GetObjectRef(const TObject* obj) const. Int_t GetSize() const; { return fSize; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsEmpty() const; { return GetSize() <= 0; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsOwner() const; { return TestBit(kIsOwner); }. Bool_t IsSortable() const; { return kTRUE; }. TIterator * MakeIterator(Bool_t dir = kIterForward) cons",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollection.html:14924,Usability,Clear,Clear,14924,"(i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). TIter begin() const; { return ++(TIter(this)); }. TIter end() const; { return TIter::End(); }. TCollection(const TCollection& ). void operator=(const TCollection& ). TCollection(); { }. virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* option = """"). Int_t GetEntries() const; { return GetSize(); }. TObject ** GetObjectRef(const TObject* obj) const. Int_t GetSize() const; { return fSize; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsEmpty() const; { return GetSize() <= 0; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsOwner() const; { return TestBit(kIsOwner); }. Bool_t IsSortable() const; { return kTRUE; }. TIterator * MakeIterator(Bool_t dir = kIterForward) const. TIterator * MakeReverseIterator() const; { return MakeIterator(kIterBackward); }. TObject * Remove(TObject* obj). void RemoveAll(TCollection* col). void SetName(const char* name); { fName = name; }.  Author: Fons Rademakers 13/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id$  Last generated: 201",MatchSource.WIKI,root/html602/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollection.html
https://root.cern/root/html602/TCollectionClassStreamer.html:1854,Modifiability,Inherit,Inheritance,1854,"quence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionClassStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual TClassStreamer*Generate() const; virtual const TClass*TClassStreamer::GetOnFileClass() const; TGenCollectionProxy*GetXYZ(); virtual voidoperator()(TBuffer& buff, void* obj); virtual voidTClassStreamer::SetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* obj, const TClass* onfileClass); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionClassStreamer(). protected:. voidTCollectionStreamer::InvalidProxyError(); TCollectionClassStreamer&operator=(const TCollectionClassStreamer& rhs); TCollectionClassStreamer(const TCollectionClassStreamer& c). Data Members; protected:. TClassRefTClassStreamer::fOnFileClass; TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionClassStreamer& rhs). TCollectionClassStreamer(const TCollectionClassStreamer& c); Copy constructor. { }. TCollectionClassStreamer(); Initializing constructor. { }. virtual ~TCollectionClassStreamer(); Standard destructor. { }. void operator()(TBuffer& buff, void* obj); Streamer for I/O handling. { Streamer(buff,obj,0,fOnFileClass); }. void Stream(TBuffer& b, void* obj, const TClass* onfileClass). TClassStreamer * Generate() const; Virtual copy constructor. TGenCollectionProxy * GetXYZ(); { return TCollectionStreamer::fStreamer; }.  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionClassStreamer.html
https://root.cern/root/html602/TCollectionClassStreamer.html:1867,Modifiability,Inherit,Inherited,1867,"quence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionClassStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual TClassStreamer*Generate() const; virtual const TClass*TClassStreamer::GetOnFileClass() const; TGenCollectionProxy*GetXYZ(); virtual voidoperator()(TBuffer& buff, void* obj); virtual voidTClassStreamer::SetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* obj, const TClass* onfileClass); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionClassStreamer(). protected:. voidTCollectionStreamer::InvalidProxyError(); TCollectionClassStreamer&operator=(const TCollectionClassStreamer& rhs); TCollectionClassStreamer(const TCollectionClassStreamer& c). Data Members; protected:. TClassRefTClassStreamer::fOnFileClass; TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionClassStreamer& rhs). TCollectionClassStreamer(const TCollectionClassStreamer& c); Copy constructor. { }. TCollectionClassStreamer(); Initializing constructor. { }. virtual ~TCollectionClassStreamer(); Standard destructor. { }. void operator()(TBuffer& buff, void* obj); Streamer for I/O handling. { Streamer(buff,obj,0,fOnFileClass); }. void Stream(TBuffer& b, void* obj, const TClass* onfileClass). TClassStreamer * Generate() const; Virtual copy constructor. TGenCollectionProxy * GetXYZ(); { return TCollectionStreamer::fStreamer; }.  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionClassStreamer.html
https://root.cern/root/html602/TCollectionClassStreamer.html:624,Security,expose,expose,624,". TCollectionClassStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionClassStreamer. class TCollectionClassStreamer: public TClassStreamer, public TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionClassStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual TClassStreamer*Generate() const; virtual const TClass*TClassStreamer::GetOnFileClass() const; TGenCollectionProxy*GetXYZ(); virtual voidoperator()(TBuffer& buff, void* obj); virtual voidTClassStreamer::SetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* obj, const TClass* onfileClass); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionClassStreamer(). protected:. voidTCollectionStreamer::InvalidProxyError(); TCollectionClassStreamer&operator=(const TCollectionClassStreamer& rhs); TCollectionClassStreamer(const TCollectionClassStreamer& c). Data Members; protected:. TClassRefTClassStreamer::fOnFileClass; TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionClassStreamer& rhs). T",MatchSource.WIKI,root/html602/TCollectionClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionClassStreamer.html
https://root.cern/root/html602/TCollectionClassStreamer.html:728,Security,access,access,728,". TCollectionClassStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionClassStreamer. class TCollectionClassStreamer: public TClassStreamer, public TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionClassStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual TClassStreamer*Generate() const; virtual const TClass*TClassStreamer::GetOnFileClass() const; TGenCollectionProxy*GetXYZ(); virtual voidoperator()(TBuffer& buff, void* obj); virtual voidTClassStreamer::SetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* obj, const TClass* onfileClass); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionClassStreamer(). protected:. voidTCollectionStreamer::InvalidProxyError(); TCollectionClassStreamer&operator=(const TCollectionClassStreamer& rhs); TCollectionClassStreamer(const TCollectionClassStreamer& c). Data Members; protected:. TClassRefTClassStreamer::fOnFileClass; TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionClassStreamer& rhs). T",MatchSource.WIKI,root/html602/TCollectionClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionClassStreamer.html
https://root.cern/root/html602/TCollectionClassStreamer.html:753,Security,Access,Access,753,". TCollectionClassStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionClassStreamer. class TCollectionClassStreamer: public TClassStreamer, public TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionClassStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual TClassStreamer*Generate() const; virtual const TClass*TClassStreamer::GetOnFileClass() const; TGenCollectionProxy*GetXYZ(); virtual voidoperator()(TBuffer& buff, void* obj); virtual voidTClassStreamer::SetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* obj, const TClass* onfileClass); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionClassStreamer(). protected:. voidTCollectionStreamer::InvalidProxyError(); TCollectionClassStreamer&operator=(const TCollectionClassStreamer& rhs); TCollectionClassStreamer(const TCollectionClassStreamer& c). Data Members; protected:. TClassRefTClassStreamer::fOnFileClass; TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionClassStreamer& rhs). T",MatchSource.WIKI,root/html602/TCollectionClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionClassStreamer.html
https://root.cern/root/html602/TCollectionClassStreamer.html:868,Usability,clear,clear,868,". TCollectionClassStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionClassStreamer. class TCollectionClassStreamer: public TClassStreamer, public TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionClassStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual TClassStreamer*Generate() const; virtual const TClass*TClassStreamer::GetOnFileClass() const; TGenCollectionProxy*GetXYZ(); virtual voidoperator()(TBuffer& buff, void* obj); virtual voidTClassStreamer::SetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* obj, const TClass* onfileClass); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionClassStreamer(). protected:. voidTCollectionStreamer::InvalidProxyError(); TCollectionClassStreamer&operator=(const TCollectionClassStreamer& rhs); TCollectionClassStreamer(const TCollectionClassStreamer& c). Data Members; protected:. TClassRefTClassStreamer::fOnFileClass; TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionClassStreamer& rhs). T",MatchSource.WIKI,root/html602/TCollectionClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionClassStreamer.html
https://root.cern/root/html602/TCollectionMemberStreamer.html:1711,Modifiability,Inherit,Inheritance,1711,"f this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionMemberStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual const TClass*TMemberStreamer::GetOnFileClass() const; virtual voidoperator()(TBuffer& buff, void* obj, Int_t siz = 0); virtual voidTMemberStreamer::SetOnFileClass(const TClass* cl); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionMemberStreamer(); TCollectionMemberStreamer(const TCollectionMemberStreamer& c). protected:. voidTCollectionStreamer::InvalidProxyError(). private:. TCollectionMemberStreamer&operator=(const TCollectionMemberStreamer& rhs). Data Members; protected:. TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionMemberStreamer& rhs). void operator()(TBuffer &buff, void *obj ); Streamer for I/O handling. { Streamer(buff,obj,0,fOnFileClass); }. TCollectionMemberStreamer(); Initializing constructor. { }. TCollectionMemberStreamer(const TCollectionMemberStreamer& c); Copy constructor. { }. virtual ~TCollectionMemberStreamer(); Standard destructor. { }.  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMemberStreamer.html
https://root.cern/root/html602/TCollectionMemberStreamer.html:1724,Modifiability,Inherit,Inherited,1724,"f this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionMemberStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual const TClass*TMemberStreamer::GetOnFileClass() const; virtual voidoperator()(TBuffer& buff, void* obj, Int_t siz = 0); virtual voidTMemberStreamer::SetOnFileClass(const TClass* cl); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionMemberStreamer(); TCollectionMemberStreamer(const TCollectionMemberStreamer& c). protected:. voidTCollectionStreamer::InvalidProxyError(). private:. TCollectionMemberStreamer&operator=(const TCollectionMemberStreamer& rhs). Data Members; protected:. TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionMemberStreamer& rhs). void operator()(TBuffer &buff, void *obj ); Streamer for I/O handling. { Streamer(buff,obj,0,fOnFileClass); }. TCollectionMemberStreamer(); Initializing constructor. { }. TCollectionMemberStreamer(const TCollectionMemberStreamer& c); Copy constructor. { }. virtual ~TCollectionMemberStreamer(); Standard destructor. { }.  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMemberStreamer.html
https://root.cern/root/html602/TCollectionMemberStreamer.html:628,Security,expose,expose,628,". TCollectionMemberStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionMemberStreamer. class TCollectionMemberStreamer: public TMemberStreamer, public TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionMemberStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual const TClass*TMemberStreamer::GetOnFileClass() const; virtual voidoperator()(TBuffer& buff, void* obj, Int_t siz = 0); virtual voidTMemberStreamer::SetOnFileClass(const TClass* cl); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionMemberStreamer(); TCollectionMemberStreamer(const TCollectionMemberStreamer& c). protected:. voidTCollectionStreamer::InvalidProxyError(). private:. TCollectionMemberStreamer&operator=(const TCollectionMemberStreamer& rhs). Data Members; protected:. TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionMemberStreamer& rhs). void operator()(TBuffer &buff, void *obj ); Streamer for I/O handling. { Streamer(buff,obj,0,fOnFileClass); }. TCollectionMemberStreamer(); Ini",MatchSource.WIKI,root/html602/TCollectionMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMemberStreamer.html
https://root.cern/root/html602/TCollectionMemberStreamer.html:732,Security,access,access,732,". TCollectionMemberStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionMemberStreamer. class TCollectionMemberStreamer: public TMemberStreamer, public TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionMemberStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual const TClass*TMemberStreamer::GetOnFileClass() const; virtual voidoperator()(TBuffer& buff, void* obj, Int_t siz = 0); virtual voidTMemberStreamer::SetOnFileClass(const TClass* cl); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionMemberStreamer(); TCollectionMemberStreamer(const TCollectionMemberStreamer& c). protected:. voidTCollectionStreamer::InvalidProxyError(). private:. TCollectionMemberStreamer&operator=(const TCollectionMemberStreamer& rhs). Data Members; protected:. TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionMemberStreamer& rhs). void operator()(TBuffer &buff, void *obj ); Streamer for I/O handling. { Streamer(buff,obj,0,fOnFileClass); }. TCollectionMemberStreamer(); Ini",MatchSource.WIKI,root/html602/TCollectionMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMemberStreamer.html
https://root.cern/root/html602/TCollectionMemberStreamer.html:757,Security,Access,Access,757,". TCollectionMemberStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionMemberStreamer. class TCollectionMemberStreamer: public TMemberStreamer, public TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionMemberStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual const TClass*TMemberStreamer::GetOnFileClass() const; virtual voidoperator()(TBuffer& buff, void* obj, Int_t siz = 0); virtual voidTMemberStreamer::SetOnFileClass(const TClass* cl); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionMemberStreamer(); TCollectionMemberStreamer(const TCollectionMemberStreamer& c). protected:. voidTCollectionStreamer::InvalidProxyError(). private:. TCollectionMemberStreamer&operator=(const TCollectionMemberStreamer& rhs). Data Members; protected:. TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionMemberStreamer& rhs). void operator()(TBuffer &buff, void *obj ); Streamer for I/O handling. { Streamer(buff,obj,0,fOnFileClass); }. TCollectionMemberStreamer(); Ini",MatchSource.WIKI,root/html602/TCollectionMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMemberStreamer.html
https://root.cern/root/html602/TCollectionMemberStreamer.html:872,Usability,clear,clear,872,". TCollectionMemberStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionMemberStreamer. class TCollectionMemberStreamer: public TMemberStreamer, public TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionMemberStreamer(); voidTCollectionStreamer::AdoptStreamer(TGenCollectionProxy* streamer); virtual const TClass*TMemberStreamer::GetOnFileClass() const; virtual voidoperator()(TBuffer& buff, void* obj, Int_t siz = 0); virtual voidTMemberStreamer::SetOnFileClass(const TClass* cl); voidTCollectionStreamer::Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionMemberStreamer(); TCollectionMemberStreamer(const TCollectionMemberStreamer& c). protected:. voidTCollectionStreamer::InvalidProxyError(). private:. TCollectionMemberStreamer&operator=(const TCollectionMemberStreamer& rhs). Data Members; protected:. TGenCollectionProxy*TCollectionStreamer::fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionStreamer& operator=(const TCollectionMemberStreamer& rhs). void operator()(TBuffer &buff, void *obj ); Streamer for I/O handling. { Streamer(buff,obj,0,fOnFileClass); }. TCollectionMemberStreamer(); Ini",MatchSource.WIKI,root/html602/TCollectionMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMemberStreamer.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:3066,Availability,Error,Error,3066,,MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:3195,Availability,error,error,3195,,MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:3279,Availability,error,error,3279,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TMethodBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject:",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:10178,Integrability,Wrap,Wrapper,10178,"ct::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Contructor, see TMethodBrowsable's constructor.; Prepends ""@"" to the name to make this method work on the container. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's collection class and its base classes,; and returns the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionMethodBrowsable(); {}. TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:10287,Integrability,depend,depending,10287,"ct::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Contructor, see TMethodBrowsable's constructor.; Prepends ""@"" to the name to make this method work on the container. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's collection class and its base classes,; and returns the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionMethodBrowsable(); {}. TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:10355,Integrability,Wrap,Wrapper,10355,"ct::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Contructor, see TMethodBrowsable's constructor.; Prepends ""@"" to the name to make this method work on the container. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's collection class and its base classes,; and returns the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionMethodBrowsable(); {}. TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:10464,Integrability,depend,depending,10464,"ct::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Contructor, see TMethodBrowsable's constructor.; Prepends ""@"" to the name to make this method work on the container. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's collection class and its base classes,; and returns the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionMethodBrowsable(); {}. TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:458,Modifiability,extend,extend,458,". TCollectionMethodBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TCollectionMethodBrowsable. class TCollectionMethodBrowsable: public TMethodBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, c",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:4753,Modifiability,Inherit,InheritsFrom,4753,"rtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TMethodBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*TVirtualBranchBrowsable::GetParent() const; voidTVirtualBranchBrowsable::GetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTVirtualBranchBrowsable::IsFolder() const; static Bool_tTMethodBrowsable::IsMethodBrowsable(const TMethod* m); Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* ",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:4819,Modifiability,Inherit,InheritsFrom,4819,"(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TMethodBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*TVirtualBranchBrowsable::GetParent() const; voidTVirtualBranchBrowsable::GetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTVirtualBranchBrowsable::IsFolder() const; static Bool_tTMethodBrowsable::IsMethodBrowsable(const TMethod* m); Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operat",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:9431,Modifiability,Inherit,Inheritance,9431,"tic voidTVirtualBranchBrowsable::UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Contructor, see TMethodBrowsable's constructor.; Prepends ""@"" to the name to make this method work on the container. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's collection class and its base classes,; and returns the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same m",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:9444,Modifiability,Inherit,Inherited,9444,"tic voidTVirtualBranchBrowsable::UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Contructor, see TMethodBrowsable's constructor.; Prepends ""@"" to the name to make this method work on the container. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's collection class and its base classes,; and returns the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same m",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:1185,Performance,cache,cached,1185,"  TREE;  TCollectionMethodBrowsable. class TCollectionMethodBrowsable: public TMethodBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionMeth",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:1246,Performance,cache,cached,1246,"  TREE;  TCollectionMethodBrowsable. class TCollectionMethodBrowsable: public TMethodBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionMeth",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:4643,Security,Hash,Hash,4643,"ndObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TMethodBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*TVirtualBranchBrowsable::GetParent() const; voidTVirtualBranchBrowsable::GetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTVirtualBranchBrowsable::IsFolder() const; static Bool_tTMethodBrowsable::IsMethodBrowsable(const TMethod* m); Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator ",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:7179,Testability,Test,TestBit,7179,"tr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCollectionMethodBrowsable&operator=(const TCollectionMethodBrowsable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static voidRegister(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCollectionMethodBrowsable(const TCollectionMethodBrowsable&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTVirtualBranchBrowsable::TypeIsPointer() const; static voidUnregister(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:7218,Testability,Test,TestBits,7218,"tr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCollectionMethodBrowsable&operator=(const TCollectionMethodBrowsable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static voidRegister(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCollectionMethodBrowsable(const TCollectionMethodBrowsable&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTVirtualBranchBrowsable::TypeIsPointer() const; static voidUnregister(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:1433,Usability,simpl,simple,1433,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Cl",MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionMethodBrowsable.html:2523,Usability,Clear,Clear,2523,,MatchSource.WIKI,root/html602/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:3056,Availability,Error,Error,3056,,MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:3185,Availability,error,error,3185,,MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:3269,Availability,error,error,3269,"able(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; const char*GetDraw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TVirtualBranchBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:10267,Integrability,Wrap,Wrapper,10267,"gTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gen",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:10376,Integrability,depend,depending,10376,"Named::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:10444,Integrability,Wrap,Wrapper,10444,"Named::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:10553,Integrability,depend,depending,10553,"Named::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:471,Modifiability,extend,extend,471,". TCollectionPropertyBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TCollectionPropertyBrowsable. class TCollectionPropertyBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(T",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:4778,Modifiability,Inherit,InheritsFrom,4778,"onst; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; const char*GetDraw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TVirtualBranchBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*TVirtualBranchBrowsable::GetParent() const; voidTVirtualBranchBrowsable::GetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTVirtualBranchBrowsable::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:4844,Modifiability,Inherit,InheritsFrom,4844,", const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; const char*GetDraw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TVirtualBranchBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*TVirtualBranchBrowsable::GetParent() const; voidTVirtualBranchBrowsable::GetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTVirtualBranchBrowsable::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCollectionPropertyBrowsable&operator",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:9433,Modifiability,Inherit,Inheritance,9433,"e::MethodCreateListOfBrowsables_t generator). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:9446,Modifiability,Inherit,Inherited,9446,"e::MethodCreateListOfBrowsables_t generator). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:1198,Performance,cache,cached,1198,"TCollectionPropertyBrowsable. class TCollectionPropertyBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionProp",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:1259,Performance,cache,cached,1259,"TCollectionPropertyBrowsable. class TCollectionPropertyBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionProp",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:4668,Security,Hash,Hash,4668,"irtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; const char*GetDraw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TVirtualBranchBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*TVirtualBranchBrowsable::GetParent() const; voidTVirtualBranchBrowsable::GetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTVirtualBranchBrowsable::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz)",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:7144,Testability,Test,TestBit,7144,"dTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCollectionPropertyBrowsable&operator=(const TCollectionPropertyBrowsable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static voidRegister(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCollectionPropertyBrowsable(const TCollectionPropertyBrowsable&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTVirtualBranchBrowsable::TypeIsPointer() const; static voidUnregister(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:7183,Testability,Test,TestBits,7183,"dTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TCollectionPropertyBrowsable&operator=(const TCollectionPropertyBrowsable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static voidRegister(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TCollectionPropertyBrowsable(const TCollectionPropertyBrowsable&); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTVirtualBranchBrowsable::TypeIsPointer() const; static voidUnregister(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:1446,Usability,simpl,simple,1446,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionPropertyBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const ch",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:2513,Usability,Clear,Clear,2513,,MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionPropertyBrowsable.html:10129,Usability,simpl,simply,10129,"eKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable).  Author: Axel Naumann 14/10/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 14:",MatchSource.WIKI,root/html602/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html
https://root.cern/root/html602/TCollectionProxyFactory.html:1890,Modifiability,Inherit,Inheritance,1890,"nProxyFactory(); static TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); static TMemberStreamer*GenEmulatedMemberStreamer(const char* class_name, Bool_t silent); static TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); static TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TMemberStreamer*GenExplicitMemberStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TCollectionProxyFactory::Proxy_t*GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TGenCollectionStreamer*GenExplicitStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); TCollectionProxyFactory&operator=(const TCollectionProxyFactory&); TCollectionProxyFactory&operator=(TCollectionProxyFactory&&); TCollectionProxyFactory(); TCollectionProxyFactory(const TCollectionProxyFactory&); TCollectionProxyFactory(TCollectionProxyFactory&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GenEmulatedProxy(const char* class_name, Bool_t silent); Generate emulated collection proxy for a given class. GenEmulatedClassStreamer(const char* class_name, Bool_t silent); Generate emulated class streamer for a given collection class. GenEmulatedMemberStreamer(const char* class_name, Bool_t silent); Generate emulated member streamer for a given collection class. GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate proxy from static functions. GenExplicitStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate streamer from static functions. GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate class streamer from static functions. GenExplicitMemberStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate member streamer from static functions. TCollectionStreamer& operator=(const TCollectionStreamer&). TCollectionClassStreamer & operator=(const TCo",MatchSource.WIKI,root/html602/TCollectionProxyFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionProxyFactory.html
https://root.cern/root/html602/TCollectionProxyFactory.html:1903,Modifiability,Inherit,Inherited,1903,"nProxyFactory(); static TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); static TMemberStreamer*GenEmulatedMemberStreamer(const char* class_name, Bool_t silent); static TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); static TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TMemberStreamer*GenExplicitMemberStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TCollectionProxyFactory::Proxy_t*GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TGenCollectionStreamer*GenExplicitStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); TCollectionProxyFactory&operator=(const TCollectionProxyFactory&); TCollectionProxyFactory&operator=(TCollectionProxyFactory&&); TCollectionProxyFactory(); TCollectionProxyFactory(const TCollectionProxyFactory&); TCollectionProxyFactory(TCollectionProxyFactory&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GenEmulatedProxy(const char* class_name, Bool_t silent); Generate emulated collection proxy for a given class. GenEmulatedClassStreamer(const char* class_name, Bool_t silent); Generate emulated class streamer for a given collection class. GenEmulatedMemberStreamer(const char* class_name, Bool_t silent); Generate emulated member streamer for a given collection class. GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate proxy from static functions. GenExplicitStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate streamer from static functions. GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate class streamer from static functions. GenExplicitMemberStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate member streamer from static functions. TCollectionStreamer& operator=(const TCollectionStreamer&). TCollectionClassStreamer & operator=(const TCo",MatchSource.WIKI,root/html602/TCollectionProxyFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionProxyFactory.html
https://root.cern/root/html602/TCollectionProxyFactory.html:570,Security,expose,expose,570,". TCollectionProxyFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionProxyFactory. class TCollectionProxyFactory. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~TCollectionProxyFactory(); static TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); static TMemberStreamer*GenEmulatedMemberStreamer(const char* class_name, Bool_t silent); static TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); static TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TMemberStreamer*GenExplicitMemberStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TCollectionProxyFactory::Proxy_t*GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TGenCollectionStreamer*GenExplicitStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); TCollectionProxyFactory&operator=(const TCollectionProxyFactory&); TCollectionProxyFactory&operator=(TCollectionProxyFactory&&); TCollectionProxyFactory(); TCollectionProxyFactory(const TCollectionProxyFactory&); TCollectionProxyFactory(TCollectionProxyFactory&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GenEmulatedProxy(const char* class",MatchSource.WIKI,root/html602/TCollectionProxyFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionProxyFactory.html
https://root.cern/root/html602/TCollectionProxyFactory.html:674,Security,access,access,674,". TCollectionProxyFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionProxyFactory. class TCollectionProxyFactory. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~TCollectionProxyFactory(); static TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); static TMemberStreamer*GenEmulatedMemberStreamer(const char* class_name, Bool_t silent); static TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); static TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TMemberStreamer*GenExplicitMemberStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TCollectionProxyFactory::Proxy_t*GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TGenCollectionStreamer*GenExplicitStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); TCollectionProxyFactory&operator=(const TCollectionProxyFactory&); TCollectionProxyFactory&operator=(TCollectionProxyFactory&&); TCollectionProxyFactory(); TCollectionProxyFactory(const TCollectionProxyFactory&); TCollectionProxyFactory(TCollectionProxyFactory&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GenEmulatedProxy(const char* class",MatchSource.WIKI,root/html602/TCollectionProxyFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionProxyFactory.html
https://root.cern/root/html602/TCollectionProxyFactory.html:699,Security,Access,Access,699,". TCollectionProxyFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionProxyFactory. class TCollectionProxyFactory. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~TCollectionProxyFactory(); static TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); static TMemberStreamer*GenEmulatedMemberStreamer(const char* class_name, Bool_t silent); static TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); static TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TMemberStreamer*GenExplicitMemberStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TCollectionProxyFactory::Proxy_t*GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TGenCollectionStreamer*GenExplicitStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); TCollectionProxyFactory&operator=(const TCollectionProxyFactory&); TCollectionProxyFactory&operator=(TCollectionProxyFactory&&); TCollectionProxyFactory(); TCollectionProxyFactory(const TCollectionProxyFactory&); TCollectionProxyFactory(TCollectionProxyFactory&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GenEmulatedProxy(const char* class",MatchSource.WIKI,root/html602/TCollectionProxyFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionProxyFactory.html
https://root.cern/root/html602/TCollectionProxyFactory.html:814,Usability,clear,clear,814,". TCollectionProxyFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionProxyFactory. class TCollectionProxyFactory. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~TCollectionProxyFactory(); static TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); static TMemberStreamer*GenEmulatedMemberStreamer(const char* class_name, Bool_t silent); static TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); static TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TMemberStreamer*GenExplicitMemberStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TCollectionProxyFactory::Proxy_t*GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); static TGenCollectionStreamer*GenExplicitStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); TCollectionProxyFactory&operator=(const TCollectionProxyFactory&); TCollectionProxyFactory&operator=(TCollectionProxyFactory&&); TCollectionProxyFactory(); TCollectionProxyFactory(const TCollectionProxyFactory&); TCollectionProxyFactory(TCollectionProxyFactory&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GenEmulatedProxy(const char* class",MatchSource.WIKI,root/html602/TCollectionProxyFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionProxyFactory.html
https://root.cern/root/html602/TCollectionStreamer.html:1436,Availability,Error,Error,1436,"ription; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionStreamer. class TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionStreamer(); voidAdoptStreamer(TGenCollectionProxy* streamer); voidStreamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionStreamer(); TCollectionStreamer(const TCollectionStreamer& c). protected:. voidInvalidProxyError(). private:. TCollectionStreamer&operator=(const TCollectionStreamer&). Data Members; protected:. TGenCollectionProxy*fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InvalidProxyError(); Issue Error about invalid proxy. TCollectionStreamer(); Initializing constructor. TCollectionStreamer(const TCollectionStreamer& c); Copy constructor. ~TCollectionStreamer(); Standard destructor. void AdoptStreamer(TGenCollectionProxy* streamer); Attach worker proxy. void Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); Streamer for I/O handling. TCollectionStreamer& operator=(const TCollectionStreamer& ).  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionStreamer.html
https://root.cern/root/html602/TCollectionStreamer.html:1327,Modifiability,Inherit,Inheritance,1327,"ription; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionStreamer. class TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionStreamer(); voidAdoptStreamer(TGenCollectionProxy* streamer); voidStreamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionStreamer(); TCollectionStreamer(const TCollectionStreamer& c). protected:. voidInvalidProxyError(). private:. TCollectionStreamer&operator=(const TCollectionStreamer&). Data Members; protected:. TGenCollectionProxy*fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InvalidProxyError(); Issue Error about invalid proxy. TCollectionStreamer(); Initializing constructor. TCollectionStreamer(const TCollectionStreamer& c); Copy constructor. ~TCollectionStreamer(); Standard destructor. void AdoptStreamer(TGenCollectionProxy* streamer); Attach worker proxy. void Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); Streamer for I/O handling. TCollectionStreamer& operator=(const TCollectionStreamer& ).  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionStreamer.html
https://root.cern/root/html602/TCollectionStreamer.html:1340,Modifiability,Inherit,Inherited,1340,"ription; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionStreamer. class TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionStreamer(); voidAdoptStreamer(TGenCollectionProxy* streamer); voidStreamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionStreamer(); TCollectionStreamer(const TCollectionStreamer& c). protected:. voidInvalidProxyError(). private:. TCollectionStreamer&operator=(const TCollectionStreamer&). Data Members; protected:. TGenCollectionProxy*fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InvalidProxyError(); Issue Error about invalid proxy. TCollectionStreamer(); Initializing constructor. TCollectionStreamer(const TCollectionStreamer& c); Copy constructor. ~TCollectionStreamer(); Standard destructor. void AdoptStreamer(TGenCollectionProxy* streamer); Attach worker proxy. void Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); Streamer for I/O handling. TCollectionStreamer& operator=(const TCollectionStreamer& ).  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TCollectionStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionStreamer.html
https://root.cern/root/html602/TCollectionStreamer.html:558,Security,expose,expose,558,". TCollectionStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionStreamer. class TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionStreamer(); voidAdoptStreamer(TGenCollectionProxy* streamer); voidStreamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionStreamer(); TCollectionStreamer(const TCollectionStreamer& c). protected:. voidInvalidProxyError(). private:. TCollectionStreamer&operator=(const TCollectionStreamer&). Data Members; protected:. TGenCollectionProxy*fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InvalidProxyError(); Issue Error about invalid proxy. TCollectionStreamer(); Initializing constructor. TCollectionStreamer(const TCollectionStreamer& c); Copy constructor. ~TCollectionStreamer(); Standard destructor. void AdoptStreamer(TGenCollectionProxy* streamer); Attach worker proxy. void Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); Streamer for I/O handling. TCollectionStreamer& operator=(const TCollectionStreamer& ).  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated:",MatchSource.WIKI,root/html602/TCollectionStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionStreamer.html
https://root.cern/root/html602/TCollectionStreamer.html:662,Security,access,access,662,". TCollectionStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionStreamer. class TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionStreamer(); voidAdoptStreamer(TGenCollectionProxy* streamer); voidStreamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionStreamer(); TCollectionStreamer(const TCollectionStreamer& c). protected:. voidInvalidProxyError(). private:. TCollectionStreamer&operator=(const TCollectionStreamer&). Data Members; protected:. TGenCollectionProxy*fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InvalidProxyError(); Issue Error about invalid proxy. TCollectionStreamer(); Initializing constructor. TCollectionStreamer(const TCollectionStreamer& c); Copy constructor. ~TCollectionStreamer(); Standard destructor. void AdoptStreamer(TGenCollectionProxy* streamer); Attach worker proxy. void Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); Streamer for I/O handling. TCollectionStreamer& operator=(const TCollectionStreamer& ).  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated:",MatchSource.WIKI,root/html602/TCollectionStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionStreamer.html
https://root.cern/root/html602/TCollectionStreamer.html:687,Security,Access,Access,687,". TCollectionStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionStreamer. class TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionStreamer(); voidAdoptStreamer(TGenCollectionProxy* streamer); voidStreamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionStreamer(); TCollectionStreamer(const TCollectionStreamer& c). protected:. voidInvalidProxyError(). private:. TCollectionStreamer&operator=(const TCollectionStreamer&). Data Members; protected:. TGenCollectionProxy*fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InvalidProxyError(); Issue Error about invalid proxy. TCollectionStreamer(); Initializing constructor. TCollectionStreamer(const TCollectionStreamer& c); Copy constructor. ~TCollectionStreamer(); Standard destructor. void AdoptStreamer(TGenCollectionProxy* streamer); Attach worker proxy. void Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); Streamer for I/O handling. TCollectionStreamer& operator=(const TCollectionStreamer& ).  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated:",MatchSource.WIKI,root/html602/TCollectionStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionStreamer.html
https://root.cern/root/html602/TCollectionStreamer.html:802,Usability,clear,clear,802,". TCollectionStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TCollectionStreamer. class TCollectionStreamer. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. The purpose of this implementation; is to shield any generated dictionary implementation from the; underlying streamer/proxy implementation and only expose; the creation functions. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TCollectionStreamer(); voidAdoptStreamer(TGenCollectionProxy* streamer); voidStreamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); TCollectionStreamer(); TCollectionStreamer(const TCollectionStreamer& c). protected:. voidInvalidProxyError(). private:. TCollectionStreamer&operator=(const TCollectionStreamer&). Data Members; protected:. TGenCollectionProxy*fStreamer/ Pointer to worker streamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InvalidProxyError(); Issue Error about invalid proxy. TCollectionStreamer(); Initializing constructor. TCollectionStreamer(const TCollectionStreamer& c); Copy constructor. ~TCollectionStreamer(); Standard destructor. void AdoptStreamer(TGenCollectionProxy* streamer); Attach worker proxy. void Streamer(TBuffer& refBuffer, void* obj, int siz, TClass* onFileClass); Streamer for I/O handling. TCollectionStreamer& operator=(const TCollectionStreamer& ).  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated:",MatchSource.WIKI,root/html602/TCollectionStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TCollectionStreamer.html
https://root.cern/root/html602/TColor.html:9063,Availability,avail,available,9063,"6 = gROOT->GetColor(26);; col26->SetAlpha(0.01);. A new color can be created transparent the following way:. Int_t ci = 1756;; TColor *color = new TColor(ci, 0.1, 0.2, 0.3, """", 0.5); // alpha = 0.5. An example of tranparency usage with parallel coordinates can be found; in $ROOTSYS/tutorials/tree/parallelcoordtrans.C. To ease the creation of a transparent color the static method; GetColorTransparent(Int_t color, Float_t a) is provided.; In the following example the trans_red color index point to; a red color 30% transparent. The alpha value of the color index; kRed is not modified. Int_t trans_red = GetColorTransparent(kRed, 0.3);. This function is also used in the methods; SetFillColorAlpha(), SetLineColorAlpha(),; SetMarkerColorAlpha() and SetTextColorAlpha().; In the following example the fill color of the histogram histo; is set to blue with a transparency of 35%. The color kBlue; itself remains fully opaque. histo->SetFillColorAlpha(kBlue, 0.35);. The transparency is available on all platforms when the flagOpenGL.CanvasPreferGL is set to 1; in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. On the file output; it is visible with PDF, PNG, Gif, JPEG, SVG ... but not PostScript.; . Function Members (Methods); public:. virtual~TColor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& color) const; static voidCreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidCreateColorsGray(); static voidCreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidCreateColorWheel(); static Int_tCreateGradientColorTable(UInt_t N",MatchSource.WIKI,root/html602/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TColor.html
https://root.cern/root/html602/TColor.html:10531,Availability,Error,Error,10531,,MatchSource.WIKI,root/html602/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TColor.html
