id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:52,Performance,load,load,52,// We also need to make sure it is safe to move the load.; // Assume there are stores between DefMI and UseMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:35,Safety,safe,safe,35,// We also need to make sure it is safe to move the load.; // Assume there are stores between DefMI and UseMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:3,Deployability,Update,Update,3,// Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:8,Performance,optimiz,optimize,8,"// Only optimize rematerialize case when the instruction has one def, since; // otherwise we could leave some dead defs in the code. This case is; // extremely rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:186,Integrability,depend,depend,186,"// The original live-range may have been shrunk to; // an empty live-range. It happens when it is dead, but; // we still keep it around to be able to rematerialize; // other values that depend on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp:44,Availability,down,down,44,"// OrderOld == OrderNew, we need to iterate down from Old to see if it; // can reach New, if yes, New is dominated by Old.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp:3,Deployability,Update,Update,3,// Update the dominator order to be the same as the insertion point.; // We do this to maintain a non-decreasing order without need to update; // all instruction orders after the insertion point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp:135,Deployability,update,update,135,// Update the dominator order to be the same as the insertion point.; // We do this to maintain a non-decreasing order without need to update; // all instruction orders after the insertion point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:14,Usability,clear,clear,14,"// No need to clear Queries here, since LiveIntervalUnion::Query doesn't; // have anything important to clear and LiveRegMatrix's runOnFunction(); // does a std::unique_ptr::reset anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:104,Usability,clear,clear,104,"// No need to clear Queries here, since LiveIntervalUnion::Query doesn't; // have anything important to clear and LiveRegMatrix's runOnFunction(); // does a std::unique_ptr::reset anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:16,Performance,cache,cached,16,// Check if the cached information is valid.; // The same BitVector can be reused for all PhysRegs.; // We could cache multiple VirtRegs if it becomes necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:113,Performance,cache,cache,113,// Check if the cached information is valid.; // The same BitVector can be reused for all PhysRegs.; // We could cache multiple VirtRegs if it becomes necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:15,Energy Efficiency,allocate,allocated,15,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:249,Energy Efficiency,allocate,allocated,249,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:40,Performance,cache,caches,40,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:304,Performance,cache,cached,304,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:462,Performance,cache,cached,462,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:518,Performance,cache,cache,518,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:497,Safety,avoid,avoid,497,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:610,Safety,avoid,avoid,610,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:655,Safety,Avoid,Avoiding,655,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:559,Usability,usab,usability,559,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:704,Usability,simpl,simplify,704,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegUnits.cpp:27,Usability,simpl,simply,27,// To get the live-outs we simply merge the live-ins of all successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegUnits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegUnits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveStacks.cpp:3,Deployability,Release,Release,3,"// Release VNInfo memory regions, VNInfo objects don't need to be dtor'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveStacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveStacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:1076,Energy Efficiency,efficient,efficiently,1076,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:33,Modifiability,Variab,Variable,33,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:817,Modifiability,variab,variables,817,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:922,Modifiability,variab,variable,922,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:1105,Modifiability,variab,variables,1105,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:65,Availability,alive,alive,65,// We already know the block is live; // Mark the variable known alive in this bb,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:50,Modifiability,variab,variable,50,// We already know the block is live; // Mark the variable known alive in this bb,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:314,Availability,alive,alive,314,"// This situation can occur:; //; // ,------.; // | |; // | v; // | t2 = phi ... t1 ...; // | |; // | v; // | t1 = ...; // | ... = ... t1 ...; // | |; // `------'; //; // where there is a use in a PHI node that's a predecessor to the defining; // block. We don't want to mark all predecessors as having the value ""alive""; // in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:96,Availability,alive,alive,96,"// Add a new kill entry for this basic block. If this virtual register is; // already marked as alive in this basic block, that means it is alive in at; // least one of the successor blocks, it's not a kill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:140,Availability,alive,alive,140,"// Add a new kill entry for this basic block. If this virtual register is; // already marked as alive in this basic block, that means it is alive in at; // least one of the successor blocks, it's not a kill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:3,Deployability,Update,Update,3,"// Update all dominating blocks to mark them as ""known live"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:16,Availability,alive,alive,16,"// If vr is not alive in any block, then defaults to dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:172,Modifiability,extend,extends,172,"// Partial uses. Mark register def dead and add implicit def of; // sub-registers which are used.; // dead EAX = op implicit-def AL; // That is, EAX def is dead but AL def extends pass it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:64,Availability,Mask,Mask,64,"// Call HandlePhysRegKill() for all live registers clobbered by Mask.; // Clobbered registers are always dead, sp there is no need to use; // HandlePhysRegDef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:8,Availability,mask,mask-preserved,8,// Skip mask-preserved regs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:55,Safety,avoid,avoids,55,// Kill the largest clobbered super-register.; // This avoids needless implicit operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:3,Usability,Clear,Clear,3,// Clear kill and dead markers. LV will recompute them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:15,Availability,mask,masked,15,// Process all masked registers. (Call clobbers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:11,Availability,alive,alive,11,// Mark it alive only in the block we are representing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:73,Availability,avail,available,73,"// Loop over PhysRegDef / PhysRegUse, killing any registers that are; // available at the end of the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:32,Deployability,update,updated,32,"// FIXME: LiveIntervals will be updated to remove its dependence on; // LiveVariables to improve compilation time and eliminate bizarre pass; // dependencies. Until then, we can't change much in -O0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:54,Integrability,depend,dependence,54,"// FIXME: LiveIntervals will be updated to remove its dependence on; // LiveVariables to improve compilation time and eliminate bizarre pass; // dependencies. Until then, we can't change much in -O0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:145,Integrability,depend,dependencies,145,"// FIXME: LiveIntervals will be updated to remove its dependence on; // LiveVariables to improve compilation time and eliminate bizarre pass; // dependencies. Until then, we can't change much in -O0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:18,Modifiability,variab,variable,18,"// Calculate live variable information in depth first order on the CFG of the; // function. This guarantees that we will see the definition of a virtual; // register before its uses due to dominance properties of SSA (except for PHI; // nodes, which are treated as a special case).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:46,Availability,Alive,AliveBlocks,46,// Iterate over the worklist adding blocks to AliveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:29,Deployability,Update,Update,29,/// replaceKillInstruction - Update register kill info by replacing a kill; /// instruction with a new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:109,Modifiability,variab,variable,109,"/// analyzePHINodes - Gather information about the PHI nodes in here. In; /// particular, we want to map the variable information of a virtual register; /// which is used in a PHI node. We map that to the BB the vreg is coming from.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:9,Availability,alive,alive,9,// Is it alive in this successor?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:85,Modifiability,variab,variables,85,/// addNewBlock - Add a new basic block BB as an empty succcessor to DomBB. All; /// variables that are live out of DomBB will be marked as passing live through; /// BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:3,Deployability,Update,Update,3,// Update info for all live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:28,Modifiability,variab,variables,28,// Update info for all live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:194,Deployability,update,updated,194,/// addNewBlock - Add a new basic block BB as an empty succcessor to DomBB. All; /// variables that are live out of DomBB will be marked as passing live through; /// BB. LiveInSets[BB] is *not* updated (because it is not needed during; /// PHIElimination).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:85,Modifiability,variab,variables,85,/// addNewBlock - Add a new basic block BB as an empty succcessor to DomBB. All; /// variables that are live out of DomBB will be marked as passing live through; /// BB. LiveInSets[BB] is *not* updated (because it is not needed during; /// PHIElimination).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:118,Integrability,depend,dependent,118,// FIXME: Having an MCSubtargetInfo on the target machine is a hack due; // to some backends having subtarget feature dependent module level; // code generation. This is similar to the hack in the AsmPrinter for; // module level assembly etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:202,Availability,error,error,202,"// TargetSelect.h moved to a different directory between LLVM 2.9 and 3.0,; // and if the old one gets included then MCAsmInfo will be NULL and; // we'll crash later.; // Provide the user with a useful error message about what's wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:208,Integrability,message,message,208,"// TargetSelect.h moved to a different directory between LLVM 2.9 and 3.0,; // and if the old one gets included then MCAsmInfo will be NULL and; // we'll crash later.; // Provide the user with a useful error message about what's wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:38,Deployability,integrat,integratedAS,38,"// If there is explict option disable integratedAS, we can't use it for; // inlineasm either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:38,Integrability,integrat,integratedAS,38,"// If there is explict option disable integratedAS, we can't use it for; // inlineasm either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:43,Performance,perform,performance,43,"// The Null output is intended for use for performance analysis and testing,; // not real users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:68,Testability,test,testing,68,"// The Null output is intended for use for performance analysis and testing,; // not real users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:19,Availability,redundant,redundant,19,// MIR printing is redundant with -filetype=null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:19,Safety,redund,redundant,19,// MIR printing is redundant with -filetype=null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:26,Performance,load,load,26,"// libunwind is unable to load compact unwind dynamically, so we must generate; // DWARF unwind info for the JIT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:42,Energy Efficiency,allocate,allocate,42,"//===- LocalStackSlotAllocation.cpp - Pre-allocate locals to stack slots --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass assigns local frame indices to stack slots relative to one another; // and allocates additional base registers to access them when the target; // estimates they are likely to be out of range of stack pointer and frame; // pointer relative addressing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:468,Energy Efficiency,allocate,allocates,468,"//===- LocalStackSlotAllocation.cpp - Pre-allocate locals to stack slots --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass assigns local frame indices to stack slots relative to one another; // and allocates additional base registers to access them when the target; // estimates they are likely to be out of range of stack pointer and frame; // pointer relative addressing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:507,Security,access,access,507,"//===- LocalStackSlotAllocation.cpp - Pre-allocate locals to stack slots --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass assigns local frame indices to stack slots relative to one another; // and allocates additional base registers to access them when the target; // estimates they are likely to be out of range of stack pointer and frame; // pointer relative addressing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:44,Energy Efficiency,allocate,allocated,44,"// Tell MFI whether any base registers were allocated. PEI will only; // want to use the local block allocations from this pass if there were any.; // Otherwise, PEI can do a bit better job of getting the alignment right; // without a hole at the start since it knows the alignment of the stack; // at the start of local allocation, and this pass doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:22,Availability,down,down,22,"// If the stack grows down, add the object size to find the lowest address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:19,Availability,avail,available,19,// Keep the offset available for base register allocation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:61,Modifiability,variab,variables,61,// Make sure that the stack protector comes before the local variables on the; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:38,Energy Efficiency,allocate,allocate,38,"// We need to make sure we didn't pre-allocate the stack protector when; // doing this.; // If we already have a stack protector, this will re-assign it to a slot; // that is **not** covering the protected objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:295,Energy Efficiency,allocate,allocated,295,"// Scan the function's instructions looking for frame index references.; // For each, ask the target if it wants a virtual base register for it; // based on what we can tell it about where the local will end up in the; // stack frame. If it wants one, re-use a suitable one we've previously; // allocated, or if there isn't one that fits the bill, allocate a new one; // and ask the target to create a defining instruction for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:348,Energy Efficiency,allocate,allocate,348,"// Scan the function's instructions looking for frame index references.; // For each, ask the target if it wants a virtual base register for it; // based on what we can tell it about where the local will end up in the; // stack frame. If it wants one, re-use a suitable one we've previously; // allocated, or if there isn't one that fits the bill, allocate a new one; // and ask the target to create a defining instruction for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:29,Deployability,patch,patchpoint,29,"// Debug value, stackmap and patchpoint instructions can't be out of; // range, so they don't need any updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:103,Deployability,update,updates,103,"// Debug value, stackmap and patchpoint instructions can't be out of; // range, so they don't need any updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:12,Energy Efficiency,allocate,allocate,12,"// For now, allocate the base register(s) within the basic block; // where they're used, and don't try to keep them around outside; // of that. It may be beneficial to try sharing them more broadly; // than that, but the increased register pressure makes that a; // tricky thing to balance. Investigate if re-materializing these; // becomes an issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:76,Energy Efficiency,allocate,allocated,76,// Consider replacing all frame index operands that reference; // an object allocated in the local block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:41,Energy Efficiency,allocate,allocate,41,// Loop through the frame references and allocate for them as necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:159,Safety,avoid,avoids,159,"// We need to keep the references to the stack protector slot through frame; // index operands so that it gets resolved by PEI rather than this pass.; // This avoids accesses to the stack protector though virtual base; // registers, and forces PEI to address it using fp/sp/bp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:166,Security,access,accesses,166,"// We need to keep the references to the stack protector slot through frame; // index operands so that it gets resolved by PEI rather than this pass.; // This avoids accesses to the stack protector though virtual base; // registers, and forces PEI to address it using fp/sp/bp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:39,Availability,avail,available,39,"// If we have a suitable base register available, use it; otherwise; // create a new one. Note that any offset encoded in the; // instruction itself will be taken into account by the target,; // so we don't have to adjust for it here when reusing a base; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:16,Safety,avoid,avoid,16,"// We'd like to avoid creating single-use virtual base registers.; // Because the FrameRefs are in sorted order, and we've already; // processed all FrameRefs before this one, just check whether or not; // the next FrameRef will be able to reuse this new register. If not,; // then don't bother creating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp:61,Deployability,update,updated,61,// N.B: IncomingProcessed and IncomingCompleted were already updated while; // processing this block's predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp:9,Deployability,update,update,9,// Don't update successors here. We'll get to them anyway through this; // loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:427,Integrability,depend,depending,427,"//===- LowerEmuTLS.cpp - Add __emutls_[vt].* variables --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is required for targets depending on libgcc style; // emulated thread local storage variables. For every defined TLS variable xyz,; // an __emutls_v.xyz is generated. If there is non-zero initialized value; // an __emutls_t.xyz is also generated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:45,Modifiability,variab,variables,45,"//===- LowerEmuTLS.cpp - Add __emutls_[vt].* variables --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is required for targets depending on libgcc style; // emulated thread local storage variables. For every defined TLS variable xyz,; // an __emutls_v.xyz is generated. If there is non-zero initialized value; // an __emutls_t.xyz is also generated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:487,Modifiability,variab,variables,487,"//===- LowerEmuTLS.cpp - Add __emutls_[vt].* variables --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is required for targets depending on libgcc style; // emulated thread local storage variables. For every defined TLS variable xyz,; // an __emutls_v.xyz is generated. If there is non-zero initialized value; // an __emutls_t.xyz is also generated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:520,Modifiability,variab,variable,520,"//===- LowerEmuTLS.cpp - Add __emutls_[vt].* variables --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is required for targets depending on libgcc style; // emulated thread local storage variables. For every defined TLS variable xyz,; // an __emutls_v.xyz is generated. If there is non-zero initialized value; // an __emutls_t.xyz is also generated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:112,Energy Efficiency,allocate,allocated,112,"// When GV's init value is all 0, omit the EmuTlsTmplVar and let; // the emutls library function to reset newly allocated TLS variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:126,Modifiability,variab,variables,126,"// When GV's init value is all 0, omit the EmuTlsTmplVar and let; // the emutls library function to reset newly allocated TLS variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowLevelType.cpp:463,Safety,avoid,avoid,463,"//===-- llvm/CodeGen/LowLevelType.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file implements the more header-heavy bits of the LLT class to; /// avoid polluting users' namespaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowLevelType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowLevelType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowLevelTypeUtils.cpp:463,Safety,avoid,avoid,463,"//===-- llvm/CodeGen/LowLevelTypeUtils.cpp --------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file implements the more header-heavy bits of the LLT class to; /// avoid polluting users' namespaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowLevelTypeUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowLevelTypeUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:289,Availability,avail,available,289,"/// When an MBB is added to an MF, we need to update the parent pointer of the; /// MBB, the MBB numbering, and any instructions in the MBB to be on the right; /// operand list for registers.; ///; /// MBBs start out as #-1. When a MBB is added to a MachineFunction, it; /// gets the next available unique MBB number. If it is removed from a; /// MachineFunction, it goes back to being #-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:46,Deployability,update,update,46,"/// When an MBB is added to an MF, we need to update the parent pointer of the; /// MBB, the MBB numbering, and any instructions in the MBB to be on the right; /// operand list for registers.; ///; /// MBBs start out as #-1. When a MBB is added to a MachineFunction, it; /// gets the next available unique MBB number. If it is removed from a; /// MachineFunction, it goes back to being #-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:57,Deployability,update,update,57,"/// When we add an instruction to a basic block list, we update its parent; /// pointer and add its operands from reg use/def lists if appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:62,Deployability,update,update,62,"/// When we remove an instruction from a basic block list, we update its parent; /// pointer and remove its operands from reg use/def lists if appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:86,Deployability,update,update,86,"/// When moving a range of instructions from one MBB list to another, we need to; /// update the parent pointers and the use/def lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:65,Deployability,update,update,65,"// If splicing between two blocks within the same function, just update the; // parent pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:109,Modifiability,rewrite,rewrite,109,"// The block has a non-fallthrough conditional branch. If one of its; // successors is its layout successor, rewrite it to a fallthrough; // conditional branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:92,Performance,optimiz,optimization,92,"// Probability list is either empty (if successor list isn't empty, this means; // disabled optimization) or has the same size as successor list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:138,Safety,safe,safely,138,"// We need to make sure probability list is either empty or has the same size; // of successor list. When this function is called, we can safely delete all; // probability in the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:71,Performance,optimiz,optimization,71,// If probability list is empty it means we don't use it (disabled; // optimization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:35,Deployability,Update,Update,35,// New is already a successor.; // Update its probability instead of adding a duplicate edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:71,Performance,optimiz,optimization,71,// If probability list is empty it means we don't use it (disabled; // optimization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:66,Deployability,update,update,66,// This is called before MI is inserted into block so defer index update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:112,Deployability,update,updated,112,"// On some targets like Mips, branches may kill virtual registers. Make sure; // that LiveVariables is properly updated after updateTerminator replaces the; // terminators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:126,Deployability,update,updateTerminator,126,"// On some targets like Mips, branches may kill virtual registers. Make sure; // that LiveVariables is properly updated after updateTerminator replaces the; // terminators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit live-ins from the successor,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update LiveVariables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update relevant live-through information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:106,Integrability,depend,depending,106,"// After splitting the edge and updating SlotIndexes, live intervals may be; // in one of two situations, depending on whether this block was the last in; // the function. If the original block was the last in the function, all; // live intervals will end prior to the beginning of the new split block. If; // the original block was not at the end of the function, all live intervals; // will extend to the end of the new split block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:393,Modifiability,extend,extend,393,"// After splitting the edge and updating SlotIndexes, live intervals may be; // in one of two situations, depending on whether this block was the last in; // the function. If the original block was the last in the function, all; // live intervals will end prior to the beginning of the new split block. If; // the original block was not at the end of the function, all live intervals; // will extend to the end of the new split block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update subranges with live values,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update all intervals for registers whose uses may have been modified by; // updateTerminator().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:79,Deployability,update,updateTerminator,79,// Update all intervals for registers whose uses may have been modified by; // updateTerminator().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:114,Deployability,update,updated,114,"// If one or the other blocks were not in a loop, the new block is not; // either, and thus LI doesn't need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:74,Availability,mask,mask,74,// Performance might be harmed on HW that implements branching using exec mask; // where both sides of the branches are always executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Performance,Perform,Performance,3,// Performance might be harmed on HW that implements branching using exec mask; // where both sides of the branches are always executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:60,Modifiability,rewrite,rewrite,60,// Do we have an Indirect jump with a jumptable that we can rewrite?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:18,Deployability,update,update,18,"// We may need to update this's terminator, but we can't do that if; // analyzeBranch fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:221,Performance,optimiz,optimized,221,"// Avoid bugpoint weirdness: A block may end with a conditional branch but; // jumps to the same MBB is either case. We have duplicate CFG edges in that; // case that we can't handle. Since this never happens in properly optimized; // code, just skip those edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Safety,Avoid,Avoid,3,"// Avoid bugpoint weirdness: A block may end with a conditional branch but; // jumps to the same MBB is either case. We have duplicate CFG edges in that; // case that we can't handle. Since this never happens in properly optimized; // code, just skip those edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update the successor information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:32,Safety,safe,safe,32,"// If we reached the end, it is safe to clobber Reg at the end of a block of; // no successor has it live in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:202,Availability,mask,mask,202,"// If we see a return block with successors, this must be a funclet return,; // which does not preserve any registers. If there are no successors, we don't; // care what kind of return it is, putting a mask after it is a no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockFrequencyInfo.cpp:399,Usability,simpl,simplified,399,"//===- MachineBlockFrequencyInfo.cpp - MBB Frequency Analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:1222,Energy Efficiency,schedul,schedules,1222,"//===- MachineBlockPlacement.cpp - Basic Block Code Layout optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements basic block placement transformations using the CFG; // structure and branch probability estimates.; //; // The pass strives to preserve the structure of the CFG (that is, retain; // a topological ordering of basic blocks) in the absence of a *strong* signal; // to the contrary from probabilities. However, within the CFG structure, it; // attempts to choose an ordering which favors placing more likely sequences of; // blocks adjacent to each other.; //; // The algorithm works from the inner-most loop within a function outward, and; // at each stage walks through the basic blocks, trying to coalesce them into; // sequential chains where allowed by the CFG (or demanded by heavy; // probabilities). Finally, it walks the blocks in topological order, and the; // first time it reaches a chain of basic blocks, it schedules them in the; // function in-order.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:59,Performance,optimiz,optimization,59,"//===- MachineBlockPlacement.cpp - Basic Block Code Layout optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements basic block placement transformations using the CFG; // structure and branch probability estimates.; //; // The pass strives to preserve the structure of the CFG (that is, retain; // a topological ordering of basic blocks) in the absence of a *strong* signal; // to the contrary from probabilities. However, within the CFG structure, it; // attempts to choose an ordering which favors placing more likely sequences of; // blocks adjacent to each other.; //; // The algorithm works from the inner-most loop within a function outward, and; // at each stage walks through the basic blocks, trying to coalesce them into; // sequential chains where allowed by the CFG (or demanded by heavy; // probabilities). Finally, it walks the blocks in topological order, and the; // first time it reaches a chain of basic blocks, it schedules them in the; // function in-order.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:557,Deployability,update,updated,557,"/// A chain of blocks which will be laid out contiguously.; ///; /// This is the datastructure representing a chain of consecutive blocks that; /// are profitable to layout together in order to maximize fallthrough; /// probabilities and code locality. We also can use a block chain to represent; /// a sequence of basic blocks which have some external (correctness); /// requirement for sequential layout.; ///; /// Chains can be built around a single basic block and can be merged to grow; /// them. They participate in a block-to-chain mapping, which is updated; /// automatically as chains are merged together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:120,Usability,simpl,simplify,120,"/// A handle to the function-wide basic block to block chain mapping.; ///; /// This is retained in each block chain to simplify the computation of child; /// block chains for SCC-formation and iteration. We store the edges to child; /// basic blocks, and map them back to their associated chains using this; /// structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:262,Availability,down,down,262,"/// Merge a block chain into this one.; ///; /// This routine merges a block chain into this one. It takes care of forming; /// a contiguous sequence of basic blocks, updating the edge list, and; /// updating the block -> chain mapping. It does not free or tear down the; /// old chain, but the old chain's block list is no longer valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:54,Integrability,rout,routine,54,"/// Merge a block chain into this one.; ///; /// This routine merges a block chain into this one. It takes care of forming; /// a contiguous sequence of basic blocks, updating the edge list, and; /// updating the block -> chain mapping. It does not free or tear down the; /// old chain, but the old chain's block list is no longer valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Deployability,Update,Update,3,"// Update the incoming blocks to point to this chain, and add them to the; // chain structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:96,Energy Efficiency,schedul,scheduled,96,"// NDEBUG; /// Count of predecessors of any block within the chain which have not; /// yet been scheduled. In general, we will delay scheduling this chain; /// until those predecessors are scheduled (or we find a sufficiently good; /// reason to override this heuristic.) Note that when forming loop chains,; /// blocks outside the loop are ignored and treated as if they were already; /// scheduled.; ///; /// Note: This field is reinitialized multiple times - once for each loop,; /// and then once for the function as a whole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:133,Energy Efficiency,schedul,scheduling,133,"// NDEBUG; /// Count of predecessors of any block within the chain which have not; /// yet been scheduled. In general, we will delay scheduling this chain; /// until those predecessors are scheduled (or we find a sufficiently good; /// reason to override this heuristic.) Note that when forming loop chains,; /// blocks outside the loop are ignored and treated as if they were already; /// scheduled.; ///; /// Note: This field is reinitialized multiple times - once for each loop,; /// and then once for the function as a whole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:189,Energy Efficiency,schedul,scheduled,189,"// NDEBUG; /// Count of predecessors of any block within the chain which have not; /// yet been scheduled. In general, we will delay scheduling this chain; /// until those predecessors are scheduled (or we find a sufficiently good; /// reason to override this heuristic.) Note that when forming loop chains,; /// blocks outside the loop are ignored and treated as if they were already; /// scheduled.; ///; /// Note: This field is reinitialized multiple times - once for each loop,; /// and then once for the function as a whole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:390,Energy Efficiency,schedul,scheduled,390,"// NDEBUG; /// Count of predecessors of any block within the chain which have not; /// yet been scheduled. In general, we will delay scheduling this chain; /// until those predecessors are scheduled (or we find a sufficiently good; /// reason to override this heuristic.) Note that when forming loop chains,; /// blocks outside the loop are ignored and treated as if they were already; /// scheduled.; ///; /// Note: This field is reinitialized multiple times - once for each loop,; /// and then once for the function as a whole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:37,Modifiability,variab,variable,37,/// Preferred loop exit.; /// Member variable for convenience. It may be removed by duplication deep; /// in the call stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:147,Energy Efficiency,reduce,reduce,147,"/// Allocator and owner of BlockChain structures.; ///; /// We build BlockChains lazily while processing the loop structure of; /// a function. To reduce malloc traffic, we allocate them using this; /// slab-like allocator, and destroy them after the pass completes. An; /// important guarantee is that this allocator produces stable pointers to; /// the chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:173,Energy Efficiency,allocate,allocate,173,"/// Allocator and owner of BlockChain structures.; ///; /// We build BlockChains lazily while processing the loop structure of; /// a function. To reduce malloc traffic, we allocate them using this; /// slab-like allocator, and destroy them after the pass completes. An; /// important guarantee is that this allocator produces stable pointers to; /// the chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:82,Energy Efficiency,efficient,efficiently,82,"/// Function wide BasicBlock to BlockChain mapping.; ///; /// This mapping allows efficiently moving from any given basic block to the; /// BlockChain it participates in, if any. We use it to, among other things,; /// allow implicitly defining edges between chains as the existing edges; /// between basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:126,Safety,safe,safely,126,"/// The set of basic blocks that have terminators that cannot be fully; /// analyzed. These basic blocks cannot be re-ordered safely by; /// MachineBlockPlacement, and we must preserve physical layout of these; /// blocks and their successors through the pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:33,Performance,optimiz,optimizing,33,/// Apply a post-processing step optimizing block placement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:68,Testability,log,logging,68,/// Helper to print the name of a MBB.; ///; /// Only used by debug logging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:126,Integrability,rout,routine,126,"/// Mark a chain's successors as having one fewer preds.; ///; /// When a chain is being merged into the ""placed"" chain, this routine will; /// quickly walk the successors of each block in the chain and mark them as; /// having one fewer active predecessor. It also adds any successors of this; /// chain which reach the zero-predecessor state to the appropriate worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:266,Usability,simpl,simplicity,266,"/// Compare 2 BlockFrequency's with a small penalty for \p A.; /// In order to be conservative, we apply a X% penalty to account for; /// increased icache pressure and static heuristics. For small frequencies; /// we use only the numerators to improve accuracy. For simplicity, we assume the; /// penalty is less than 100%; /// TODO(iteratee): Use 64-bit fixed point edge frequencies everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:6,Safety,avoid,avoid,6,// To avoid reviewing the same predecessors twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Performance,Perform,Perform,3,// Perform the successor check only once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:185,Usability,Simpl,Simple,185,"/// Pick the highest total weight pair of edges that can both be laid out.; /// The edges in \p Edges[0] are assumed to have a different destination than; /// the edges in \p Edges[1]. Simple counting shows that the best pair is either; /// the individual highest weight edges to the 2 different destinations, or in; /// case of a conflict, one of them should be replaced with a 2nd best edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:156,Usability,clear,clearly,156,"// Sort the edges, and then for each successor, find the best incoming; // predecessor. If the best incoming predecessors aren't the same,; // then that is clearly the best layout. If there is a conflict, one of the; // successors will have to fallthrough from the second best predecessor. We; // compare which combination is better overall.; // Sort for highest frequency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:1070,Modifiability,extend,extend,1070,"// This will result in a trellis after tail duplication, so we don't; // need to copy Succ into this predecessor. In the presence; // of a trellis tail duplication can continue to be profitable.; // For example:; // A A; // |\ |\; // | \ | \; // | C | C+BB; // | / | |; // |/ | |; // BB => BB |; // |\ |\/|; // | \ |/\|; // | D | D; // | / | /; // |/ |/; // Succ Succ; //; // After BB was duplicated into C, the layout looks like the one on the; // right. BB and C now have the same successors. When considering; // whether Succ can be duplicated into all its unplaced predecessors, we; // ignore C.; // We can do this because C already has a profitable fallthrough, namely; // D. TODO(iteratee): ignore sufficiently cold predecessors for; // duplication and for this test.; //; // This allows trellises to be laid out in 2 separate chains; // (A,B,Succ,...) and later (C,D,...) This is a reasonable heuristic; // because it allows the creation of 2 fallthrough paths with links; // between them, and we correctly identify the best layout for these; // CFGs. We want to extend trellises that the user created in addition; // to trellises created by tail-duplication, so we just look for the; // CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:768,Testability,test,test,768,"// This will result in a trellis after tail duplication, so we don't; // need to copy Succ into this predecessor. In the presence; // of a trellis tail duplication can continue to be profitable.; // For example:; // A A; // |\ |\; // | \ | \; // | C | C+BB; // | / | |; // |/ | |; // BB => BB |; // |\ |\/|; // | \ |/\|; // | D | D; // | / | /; // |/ |/; // Succ Succ; //; // After BB was duplicated into C, the layout looks like the one on the; // right. BB and C now have the same successors. When considering; // whether Succ can be duplicated into all its unplaced predecessors, we; // ignore C.; // We can do this because C already has a profitable fallthrough, namely; // D. TODO(iteratee): ignore sufficiently cold predecessors for; // duplication and for this test.; //; // This allows trellises to be laid out in 2 separate chains; // (A,B,Succ,...) and later (C,D,...) This is a reasonable heuristic; // because it allows the creation of 2 fallthrough paths with links; // between them, and we correctly identify the best layout for these; // CFGs. We want to extend trellises that the user created in addition; // to trellises created by tail-duplication, so we just look for the; // CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:29,Availability,avail,available,29,"// If profile information is available, findDuplicateCandidates can do more; // precise benefit analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:48,Deployability,integrat,integrated,48,// This is mainly for function exit BB.; // The integrated tail duplication is really designed for increasing; // fallthrough from predecessors from Succ to its successors. We may need; // other machanism to handle different cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:48,Integrability,integrat,integrated,48,// This is mainly for function exit BB.; // The integrated tail duplication is really designed for increasing; // fallthrough from predecessors from Succ to its successors. We may need; // other machanism to handle different cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:72,Modifiability,extend,extend,72,// Map from last block to the chain that contains it. This allows us to extend; // chains as we find new triangles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:32,Safety,safe,safe,32,"// Iterating over a DenseMap is safe here, because the only thing in the body; // of the loop is inserting into another DenseMap (ComputedEdges).; // ComputedEdges is never iterated, so this doesn't lead to non-determinism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Testability,Benchmark,Benchmarking,3,"// Benchmarking has shown that due to branch correlation duplicating 2 or; // more triangles is profitable, despite the calculations assuming; // independence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:81,Availability,avail,available,81,"// When profile is not present, return the StaticLikelyProb.; // When profile is available, we need to handle the triangle-shape CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:216,Testability,log,logging,216,"/// Checks to see if the layout candidate block \p Succ has a better layout; /// predecessor than \c BB. If yes, returns true.; /// \p SuccProb: The probability adjusted for only remaining blocks.; /// Only used for logging; /// \p RealSuccProb: The un-adjusted probability.; /// \p Chain: The chain that BB belongs to and Succ is being considered for.; /// \p BlockFilter: if non-null, the set of blocks that make up the loop being; /// considered",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:1131,Availability,avail,available,1131," | Pred; // | /; // Succ; // In this case, we are evaluating whether to select edge -> Succ, e.g.; // set Succ as the layout successor of BB. Picking Succ as BB's; // successor breaks the CFG constraints (FIXME: define these constraints).; // With this layout, Pred BB; // is forced to be outlined, so the overall cost will be cost of the; // branch taken from BB to Pred, plus the cost of back taken branch; // from Pred to Succ, as well as the additional cost associated; // with the needed unconditional jump instruction from Pred To Succ.; // The cost of the topological order layout is the taken branch cost; // from BB to Succ, so to make BB->Succ a viable candidate, the following; // must hold:; // 2 * freq(BB->Pred) * taken_branch_cost + unconditional_jump_cost; // < freq(BB->Succ) * taken_branch_cost.; // Ignoring unconditional jump cost, we get; // freq(BB->Succ) > 2 * freq(BB->Pred), i.e.,; // prob(BB->Succ) > 2 * prob(BB->Pred); //; // When real profile data is available, we can precisely compute the; // probability threshold that is needed for edge BB->Succ to be considered.; // Without profile data, the heuristic requires the branch bias to be; // a lot larger to make sure the signal is very strong (e.g. 80% default).; // -----------------------------------------------------------------; // Case 2: diamond like CFG (if-then-else):; // S; // / \; // | \; // BB Pred; // \ /; // Succ; // ..; //; // The current block is BB and edge BB->Succ is now being evaluated.; // Note that edge S->BB was previously already selected because; // prob(S->BB) > prob(S->Pred).; // At this point, 2 blocks can be placed after BB: Pred or Succ. If we; // choose Pred, we will have a topological ordering as shown on the left; // in the picture below. If we choose Succ, we have the solution as shown; // on the right:; //; // topo-order:; //; // S----- ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred-- | Succ--; // | | | |; // ---Succ ---Pred--; //; // cost = freq(S->Pred) + freq",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:2614,Availability,avail,available,2614,"ing evaluated.; // Note that edge S->BB was previously already selected because; // prob(S->BB) > prob(S->Pred).; // At this point, 2 blocks can be placed after BB: Pred or Succ. If we; // choose Pred, we will have a topological ordering as shown on the left; // in the picture below. If we choose Succ, we have the solution as shown; // on the right:; //; // topo-order:; //; // S----- ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred-- | Succ--; // | | | |; // ---Succ ---Pred--; //; // cost = freq(S->Pred) + freq(BB->Succ) cost = 2 * freq (S->Pred); // = freq(S->Pred) + freq(S->BB); //; // If we have profile data (i.e, branch probabilities can be trusted), the; // cost (number of taken branches) with layout S->BB->Succ->Pred is 2 *; // freq(S->Pred) while the cost of topo order is freq(S->Pred) + freq(S->BB).; // We know Prob(S->BB) > Prob(S->Pred), so freq(S->BB) > freq(S->Pred), which; // means the cost of topological order is greater.; // When profile data is not available, however, we need to be more; // conservative. If the branch prediction is wrong, breaking the topo-order; // will actually yield a layout with large cost. For this reason, we need; // strong biased branch at block S with Prob(S->BB) in order to select; // BB->Succ. This is equivalent to looking the CFG backward with backward; // edge: Prob(Succ->BB) needs to >= HotProb in order to be selected (without; // profile data).; // --------------------------------------------------------------------------; // Case 3: forked diamond; // S; // / \; // / \; // BB Pred; // | \ / |; // | \ / |; // | X |; // | / \ |; // | / \ |; // S1 S2; //; // The current block is BB and edge BB->S1 is now being evaluated.; // As above S->BB was already selected because; // prob(S->BB) > prob(S->Pred). Assume that prob(BB->S1) >= prob(BB->S2).; //; // topo-order:; //; // S-------| ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred----| | S1----; // | | | |; // --(S1 or S2) ---Pred--; // |; // S2; //; // topo-c",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:2685,Safety,predict,prediction,2685," prob(S->Pred).; // At this point, 2 blocks can be placed after BB: Pred or Succ. If we; // choose Pred, we will have a topological ordering as shown on the left; // in the picture below. If we choose Succ, we have the solution as shown; // on the right:; //; // topo-order:; //; // S----- ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred-- | Succ--; // | | | |; // ---Succ ---Pred--; //; // cost = freq(S->Pred) + freq(BB->Succ) cost = 2 * freq (S->Pred); // = freq(S->Pred) + freq(S->BB); //; // If we have profile data (i.e, branch probabilities can be trusted), the; // cost (number of taken branches) with layout S->BB->Succ->Pred is 2 *; // freq(S->Pred) while the cost of topo order is freq(S->Pred) + freq(S->BB).; // We know Prob(S->BB) > Prob(S->Pred), so freq(S->BB) > freq(S->Pred), which; // means the cost of topological order is greater.; // When profile data is not available, however, we need to be more; // conservative. If the branch prediction is wrong, breaking the topo-order; // will actually yield a layout with large cost. For this reason, we need; // strong biased branch at block S with Prob(S->BB) in order to select; // BB->Succ. This is equivalent to looking the CFG backward with backward; // edge: Prob(Succ->BB) needs to >= HotProb in order to be selected (without; // profile data).; // --------------------------------------------------------------------------; // Case 3: forked diamond; // S; // / \; // / \; // BB Pred; // | \ / |; // | \ / |; // | X |; // | / \ |; // | / \ |; // S1 S2; //; // The current block is BB and edge BB->S1 is now being evaluated.; // As above S->BB was already selected because; // prob(S->BB) > prob(S->Pred). Assume that prob(BB->S1) >= prob(BB->S2).; //; // topo-order:; //; // S-------| ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred----| | S1----; // | | | |; // --(S1 or S2) ---Pred--; // |; // S2; //; // topo-cost = freq(S->Pred) + freq(BB->S1) + freq(BB->S2); // + min(freq(Pred->S1), freq(Pred->S2)); // No",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:17,Availability,redundant,redundant,17,// This check is redundant except for look ahead. This function is; // called for lookahead by isProfitableToTailDup when BB hasn't been; // placed yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:17,Safety,redund,redundant,17,// This check is redundant except for look ahead. This function is; // called for lookahead by isProfitableToTailDup when BB hasn't been; // placed yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:444,Energy Efficiency,reduce,reduces,444,"// Do backward checking.; // For all cases above, we need a backward checking to filter out edges that; // are not 'strongly' biased.; // BB Pred; // \ /; // Succ; // We select edge BB->Succ if; // freq(BB->Succ) > freq(Succ) * HotProb; // i.e. freq(BB->Succ) > freq(BB->Succ) * HotProb + freq(Pred->Succ) *; // HotProb; // i.e. freq((BB->Succ) * (1 - HotProb) > freq(Pred->Succ) * HotProb; // Case 1 is covered too, because the first equation reduces to:; // prob(BB->Succ) > HotProb. (freq(Succ) = freq(BB) for a triangle)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:273,Safety,avoid,avoid,273,"/// Select the best successor for a block.; ///; /// This looks across all successors of a particular block and attempts to; /// select the ""best"" one to be the layout successor. It only considers direct; /// successors which also pass the block filter. It will attempt to avoid; /// breaking CFG structure, but cave and break such structures in the case of; /// very hot successor edges.; ///; /// \returns The best successor block found, or null if none are viable, along; /// with a boolean indicating if tail duplication is necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:130,Performance,perform,perform,130,"// For blocks with CFG violations, we may be able to lay them out anyway with; // tail-duplication. We keep this vector so we can perform the probability; // calculations the minimum number of times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:472,Performance,cache,cache,472,"/// Select the best block from a worklist.; ///; /// This looks through the provided worklist as a list of candidate basic; /// blocks and select the most profitable one to place. The definition of; /// profitable only really makes sense in the context of a loop. This returns; /// the most frequently visited block in the worklist, which in the case of; /// a loop, is the one most desirable to be physically close to the rest of the; /// loop body in order to improve i-cache behavior.; ///; /// \returns The best block found, or null if none are viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:55,Safety,avoid,avoid,55,"// For ehpad, we layout the least probable first as to avoid jumping back; // from least probable landingpads to more probable ones.; //; // FIXME: Using probability is probably (!) not the best way to achieve; // this. We should probably have a more principled approach to layout; // cleanup code.; //; // The goal is to get:; //; // +--------------------------+; // | V; // InnerLp -> InnerCleanup OuterLp -> OuterCleanup -> Resume; //; // Rather than:; //; // +-------------------------------------+; // V |; // OuterLp -> OuterCleanup -> Resume InnerLp -> InnerCleanup",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:427,Usability,Resume,Resume,427,"// For ehpad, we layout the least probable first as to avoid jumping back; // from least probable landingpads to more probable ones.; //; // FIXME: Using probability is probably (!) not the best way to achieve; // this. We should probably have a more principled approach to layout; // cleanup code.; //; // The goal is to get:; //; // +--------------------------+; // | V; // InnerLp -> InnerCleanup OuterLp -> OuterCleanup -> Resume; //; // Rather than:; //; // +-------------------------------------+; // V |; // OuterLp -> OuterCleanup -> Resume InnerLp -> InnerCleanup",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:542,Usability,Resume,Resume,542,"// For ehpad, we layout the least probable first as to avoid jumping back; // from least probable landingpads to more probable ones.; //; // FIXME: Using probability is probably (!) not the best way to achieve; // this. We should probably have a more principled approach to layout; // cleanup code.; //; // The goal is to get:; //; // +--------------------------+; // | V; // InnerLp -> InnerCleanup OuterLp -> OuterCleanup -> Resume; //; // Rather than:; //; // +-------------------------------------+; // V |; // OuterLp -> OuterCleanup -> Resume InnerLp -> InnerCleanup",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:309,Deployability,update,update,309,"/// Retrieve the first unplaced basic block.; ///; /// This routine is called when we are unable to use the CFG to walk through; /// all of the basic blocks and form a chain due to unnatural loops in the CFG.; /// We walk through the function's blocks in order, starting from the; /// LastUnplacedBlockIt. We update this iterator on each call to avoid; /// re-scanning the entire sequence on repeated calls to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:60,Integrability,rout,routine,60,"/// Retrieve the first unplaced basic block.; ///; /// This routine is called when we are unable to use the CFG to walk through; /// all of the basic blocks and form a chain due to unnatural loops in the CFG.; /// We walk through the function's blocks in order, starting from the; /// LastUnplacedBlockIt. We update this iterator on each call to avoid; /// re-scanning the entire sequence on repeated calls to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:415,Integrability,rout,routine,415,"/// Retrieve the first unplaced basic block.; ///; /// This routine is called when we are unable to use the CFG to walk through; /// all of the basic blocks and form a chain due to unnatural loops in the CFG.; /// We walk through the function's blocks in order, starting from the; /// LastUnplacedBlockIt. We update this iterator on each call to avoid; /// re-scanning the entire sequence on repeated calls to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:346,Safety,avoid,avoid,346,"/// Retrieve the first unplaced basic block.; ///; /// This routine is called when we are unable to use the CFG to walk through; /// all of the basic blocks and form a chain due to unnatural loops in the CFG.; /// We walk through the function's blocks in order, starting from the; /// LastUnplacedBlockIt. We update this iterator on each call to avoid; /// re-scanning the entire sequence on repeated calls to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:35,Availability,avail,available,35,"// If an immediate successor isn't available, look for the best viable; // block among those we've identified as not violating the loop's CFG at; // this point. This won't be a fallthrough, but it will increase locality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:365,Energy Efficiency,reduce,reduce,365,"// If bottom of block BB has only one successor OldTop, in most cases it is; // profitable to move it before OldTop, except the following case:; //; // -->OldTop<-; // | . |; // | . |; // | . |; // ---Pred |; // | |; // BB-----; //; // If BB is moved before OldTop, Pred needs a taken branch to BB, and it can't; // layout the other successor below it, so it can't reduce taken branch.; // In this case we keep its original layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:120,Energy Efficiency,reduce,reduced,120,"// Compute the fall through gains when move NewTop before OldTop.; //; // In following diagram, edges marked as ""-"" are reduced fallthrough, edges; // marked as ""+"" are increased fallthrough, this function computes; //; // SUM(increased fallthrough) - SUM(decreased fallthrough); //; // |; // | -; // V; // --->OldTop; // | .; // | .; // +| . +; // | Pred --->; // | |-; // | V; // --- NewTop <---; // |-; // V; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:905,Energy Efficiency,reduce,reduce,905,"/// Helper function of findBestLoopTop. Find the best loop top block; /// from predecessors of old top.; ///; /// Look for a block which is strictly better than the old top for laying; /// out before the old top of the loop. This looks for only two patterns:; ///; /// 1. a block has only one successor, the old loop top; ///; /// Because such a block will always result in an unconditional jump,; /// rotating it in front of the old top is always profitable.; ///; /// 2. a block has two successors, one is old top, another is exit; /// and it has more than one predecessors; ///; /// If it is below one of its predecessors P, only P can fall through to; /// it, all other predecessors need a jump to it, and another conditional; /// jump to loop header. If it is moved before loop header, all its; /// predecessors jump to it, then fall through to loop header. So all its; /// predecessors except P can reduce one taken branch.; /// At the same time, move it before old top increases the taken branch; /// to loop exit block, so the reduced taken branch will be compared with; /// the increased taken branch to the loop exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:1035,Energy Efficiency,reduce,reduced,1035,"/// Helper function of findBestLoopTop. Find the best loop top block; /// from predecessors of old top.; ///; /// Look for a block which is strictly better than the old top for laying; /// out before the old top of the loop. This looks for only two patterns:; ///; /// 1. a block has only one successor, the old loop top; ///; /// Because such a block will always result in an unconditional jump,; /// rotating it in front of the old top is always profitable.; ///; /// 2. a block has two successors, one is old top, another is exit; /// and it has more than one predecessors; ///; /// If it is below one of its predecessors P, only P can fall through to; /// it, all other predecessors need a jump to it, and another conditional; /// jump to loop header. If it is moved before loop header, all its; /// predecessors jump to it, then fall through to loop header. So all its; /// predecessors except P can reduce one taken branch.; /// At the same time, move it before old top increases the taken branch; /// to loop exit block, so the reduced taken branch will be compared with; /// the increased taken branch to the loop exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:159,Safety,avoid,avoid,159,"// Placing the latch block before the header may introduce an extra branch; // that skips this block the first time the loop is executed, which we want; // to avoid when optimising for size.; // FIXME: in theory there is a case that does not introduce a new branch,; // i.e. when the layout predecessor does not fallthrough to the loop header.; // In practice this never happens though: there always seems to be a preheader; // that can fallthrough and that is also placed before the header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:64,Integrability,rout,routine,64,/// Find the best loop exiting block for layout.; ///; /// This routine implements the logic to analyze the loop looking for the best; /// block to layout at the top of the loop. Typically this is done to maximize; /// fallthrough opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:87,Testability,log,logic,87,/// Find the best loop exiting block for layout.; ///; /// This routine implements the logic to analyze the loop looking for the best; /// block to layout at the top of the loop. Typically this is done to maximize; /// fallthrough opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:567,Safety,safe,safe,567,"// We don't want to layout the loop linearly in all cases. If the loop header; // is just a normal basic block in the loop, we want to look for what block; // within the loop is the best one to layout at the top. However, if the loop; // header has be pre-merged into a chain due to predecessors not having; // analyzable branches, *and* the predecessor it is merged with is *not* part; // of the loop, rotating the header into the middle of the loop will create; // a non-contiguous range of blocks which is Very Bad. So start with the; // header and only rotate if safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:681,Safety,avoid,avoid,681,"// Rotating a loop exit to the bottom when there is a fallthrough to top; // trades the entry fallthrough for an exit fallthrough.; // If there is no bottom->top edge, but the chosen exit block does have; // a fallthrough, we break that fallthrough for nothing in return.; // Let's consider an example. We have a built chain of basic blocks; // B1, B2, ..., Bn, where Bk is a ExitingBB - chosen exit block.; // By doing a rotation we get; // Bk+1, ..., Bn, B1, ..., Bk; // Break of fallthrough to B1 is compensated by a fallthrough from Bk.; // If we had a fallthrough Bk -> Bk+1 it is broken now.; // It might be compensated by fallthrough Bn -> B1.; // So we have a condition to avoid creation of extra branch by loop rotation.; // All below must be true to avoid loop rotation:; // If there is a fallthrough to top (B1); // There was fallthrough from chosen exit block (Bk) to next one (Bk+1); // There is no fallthrough from bottom (Bn) to top (B1).; // Please note that there is no exit fallthrough from Bn because we checked it; // above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:760,Safety,avoid,avoid,760,"// Rotating a loop exit to the bottom when there is a fallthrough to top; // trades the entry fallthrough for an exit fallthrough.; // If there is no bottom->top edge, but the chosen exit block does have; // a fallthrough, we break that fallthrough for nothing in return.; // Let's consider an example. We have a built chain of basic blocks; // B1, B2, ..., Bn, where Bk is a ExitingBB - chosen exit block.; // By doing a rotation we get; // Bk+1, ..., Bn, B1, ..., Bk; // Break of fallthrough to B1 is compensated by a fallthrough from Bk.; // If we had a fallthrough Bk -> Bk+1 it is broken now.; // It might be compensated by fallthrough Bn -> B1.; // So we have a condition to avoid creation of extra branch by loop rotation.; // All below must be true to avoid loop rotation:; // If there is a fallthrough to top (B1); // There was fallthrough from chosen exit block (Bk) to next one (Bk+1); // There is no fallthrough from bottom (Bn) to top (B1).; // Please note that there is no exit fallthrough from Bn because we checked it; // above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:54,Energy Efficiency,reduce,reduce,54,"/// Attempt to rotate a loop based on profile data to reduce branch cost.; ///; /// With profile data, we can determine the cost in terms of missed fall through; /// opportunities when rotating a loop chain and select the best rotation.; /// Basically, there are three kinds of cost to consider for each rotation:; /// 1. The possibly missed fall through edge (if it exists) from BB out of; /// the loop to the loop header.; /// 2. The possibly missed fall through edges (if they exist) from the loop; /// exits to BB out of the loop.; /// 3. The missed fall through edge (if it exists) from the last BB to the; /// first BB in the loop chain.; /// Therefore, the cost for a given rotation is the sum of costs listed above.; /// We select the best rotation with the smallest cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:91,Availability,avail,available,91,"/// Collect blocks in the given loop that are to be placed.; ///; /// When profile data is available, exclude cold blocks from the returned set;; /// otherwise, collect all blocks in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:65,Availability,avail,available,65,"// Filter cold blocks off from LoopBlockSet when profile data is available.; // Collect the sum of frequencies of incoming edges to the loop header from; // outside. If we treat the loop as a super block, this is the frequency of; // the loop. Then for each block in the loop, we calculate the ratio between; // its frequency and the frequency of the loop block. When it is too small,; // don't add it to the loop chain. If there are outer loops, then this block; // will be merged into the first outer loop chain for which this block is not; // cold anymore. This needs precise profile data and we only do this when; // profile data is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:637,Availability,avail,available,637,"// Filter cold blocks off from LoopBlockSet when profile data is available.; // Collect the sum of frequencies of incoming edges to the loop header from; // outside. If we treat the loop as a super block, this is the frequency of; // the loop. Then for each block in the loop, we calculate the ratio between; // its frequency and the frequency of the loop block. When it is too small,; // don't add it to the loop chain. If there are outer loops, then this block; // will be merged into the first outer loop chain for which this block is not; // cold anymore. This needs precise profile data and we only do this when; // profile data is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:268,Usability,clear,clear,268,"// If we selected just the header for the loop top, look for a potentially; // profitable exit block in the event that rotating the loop can eliminate; // branches by placing an exit edge at the bottom.; //; // Loops are processed innermost to uttermost, make sure we clear; // PreferredLoopExit before processing a new loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:67,Usability,simpl,simplify,67,// Ensure that every BB in the function has an associated chain to simplify; // the assumptions of the remaining algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:48,Deployability,update,update,48,"// Remember original layout ordering, so we can update terminators after; // reordering to point to the original layout successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Deployability,Update,Update,3,// Update the terminator of the previous block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:33,Deployability,update,updateTerminator,33,// FIXME: It would be awesome of updateTerminator would just return rather; // than assert when the branch cannot be analyzed in order to remove this; // boiler plate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:84,Testability,assert,assert,84,// FIXME: It would be awesome of updateTerminator would just return rather; // than assert when the branch cannot be analyzed in order to remove this; // boiler plate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:27,Deployability,update,updated,27,"// The ""PrevBB"" is not yet updated to reflect current code layout, so,; // o. it may fall-through to a block without explicit ""goto"" instruction; // before layout, and no longer fall-through it after layout; or; // o. just opposite.; //; // analyzeBranch() may return erroneous value for FBB when these two; // situations take place. For the first scenario FBB is mistakenly set NULL;; // for the 2nd scenario, the FBB, which is expected to be NULL, is; // mistakenly pointing to ""*BI"".; // Thus, if the future change needs to use FBB before the layout is set, it; // has to correct FBB first by using the code similar to the following:; //; // if (!Cond.empty() && (!FBB || FBB == ChainBB)) {; // PrevBB->updateTerminator();; // Cond.clear();; // TBB = FBB = nullptr;; // if (TII->analyzeBranch(*PrevBB, TBB, FBB, Cond)) {; // // FIXME: This should never take place.; // TBB = FBB = nullptr;; // }; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:706,Deployability,update,updateTerminator,706,"// The ""PrevBB"" is not yet updated to reflect current code layout, so,; // o. it may fall-through to a block without explicit ""goto"" instruction; // before layout, and no longer fall-through it after layout; or; // o. just opposite.; //; // analyzeBranch() may return erroneous value for FBB when these two; // situations take place. For the first scenario FBB is mistakenly set NULL;; // for the 2nd scenario, the FBB, which is expected to be NULL, is; // mistakenly pointing to ""*BI"".; // Thus, if the future change needs to use FBB before the layout is set, it; // has to correct FBB first by using the code similar to the following:; //; // if (!Cond.empty() && (!FBB || FBB == ChainBB)) {; // PrevBB->updateTerminator();; // Cond.clear();; // TBB = FBB = nullptr;; // if (TII->analyzeBranch(*PrevBB, TBB, FBB, Cond)) {; // // FIXME: This should never take place.; // TBB = FBB = nullptr;; // }; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:735,Usability,clear,clear,735,"// The ""PrevBB"" is not yet updated to reflect current code layout, so,; // o. it may fall-through to a block without explicit ""goto"" instruction; // before layout, and no longer fall-through it after layout; or; // o. just opposite.; //; // analyzeBranch() may return erroneous value for FBB when these two; // situations take place. For the first scenario FBB is mistakenly set NULL;; // for the 2nd scenario, the FBB, which is expected to be NULL, is; // mistakenly pointing to ""*BI"".; // Thus, if the future change needs to use FBB before the layout is set, it; // has to correct FBB first by using the code similar to the following:; //; // if (!Cond.empty() && (!FBB || FBB == ChainBB)) {; // PrevBB->updateTerminator();; // Cond.clear();; // TBB = FBB = nullptr;; // if (TII->analyzeBranch(*PrevBB, TBB, FBB, Cond)) {; // // FIXME: This should never take place.; // TBB = FBB = nullptr;; // }; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:192,Performance,optimiz,optimize,192,"// For analyzeBranch.; // Now that all the basic blocks in the chain have the proper layout,; // make a final call to analyzeBranch with AllowModify set.; // Indeed, the target may be able to optimize the branches in a way we; // cannot because all branches may not be analyzable.; // E.g., the target may be able to remove an unconditional branch to; // a fallthrough when it occurs after predicated terminators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:252,Deployability,Update,Updated,252,"/// Tail duplicate \p BB into (some) predecessors if profitable, repeating if; /// it was duplicated into its chain predecessor and removed.; /// \p BB - Basic block that may be duplicated.; ///; /// \p LPred - Chosen layout predecessor of \p BB.; /// Updated to be the chain end if LPred is removed.; /// \p Chain - Chain to which \p LPred belongs, and \p BB will belong.; /// \p BlockFilter - Set of blocks that belong to the loop being laid out.; /// Used to identify which blocks to update predecessor; /// counts.; /// \p PrevUnplacedBlockIt - Iterator pointing to the last block that was; /// chosen in the given order due to unnatural CFG; /// only needed if \p BB is removed and; /// \p PrevUnplacedBlockIt pointed to \p BB.; /// @return true if \p BB was removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:487,Deployability,update,update,487,"/// Tail duplicate \p BB into (some) predecessors if profitable, repeating if; /// it was duplicated into its chain predecessor and removed.; /// \p BB - Basic block that may be duplicated.; ///; /// \p LPred - Chosen layout predecessor of \p BB.; /// Updated to be the chain end if LPred is removed.; /// \p Chain - Chain to which \p LPred belongs, and \p BB will belong.; /// \p BlockFilter - Set of blocks that belong to the loop being laid out.; /// Used to identify which blocks to update predecessor; /// counts.; /// \p PrevUnplacedBlockIt - Iterator pointing to the last block that was; /// chosen in the given order due to unnatural CFG; /// only needed if \p BB is removed and; /// \p PrevUnplacedBlockIt pointed to \p BB.; /// @return true if \p BB was removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:254,Energy Efficiency,schedul,scheduled,254,"// Iteratively try to duplicate again. It can happen that a block that is; // duplicated into is still small enough to be duplicated again.; // No need to call markBlockSuccessors in this case, as the blocks being; // duplicated from here on are already scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:49,Deployability,update,updated,49,"// The removal callback causes Chain.end() to be updated when a block is; // removed. On the first pass through the loop, the chain end should be the; // same as it was on function entry. On subsequent passes, because we are; // duplicating the block at the end of the chain, if it is removed the; // chain will have shrunk by one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:46,Energy Efficiency,schedul,scheduled,46,"// If BB was duplicated into LPred, it is now scheduled. But because it was; // removed, markChainSuccessors won't be called for its chain. Instead we; // call markBlockSuccessors for LPred to achieve the same effect. This must go; // at the end because repeating the tail duplication can increase the number; // of unscheduled predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:350,Deployability,update,update,350,"/// Tail duplicate \p BB into (some) predecessors if profitable.; /// \p BB - Basic block that may be duplicated; /// \p LPred - Chosen layout predecessor of \p BB; /// \p Chain - Chain to which \p LPred belongs, and \p BB will belong.; /// \p BlockFilter - Set of blocks that belong to the loop being laid out.; /// Used to identify which blocks to update predecessor; /// counts.; /// \p PrevUnplacedBlockIt - Iterator pointing to the last block that was; /// chosen in the given order due to unnatural CFG; /// only needed if \p BB is removed and; /// \p PrevUnplacedBlockIt pointed to \p BB.; /// \p DuplicatedToLPred - True if the block was duplicated into LPred.; /// \return - True if the block was duplicated into all preds and removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Deployability,Update,Update,3,// Update UnscheduledPredecessors to reflect tail-duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:167,Availability,avail,available,167,"// The size cost of duplication is the instruction size of the duplicated block.; // So we should scale the threshold accordingly. But the instruction size is not; // available on all targets, so we use the number of instructions instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:25,Energy Efficiency,reduce,reduced,25,// Compute the number of reduced taken branches if Pred falls through to BB; // instead of another successor. Then compare it with threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:929,Availability,avail,available,929,"// For each predecessors of BB, compute the benefit of duplicating BB,; // if it is larger than the threshold, add it into Candidates.; //; // If we have following control flow.; //; // PB1 PB2 PB3 PB4; // \ | / /\; // \ | / / \; // \ |/ / \; // BB----/ OB; // /\; // / \; // SB1 SB2; //; // And it can be partially duplicated as; //; // PB2+BB; // | PB1 PB3 PB4; // | | / /\; // | | / / \; // | |/ / \; // | BB----/ OB; // |\ /|; // | X |; // |/ \|; // SB2 SB1; //; // The benefit of duplicating into a predecessor is defined as; // Orig_taken_branch - Duplicated_taken_branch; //; // The Orig_taken_branch is computed with the assumption that predecessor; // jumps to BB and the most possible successor is laid out after BB.; //; // The Duplicated_taken_branch is computed with the assumption that BB is; // duplicated into PB, and one successor is layout after it (SB1 for PB1 and; // SB2 for PB2 in our case). If there is no available successor, the combined; // block jumps to all BB's successor, like PB3 in this example.; //; // If a predecessor has multiple successors, so BB can't be duplicated into; // it. But it can beneficially fall through to BB, and duplicate BB into other; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:24,Availability,avail,available,24,"// Profile count is not available, we can use block frequency instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:18,Performance,optimiz,optimization,18,"// For aggressive optimization, we can adjust some thresholds to be less; // conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:27,Performance,optimiz,optimizing,27,// Apply a post-processing optimizing block placement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:38,Performance,optimiz,optimizeBranches,38,// Re-create CFG chain so that we can optimizeBranches and alignBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:178,Integrability,depend,dependent,178,"// Getting the block size:; // - approximate the size of an instruction by 4 bytes, and; // - ignore debug instructions.; // Note: getting the exact size of each block is target-dependent and can be; // done by extending the interface of MCCodeEmitter. Experimentally we do; // not see a perf improvement with the exact block sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:225,Integrability,interface,interface,225,"// Getting the block size:; // - approximate the size of an instruction by 4 bytes, and; // - ignore debug instructions.; // Note: getting the exact size of each block is target-dependent and can be; // done by extending the interface of MCCodeEmitter. Experimentally we do; // not see a perf improvement with the exact block sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:211,Modifiability,extend,extending,211,"// Getting the block size:; // - approximate the size of an instruction by 4 bytes, and; // - ignore debug instructions.; // Note: getting the exact size of each block is target-dependent and can be; // done by extending the interface of MCCodeEmitter. Experimentally we do; // not see a perf improvement with the exact block sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Deployability,Update,Update,3,// Update basic block branches by inserting explicit fallthrough branches; // when required and re-optimize branches when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:99,Performance,optimiz,optimize,99,// Update basic block branches by inserting explicit fallthrough branches; // when required and re-optimize branches when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:27,Performance,optimiz,optimize,27,// It might be possible to optimize branches by flipping the condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:487,Security,integrity,integrity,487,"//===- MachineCheckDebugify.cpp - Check debug info ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This checks debug info after mir-debugify (+ pass-to-test). Currently; /// it simply checks the integrity of line info in DILocation and; /// DILocalVariable which mir-debugifiy generated before.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:444,Testability,test,test,444,"//===- MachineCheckDebugify.cpp - Check debug info ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This checks debug info after mir-debugify (+ pass-to-test). Currently; /// it simply checks the integrity of line info in DILocation and; /// DILocalVariable which mir-debugifiy generated before.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:469,Usability,simpl,simply,469,"//===- MachineCheckDebugify.cpp - Check debug info ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This checks debug info after mir-debugify (+ pass-to-test). Currently; /// it simply checks the integrity of line info in DILocation and; /// DILocalVariable which mir-debugifiy generated before.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:33,Safety,Avoid,Avoid,33,// Find missing lines.; // TODO: Avoid meta instructions other than dbg_val.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:16,Modifiability,variab,variables,16,// Find missing variables.; // TODO: Handle DBG_INSTR_REF which is under an experimental option now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:12,Performance,optimiz,optimizing,12,/// True if optimizing for code size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:253,Integrability,depend,dependent,253,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:25,Performance,latency,latency,25,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:43,Performance,latency,latency,43,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:197,Performance,latency,latency,197,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:362,Performance,latency,latency,362,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:459,Performance,Latency,Latency,459,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:52,Performance,latency,latency,52,// Check each definition in NewRoot and compute the latency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:83,Performance,optimiz,optimize,83,/// The combiner's goal may differ based on which pattern it is attempting; /// to optimize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:12,Integrability,depend,dependency,12,// The data dependency chain must be improved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:33,Energy Efficiency,reduce,reduced,33,// The register pressure must be reduced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:210,Integrability,depend,dependent,210,"/// Estimate the latency of the new and original instruction sequence by summing; /// up the latencies of the inserted and deleted instructions. This assumes; /// that the inserted and deleted instructions are dependent instruction chains,; /// which might not hold in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:17,Performance,latency,latency,17,"/// Estimate the latency of the new and original instruction sequence by summing; /// up the latencies of the inserted and deleted instructions. This assumes; /// that the inserted and deleted instructions are dependent instruction chains,; /// which might not hold in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:347,Integrability,depend,dependency,347,"/// The DAGCombine code sequence ends in MI (Machine Instruction) Root.; /// The new code sequence ends in MI NewRoot. A necessary condition for the new; /// sequence to replace the old sequence is that it cannot lengthen the critical; /// path. The definition of ""improve"" may be restricted by specifying that the; /// new path improves the data dependency chain (MustReduceDepth).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:17,Performance,latency,latency,17,// Get depth and latency of NewRoot and Root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:137,Integrability,depend,dependency,137,"// For a transform such as reassociation, the cost equation is; // conservatively calculated so that we must improve the depth (data; // dependency cycles) in the critical path to proceed with the transform.; // Being conservative also protects against inaccuracies in the underlying; // machine trace metrics and CPU models.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:193,Integrability,depend,dependency,193,// A more flexible cost calculation for the critical path includes the slack; // of the original code sequence. This may allow the transform to proceed; // even if the instruction depths (data dependency cycles) become worse.; // Account for the latency of the inserted and deleted instructions by,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:10,Modifiability,flexible,flexible,10,// A more flexible cost calculation for the critical path includes the slack; // of the original code sequence. This may allow the transform to proceed; // even if the instruction depths (data dependency cycles) become worse.; // Account for the latency of the inserted and deleted instructions by,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:246,Performance,latency,latency,246,// A more flexible cost calculation for the critical path includes the slack; // of the original code sequence. This may allow the transform to proceed; // even if the instruction depths (data dependency cycles) become worse.; // Account for the latency of the inserted and deleted instructions by,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:11,Integrability,rout,routine,11,/// helper routine to convert instructions into SC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:59,Deployability,update,updates,59,"/// Inserts InsInstrs and deletes DelInstrs. Incrementally updates instruction; /// depths if requested.; ///; /// \param MBB basic block to insert instructions in; /// \param MI current machine instruction; /// \param InsInstrs new instructions to insert in \p MBB; /// \param DelInstrs instruction to delete from \p MBB; /// \param TraceEnsemble is a pointer to the machine trace information; /// \param RegUnits set of live registers, needed to compute instruction depths; /// \param TII is target instruction info, used to call target hook; /// \param Pattern is used to call target hook finalizeInsInstrs; /// \param IncrementalUpdate if true, compute instruction depths incrementally,; /// otherwise invalidate the trace",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:54,Performance,latency,latency,54,// Check that the difference between original and new latency is decreasing for; // later patterns. This helps to discover sub-optimal pattern orderings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:3,Modifiability,Variab,Variable,3,// Variable is used in assert only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:23,Testability,assert,assert,23,// Variable is used in assert only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:163,Performance,Perform,Performs,163,/// Substitute a slow code sequence with a faster one by; /// evaluating instruction combining pattern.; /// The prototype of such a pattern is MUl + ADD -> MADD. Performs instruction; /// combining based on machine trace metrics. Only combine a sequence of; /// instructions when this neither lengthens the critical path nor increases; /// resource pressure. When optimizing for codesize always combine when the new; /// sequence is shorter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:365,Performance,optimiz,optimizing,365,/// Substitute a slow code sequence with a faster one by; /// evaluating instruction combining pattern.; /// The prototype of such a pattern is MUl + ADD -> MADD. Performs instruction; /// combining based on machine trace metrics. Only combine a sequence of; /// instructions when this neither lengthens the critical path nor increases; /// resource pressure. When optimizing for codesize always combine when the new; /// sequence is shorter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:272,Performance,perform,performance,272,"// The motivating example is:; //; // MUL Other MUL_op1 MUL_op2 Other; // \ / \ | /; // ADD/SUB => MADD/MSUB; // (=Root) (=NewRoot); // The DAGCombine code always replaced MUL + ADD/SUB by MADD. While this is; // usually beneficial for code size it unfortunately can hurt performance; // when the ADD is on the critical path, but the MUL is not. With the; // substitution the MUL becomes part of the critical path (in form of the; // MADD) and can lengthen it on architectures where the MADD latency is; // longer than the ADD latency.; //; // For each instruction we check if it can be the root of a combiner; // pattern. Then for each pattern the new code sequence in form of MI is; // generated and evaluated. When the efficiency criteria (don't lengthen; // critical path, don't use more resources) is met the new sequence gets; // hooked up into the basic block before the old sequence is removed.; //; // The algorithm does not try to evaluate all patterns and pick the best.; // This is only an artificial restriction though. In practice there is; // mostly one pattern, and getMachineCombinerPatterns() can order patterns; // based on an internal cost heuristic. If; // machine-combiner-verify-pattern-order is enabled, all patterns are; // checked to ensure later patterns do not provide better latency savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:492,Performance,latency,latency,492,"// The motivating example is:; //; // MUL Other MUL_op1 MUL_op2 Other; // \ / \ | /; // ADD/SUB => MADD/MSUB; // (=Root) (=NewRoot); // The DAGCombine code always replaced MUL + ADD/SUB by MADD. While this is; // usually beneficial for code size it unfortunately can hurt performance; // when the ADD is on the critical path, but the MUL is not. With the; // substitution the MUL becomes part of the critical path (in form of the; // MADD) and can lengthen it on architectures where the MADD latency is; // longer than the ADD latency.; //; // For each instruction we check if it can be the root of a combiner; // pattern. Then for each pattern the new code sequence in form of MI is; // generated and evaluated. When the efficiency criteria (don't lengthen; // critical path, don't use more resources) is met the new sequence gets; // hooked up into the basic block before the old sequence is removed.; //; // The algorithm does not try to evaluate all patterns and pick the best.; // This is only an artificial restriction though. In practice there is; // mostly one pattern, and getMachineCombinerPatterns() can order patterns; // based on an internal cost heuristic. If; // machine-combiner-verify-pattern-order is enabled, all patterns are; // checked to ensure later patterns do not provide better latency savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:527,Performance,latency,latency,527,"// The motivating example is:; //; // MUL Other MUL_op1 MUL_op2 Other; // \ / \ | /; // ADD/SUB => MADD/MSUB; // (=Root) (=NewRoot); // The DAGCombine code always replaced MUL + ADD/SUB by MADD. While this is; // usually beneficial for code size it unfortunately can hurt performance; // when the ADD is on the critical path, but the MUL is not. With the; // substitution the MUL becomes part of the critical path (in form of the; // MADD) and can lengthen it on architectures where the MADD latency is; // longer than the ADD latency.; //; // For each instruction we check if it can be the root of a combiner; // pattern. Then for each pattern the new code sequence in form of MI is; // generated and evaluated. When the efficiency criteria (don't lengthen; // critical path, don't use more resources) is met the new sequence gets; // hooked up into the basic block before the old sequence is removed.; //; // The algorithm does not try to evaluate all patterns and pick the best.; // This is only an artificial restriction though. In practice there is; // mostly one pattern, and getMachineCombinerPatterns() can order patterns; // based on an internal cost heuristic. If; // machine-combiner-verify-pattern-order is enabled, all patterns are; // checked to ensure later patterns do not provide better latency savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:1304,Performance,latency,latency,1304,"// The motivating example is:; //; // MUL Other MUL_op1 MUL_op2 Other; // \ / \ | /; // ADD/SUB => MADD/MSUB; // (=Root) (=NewRoot); // The DAGCombine code always replaced MUL + ADD/SUB by MADD. While this is; // usually beneficial for code size it unfortunately can hurt performance; // when the ADD is on the critical path, but the MUL is not. With the; // substitution the MUL becomes part of the critical path (in form of the; // MADD) and can lengthen it on architectures where the MADD latency is; // longer than the ADD latency.; //; // For each instruction we check if it can be the root of a combiner; // pattern. Then for each pattern the new code sequence in form of MI is; // generated and evaluated. When the efficiency criteria (don't lengthen; // critical path, don't use more resources) is met the new sequence gets; // hooked up into the basic block before the old sequence is removed.; //; // The algorithm does not try to evaluate all patterns and pick the best.; // This is only an artificial restriction though. In practice there is; // mostly one pattern, and getMachineCombinerPatterns() can order patterns; // based on an internal cost heuristic. If; // machine-combiner-verify-pattern-order is enabled, all patterns are; // checked to ensure later patterns do not provide better latency savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:3,Deployability,Update,Update,3,// Update depths since the last incremental update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:44,Deployability,update,update,44,// Update depths since the last incremental update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:25,Deployability,update,updates,25,// Use incremental depth updates for basic blocks above threshold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:132,Deployability,update,update,132,"// For big basic blocks, we only compute the full trace the first time; // we hit this. We do not invalidate the trace, but instead update the; // instruction depths incrementally.; // NOTE: Only the instruction depths up to MI are accurate. All other; // trace information is not updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:281,Deployability,update,updated,281,"// For big basic blocks, we only compute the full trace the first time; // we hit this. We do not invalidate the trace, but instead update the; // instruction depths incrementally.; // NOTE: Only the instruction depths up to MI are accurate. All other; // trace information is not updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:25,Deployability,update,updates,25,// Use incremental depth updates for basic blocks above treshold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:946,Availability,redundant,redundant,946,"//===- MachineCopyPropagation.cpp - Machine Copy Propagation Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is an extremely simple MachineInstr-level copy propagation pass.; //; // This pass forwards the source of COPYs to the users of their destinations; // when doing so is legal. For example:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg1; //; // If; // - %reg0 has not been clobbered by the time of the use of %reg1; // - the register class constraints are satisfied; // - the COPY def is the only value that reaches OP; // then this pass replaces the above with:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg0; //; // This pass also removes some redundant COPYs. For example:; //; // %R1 = COPY %R0; // ... // No clobber of %R1; // %R0 = COPY %R1 <<< Removed; //; // or; //; // %R1 = COPY %R0; // ... // No clobber of %R0; // %R1 = COPY %R0 <<< Removed; //; // or; //; // $R0 = OP ...; // ... // No read/clobber of $R0 and $R1; // $R1 = COPY $R0 // $R0 is killed; // Replace $R0 with $R1 and remove the COPY; // $R1 = OP ...; // ...; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:946,Safety,redund,redundant,946,"//===- MachineCopyPropagation.cpp - Machine Copy Propagation Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is an extremely simple MachineInstr-level copy propagation pass.; //; // This pass forwards the source of COPYs to the users of their destinations; // when doing so is legal. For example:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg1; //; // If; // - %reg0 has not been clobbered by the time of the use of %reg1; // - the register class constraints are satisfied; // - the COPY def is the only value that reaches OP; // then this pass replaces the above with:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg0; //; // This pass also removes some redundant COPYs. For example:; //; // %R1 = COPY %R0; // ... // No clobber of %R1; // %R0 = COPY %R1 <<< Removed; //; // or; //; // %R1 = COPY %R0; // ... // No clobber of %R0; // %R1 = COPY %R0 <<< Removed; //; // or; //; // $R0 = OP ...; // ... // No read/clobber of $R0 and $R1; // $R1 = COPY $R0 // $R0 is killed; // Replace $R0 with $R1 and remove the COPY; // $R1 = OP ...; // ...; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:404,Usability,simpl,simple,404,"//===- MachineCopyPropagation.cpp - Machine Copy Propagation Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is an extremely simple MachineInstr-level copy propagation pass.; //; // This pass forwards the source of COPYs to the users of their destinations; // when doing so is legal. For example:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg1; //; // If; // - %reg0 has not been clobbered by the time of the use of %reg1; // - the register class constraints are satisfied; // - the COPY def is the only value that reaches OP; // then this pass replaces the above with:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg0; //; // This pass also removes some redundant COPYs. For example:; //; // %R1 = COPY %R0; // ... // No clobber of %R1; // %R0 = COPY %R1 <<< Removed; //; // or; //; // %R1 = COPY %R0; // ... // No clobber of %R0; // %R1 = COPY %R0 <<< Removed; //; // or; //; // $R0 = OP ...; // ... // No read/clobber of $R0 and $R1; // $R1 = COPY $R0 // $R0 is killed; // Replace $R0 with $R1 and remove the COPY; // $R1 = OP ...; // ...; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:31,Availability,avail,available,31,// Source of copy is no longer available for propagation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:312,Availability,redundant,redundant,312,"// Since we clobber the destination of a copy, the semantic of Src's; // ""DefRegs"" to contain Def is no longer effectual. We will also need; // to remove the record from the copy maps that indicates Src defined; // Def. Failing to do so might cause the target to miss some; // opportunities to further eliminate redundant copy instructions.; // Consider the following sequence during the; // ForwardCopyPropagateBlock procedure:; // L1: r0 = COPY r9 <- TrackMI; // L2: r0 = COPY r8 <- TrackMI (Remove r9 defined r0 from tracker); // L3: use r0 <- Remove L2 from MaybeDeadCopies; // L4: early-clobber r9 <- Clobber r9 (L2 is still valid in tracker); // L5: r0 = COPY r8 <- Remove NopCopy",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:312,Safety,redund,redundant,312,"// Since we clobber the destination of a copy, the semantic of Src's; // ""DefRegs"" to contain Def is no longer effectual. We will also need; // to remove the record from the copy maps that indicates Src defined; // Def. Failing to do so might cause the target to miss some; // opportunities to further eliminate redundant copy instructions.; // Consider the following sequence during the; // ForwardCopyPropagateBlock procedure:; // L1: r0 = COPY r9 <- TrackMI; // L2: r0 = COPY r8 <- TrackMI (Remove r9 defined r0 from tracker); // L3: use r0 <- Remove L2 from MaybeDeadCopies; // L4: early-clobber r9 <- Clobber r9 (L2 is still valid in tracker); // L5: r0 = COPY r8 <- Remove NopCopy",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:270,Usability,clear,cleared,270,"// If DefReg becomes empty after removal, we can remove the; // SrcCopy from the tracker's copy maps. We only remove those; // entries solely record the Def is defined by Src. If an; // entry also contains the definition record of other Def'; // registers, it cannot be cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:86,Availability,avail,available,86,"// Remember source that's copied to Def. Once it's clobbered, then; // it's no longer available for copy propagation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:45,Availability,Avail,AvailSrc,45,// FIXME: Shall we simultaneously invalidate AvailSrc or AvailDef?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:57,Availability,Avail,AvailDef,57,// FIXME: Shall we simultaneously invalidate AvailSrc or AvailDef?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:18,Availability,avail,available,18,// Check that the available copy isn't clobbered by any regmasks between; // itself and the destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Safety,Avoid,Avoid,3,// Avoid eliminating a copy from/to a reserved registers as we cannot predict; // the value (Example: The sparc zero register is writable but stays zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:70,Safety,predict,predict,70,// Avoid eliminating a copy from/to a reserved registers as we cannot predict; // the value (Example: The sparc zero register is writable but stays zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:12,Availability,redundant,redundantly,12,// Copy was redundantly redefining either Src or Def. Remove earlier kill; // flags between Copy and PrevCopy because the value will be reused now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:12,Safety,redund,redundantly,12,// Copy was redundantly redefining either Src or Def. Remove earlier kill; // flags between Copy and PrevCopy because the value will be reused now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Usability,Clear,Clear,3,// Clear undef flag from remaining copy if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:166,Safety,avoid,avoiding,166,/// Decide whether we should forward the source of \param Copy to its use in; /// \param UseI based on the physical register class constraints of the opcode; /// and avoiding introducing more cross-class COPYs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:427,Energy Efficiency,reduce,reduced,427,"/// COPYs don't have register class constraints, so if the user instruction; /// is a COPY, we just try to avoid introducing additional cross-class; /// COPYs. For example:; ///; /// RegClassA = COPY RegClassB // Copy parameter; /// ...; /// RegClassB = COPY RegClassA // UseI parameter; ///; /// which after forwarding becomes; ///; /// RegClassA = COPY RegClassB; /// ...; /// RegClassB = COPY RegClassB; ///; /// so we have reduced the number of cross-class COPYs and potentially; /// introduced a nop COPY that can be removed.; // Allow forwarding if src and dst belong to any common class, so long as they; // don't belong to any (possibly smaller) common class that requires copies to; // go via a different class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:107,Safety,avoid,avoid,107,"/// COPYs don't have register class constraints, so if the user instruction; /// is a COPY, we just try to avoid introducing additional cross-class; /// COPYs. For example:; ///; /// RegClassA = COPY RegClassB // Copy parameter; /// ...; /// RegClassB = COPY RegClassA // UseI parameter; ///; /// which after forwarding becomes; ///; /// RegClassA = COPY RegClassB; /// ...; /// RegClassB = COPY RegClassB; ///; /// so we have reduced the number of cross-class COPYs and potentially; /// introduced a nop COPY that can be removed.; // Allow forwarding if src and dst belong to any common class, so long as they; // don't belong to any (possibly smaller) common class that requires copies to; // go via a different class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:429,Deployability,update,update,429,"/// Check that \p MI does not have implicit uses that overlap with it's \p Use; /// operand (the register being replaced), since these can sometimes be; /// implicitly tied to other operands. For example, on AMDGPU:; ///; /// V_MOVRELS_B32_e32 %VGPR2, %M0<imp-use>, %EXEC<imp-use>, %VGPR2_VGPR3_VGPR4_VGPR5<imp-use>; ///; /// the %VGPR2 is implicitly tied to the larger reg operand, but we have no; /// way of knowing we need to update the latter when updating the former.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:13,Availability,avail,available,13,/// Look for available copies whose destination register is used by \p MI and; /// replace the use in \p MI with the copy's source register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:116,Energy Efficiency,allocate,allocated,116,// Look for non-tied explicit vreg uses that have an active COPY; // instruction that defines the physical register allocated to them.; // Replace the vreg with the source of the active COPY.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:236,Availability,error,error,236,"// Don't forward into undef use operands since doing so can cause problems; // with the machine verifier, since it doesn't treat undef reads as reads,; // so we can end up with a live range that ends on an undef read, leading to; // an error that the live range doesn't end on a read of the live range; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:66,Safety,safe,safe,66,// Check that the register is marked 'renamable' so we know it is safe to; // rename it without violating any constraints that aren't expressed in the; // IR (e.g. ABI or opcode requirements).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Usability,Clear,Clear,3,// Clear kill markers that may have been invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:99,Availability,avail,available,99,"// If 'Def' is previously source of another copy, then this earlier copy's; // source is no longer available. e.g.; // %xmm9 = copy %xmm2; // ...; // %xmm2 = copy %xmm0; // ...; // %xmm2 = copy %xmm9",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:34,Availability,mask,mask,34,// The instruction has a register mask operand which means that it clobbers; // a large set of registers. Treat clobbered registers the same way as; // defined registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:65,Availability,avail,available,65,// Any previous copy definition or reading the Defs is no longer available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Deployability,Update,Update,3,"// Update matching debug values, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:99,Deployability,update,update,99,"// Check if the register in the debug instruction is utilized; // in a copy instruction, so we can update the debug info if the; // register is changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:1112,Availability,avail,available,1112,"// Remove spill-reload like copy chains. For example; // r0 = COPY r1; // r1 = COPY r2; // r2 = COPY r3; // r3 = COPY r4; // <def-use r4>; // r4 = COPY r3; // r3 = COPY r2; // r2 = COPY r1; // r1 = COPY r0; // will be folded into; // r0 = COPY r1; // r1 = COPY r4; // <def-use r4>; // r4 = COPY r1; // r1 = COPY r0; // TODO: Currently we don't track usage of r0 outside the chain, so we; // conservatively keep its value as it was before the rewrite.; //; // The algorithm is trying to keep; // property#1: No Def of spill COPY in the chain is used or defined until the; // paired reload COPY in the chain uses the Def.; //; // property#2: NO Source of COPY in the chain is used or defined until the next; // COPY in the chain defines the Source, except the innermost spill-reload; // pair.; //; // The algorithm is conducted by checking every COPY inside the MBB, assuming; // the COPY is a reload COPY, then try to find paired spill COPY by searching; // the COPY defines the Src of the reload COPY backward. If such pair is found,; // it either belongs to an existing chain or a new chain depends on; // last available COPY uses the Def of the reload COPY.; // Implementation notes, we use CopyTracker::findLastDefCopy(Reg, ...) to find; // out last COPY that defines Reg; we use CopyTracker::findLastUseCopy(Reg, ...); // to find out last COPY that uses Reg. When we are encountered with a Non-COPY; // instruction, we check registers in the operands of this instruction. If this; // Reg is defined by a COPY, we untrack this Reg via; // CopyTracker::clobberRegister(Reg, ...).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:1092,Integrability,depend,depends,1092,"// Remove spill-reload like copy chains. For example; // r0 = COPY r1; // r1 = COPY r2; // r2 = COPY r3; // r3 = COPY r4; // <def-use r4>; // r4 = COPY r3; // r3 = COPY r2; // r2 = COPY r1; // r1 = COPY r0; // will be folded into; // r0 = COPY r1; // r1 = COPY r4; // <def-use r4>; // r4 = COPY r1; // r1 = COPY r0; // TODO: Currently we don't track usage of r0 outside the chain, so we; // conservatively keep its value as it was before the rewrite.; //; // The algorithm is trying to keep; // property#1: No Def of spill COPY in the chain is used or defined until the; // paired reload COPY in the chain uses the Def.; //; // property#2: NO Source of COPY in the chain is used or defined until the next; // COPY in the chain defines the Source, except the innermost spill-reload; // pair.; //; // The algorithm is conducted by checking every COPY inside the MBB, assuming; // the COPY is a reload COPY, then try to find paired spill COPY by searching; // the COPY defines the Src of the reload COPY backward. If such pair is found,; // it either belongs to an existing chain or a new chain depends on; // last available COPY uses the Def of the reload COPY.; // Implementation notes, we use CopyTracker::findLastDefCopy(Reg, ...) to find; // out last COPY that defines Reg; we use CopyTracker::findLastUseCopy(Reg, ...); // to find out last COPY that uses Reg. When we are encountered with a Non-COPY; // instruction, we check registers in the operands of this instruction. If this; // Reg is defined by a COPY, we untrack this Reg via; // CopyTracker::clobberRegister(Reg, ...).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:442,Modifiability,rewrite,rewrite,442,"// Remove spill-reload like copy chains. For example; // r0 = COPY r1; // r1 = COPY r2; // r2 = COPY r3; // r3 = COPY r4; // <def-use r4>; // r4 = COPY r3; // r3 = COPY r2; // r2 = COPY r1; // r1 = COPY r0; // will be folded into; // r0 = COPY r1; // r1 = COPY r4; // <def-use r4>; // r4 = COPY r1; // r1 = COPY r0; // TODO: Currently we don't track usage of r0 outside the chain, so we; // conservatively keep its value as it was before the rewrite.; //; // The algorithm is trying to keep; // property#1: No Def of spill COPY in the chain is used or defined until the; // paired reload COPY in the chain uses the Def.; //; // property#2: NO Source of COPY in the chain is used or defined until the next; // COPY in the chain defines the Source, except the innermost spill-reload; // pair.; //; // The algorithm is conducted by checking every COPY inside the MBB, assuming; // the COPY is a reload COPY, then try to find paired spill COPY by searching; // the COPY defines the Src of the reload COPY backward. If such pair is found,; // it either belongs to an existing chain or a new chain depends on; // last available COPY uses the Def of the reload COPY.; // Implementation notes, we use CopyTracker::findLastDefCopy(Reg, ...) to find; // out last COPY that defines Reg; we use CopyTracker::findLastUseCopy(Reg, ...); // to find out last COPY that uses Reg. When we are encountered with a Non-COPY; // instruction, we check registers in the operands of this instruction. If this; // Reg is defined by a COPY, we untrack this Reg via; // CopyTracker::clobberRegister(Reg, ...).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:520,Usability,simpl,simplify,520,"// We need at least 3 pairs of copies for the transformation to apply,; // because the first outermost pair cannot be removed since we don't; // recolor outside of the chain and that we need at least one temporary; // spill slot to shorten the chain. If we only have a chain of two; // pairs, we already have the shortest sequence this code can handle:; // the outermost pair for the temporary spill slot, and the pair that; // use that temporary spill slot for the other end of the chain.; // TODO: We might be able to simplify to one spill-reload pair if collecting; // more infomation about the outermost COPY.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Deployability,Update,Update,3,// Update track information via non-copy instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:393,Performance,perform,performs,393,"//===- MachineCSE.cpp - Machine Common Subexpression Elimination Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global common subexpression elimination on machine; // instructions using a scoped hash table based value numbering scheme. It; // must be run while the machine function is still in SSA form.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:485,Security,hash,hash,485,"//===- MachineCSE.cpp - Machine Common Subexpression Elimination Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global common subexpression elimination on machine; // instructions using a scoped hash table based value numbering scheme. It; // must be run while the machine function is still in SSA form.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:16,Safety,avoid,avoid,16,// Threshold to avoid excessive cost to compute isProfitableToCSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:383,Deployability,update,updated,383,"// FIXME: We should trivially coalesce subregister copies to expose CSE; // opportunities on instructions with truncated operands (see; // cse-add-with-overflow.ll). This can be done here as follows:; // if (SrcSubReg); // RC = TRI->getMatchingSuperRegClass(MRI->getRegClass(SrcReg), RC,; // SrcSubReg);; // MO.substVirtReg(SrcReg, SrcSubReg, *TRI);; //; // The 2-addr pass has been updated to handle coalesced subregs. However,; // some machine-specific code still can't handle it.; // To handle it properly we also need a way find a constrained subregister; // class given a super-reg class and subreg index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:61,Security,expose,expose,61,"// FIXME: We should trivially coalesce subregister copies to expose CSE; // opportunities on instructions with truncated operands (see; // cse-add-with-overflow.ll). This can be done here as follows:; // if (SrcSubReg); // RC = TRI->getMatchingSuperRegClass(MRI->getRegClass(SrcReg), RC,; // SrcSubReg);; // MO.substVirtReg(SrcReg, SrcSubReg, *TRI);; //; // The 2-addr pass has been updated to handle coalesced subregs. However,; // some machine-specific code still can't handle it.; // To handle it properly we also need a way find a constrained subregister; // class given a super-reg class and subreg index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:9,Modifiability,extend,extending,9,// Avoid extending live range of physical registers if they are; //allocatable or reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:3,Safety,Avoid,Avoid,3,// Avoid extending live range of physical registers if they are; //allocatable or reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:33,Performance,load,load,33,"// Okay, this instruction does a load. As a refinement, we allow the target; // to decide whether the loaded value is actually a constant. If so, we can; // actually use it as a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:102,Performance,load,loaded,102,"// Okay, this instruction does a load. As a refinement, we allow the target; // to decide whether the loaded value is actually a constant. If so, we can; // actually use it as a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:178,Performance,load,load,178,"// Okay, this instruction does a load. As a refinement, we allow the target; // to decide whether the loaded value is actually a constant. If so, we can; // actually use it as a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:37,Performance,load,loads,37,// FIXME: we should be able to hoist loads with no other side effects if; // there are no other instructions which can change memory in this loop.; // This is a trivial form of alias analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:22,Performance,load,loads,22,"// Ignore stack guard loads, otherwise the register that holds CSEed value may; // be spilled and get loaded back with corrupted data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:102,Performance,load,loaded,102,"// Ignore stack guard loads, otherwise the register that holds CSEed value may; // be spilled and get loaded back with corrupted data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:102,Safety,avoid,avoid,102,// Too costly to compute if NumOfUses is very large. Conservatively assume; // MayIncreasePressure to avoid spending too much time here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:85,Availability,redundant,redundant,85,"// Heuristics #2: If the expression doesn't not use a vr and the only use; // of the redundant computation are copies, do not cse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:85,Safety,redund,redundant,85,"// Heuristics #2: If the expression doesn't not use a vr and the only use; // of the redundant computation are copies, do not cse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:97,Safety,safe,safe,97,"// If the instruction defines physical registers and the values *may* be; // used, then it's not safe to replace it with a common subexpression.; // It's also not safe if the instruction uses physical registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:163,Safety,safe,safe,163,"// If the instruction defines physical registers and the values *may* be; // used, then it's not safe to replace it with a common subexpression.; // It's also not safe if the instruction uses physical registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:315,Safety,detect,detected,315,"// ... Unless the CS is local or is in the sole predecessor block; // and it also defines the physical register which is not clobbered; // in between and the physical register uses were not clobbered.; // This can never be the case if the instruction both uses and; // defines the same physical register, which was detected above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:267,Integrability,depend,dependent,267,"// Prevent CSE-ing non-local convergent instructions.; // LLVM's current definition of `isConvergent` does not necessarily prove; // that non-local CSE is illegal. The following check extends the definition; // of `isConvergent` to assume a convergent instruction is dependent not; // only on additional conditions, but also on fewer conditions. LLVM does; // not have a MachineInstr attribute which expresses this extended; // definition, so it's necessary to use `isConvergent` to prevent illegally; // CSE-ing the subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:184,Modifiability,extend,extends,184,"// Prevent CSE-ing non-local convergent instructions.; // LLVM's current definition of `isConvergent` does not necessarily prove; // that non-local CSE is illegal. The following check extends the definition; // of `isConvergent` to assume a convergent instruction is dependent not; // only on additional conditions, but also on fewer conditions. LLVM does; // not have a MachineInstr attribute which expresses this extended; // definition, so it's necessary to use `isConvergent` to prevent illegally; // CSE-ing the subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:415,Modifiability,extend,extended,415,"// Prevent CSE-ing non-local convergent instructions.; // LLVM's current definition of `isConvergent` does not necessarily prove; // that non-local CSE is illegal. The following check extends the definition; // of `isConvergent` to assume a convergent instruction is dependent not; // only on additional conditions, but also on fewer conditions. LLVM does; // not have a MachineInstr attribute which expresses this extended; // definition, so it's necessary to use `isConvergent` to prevent illegally; // CSE-ing the subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:583,Modifiability,extend,extended,583,"// Prevent CSE-ing non-local convergent instructions.; // LLVM's current definition of `isConvergent` does not necessarily prove; // that non-local CSE is illegal. The following check extends the definition; // of `isConvergent` to assume a convergent instruction is dependent not; // only on additional conditions, but also on fewer conditions. LLVM does; // not have a MachineInstr attribute which expresses this extended; // definition, so it's necessary to use `isConvergent` to prevent illegally; // CSE-ing the subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:31,Performance,perform,perform,31,// Check if it's profitable to perform this CSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:74,Availability,redundant,redundant,74,"// Keep track of implicit defs of CSMI and MI, to clear possibly; // made-redundant kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:74,Safety,redund,redundant,74,"// Keep track of implicit defs of CSMI and MI, to clear possibly; // made-redundant kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:50,Usability,clear,clear,50,"// Keep track of implicit defs of CSMI and MI, to clear possibly; // made-redundant kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:9,Performance,perform,perform,9,"// Don't perform CSE if the result of the new instruction cannot exist; // within the constraints (register class, bank, or low-level type) of; // the old instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:12,Performance,perform,perform,12,// Actually perform the elimination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:48,Usability,clear,clear,48,"// OldReg may have been unused but is used now, clear the Dead flag",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:27,Usability,clear,clear,27,// Replace with NewReg and clear kill flags which may be wrong now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:178,Availability,redundant,redundant,178,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:600,Modifiability,extend,extended,600,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:178,Safety,redund,redundant,178,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:48,Usability,clear,clear,48,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:59,Usability,clear,clear,59,"// If the instructions aren't in the same BB, bail out and clear the; // kill flag on all uses of the imp-def'd register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:3,Performance,Perform,Perform,3,// Perform a DFS walk to determine the order of visit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:7,Performance,perform,perform,7,// Now perform CSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:26,Availability,redundant,redundant,26,// Two instrs are partial redundant if their basic blocks are reachable; // from one to another but one doesn't dominate another.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:26,Safety,redund,redundant,26,// Two instrs are partial redundant if their basic blocks are reachable; // from one to another but one doesn't dominate another.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:106,Integrability,depend,dependent,106,"// The following check extends the definition of `isConvergent` to; // assume a convergent instruction is dependent not only on additional; // conditions, but also on fewer conditions. LLVM does not have a; // MachineInstr attribute which expresses this extended definition, so; // it's necessary to use `isConvergent` to prevent illegally PRE-ing the; // subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:23,Modifiability,extend,extends,23,"// The following check extends the definition of `isConvergent` to; // assume a convergent instruction is dependent not only on additional; // conditions, but also on fewer conditions. LLVM does not have a; // MachineInstr attribute which expresses this extended definition, so; // it's necessary to use `isConvergent` to prevent illegally PRE-ing the; // subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:254,Modifiability,extend,extended,254,"// The following check extends the definition of `isConvergent` to; // assume a convergent instruction is dependent not only on additional; // conditions, but also on fewer conditions. LLVM does not have a; // MachineInstr attribute which expresses this extended definition, so; // it's necessary to use `isConvergent` to prevent illegally PRE-ing the; // subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:422,Modifiability,extend,extended,422,"// The following check extends the definition of `isConvergent` to; // assume a convergent instruction is dependent not only on additional; // conditions, but also on fewer conditions. LLVM does not have a; // MachineInstr attribute which expresses this extended definition, so; // it's necessary to use `isConvergent` to prevent illegally PRE-ing the; // subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:167,Performance,optimiz,optimized,167,"// When hoisting, make sure we don't carry the debug location of; // the original instruction, as that's not correct and can cause; // unexpected jumps when debugging optimized code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:28,Safety,redund,redundancy,28,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:96,Safety,redund,redundancy,96,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:133,Safety,redund,redundancy,133,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:213,Safety,redund,redundancy,213,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:8,Usability,simpl,simple,8,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp:160,Energy Efficiency,allocate,allocated,160,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp:306,Safety,safe,safe,306,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp:18,Safety,safe,safe,18,// Otherwise it's safe to move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:485,Testability,test,tests,485,"//===- MachineDebugify.cpp - Attach synthetic debug info to everything ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This pass attaches synthetic debug info to everything. It can be used; /// to create targeted tests for debug info preservation, or test for CodeGen; /// differences with vs. without debug info.; ///; /// This isn't intended to have feature parity with Debugify.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:523,Testability,test,test,523,"//===- MachineDebugify.cpp - Attach synthetic debug info to everything ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This pass attaches synthetic debug info to everything. It can be used; /// to create targeted tests for debug info preservation, or test for CodeGen; /// differences with vs. without debug info.; ///; /// This isn't intended to have feature parity with Debugify.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:14,Modifiability,variab,variables,14,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:121,Modifiability,variab,variables,121,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:268,Modifiability,variab,variable,268,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:354,Modifiability,variab,variables,354,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:516,Modifiability,variab,variable,516,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:146,Usability,simpl,simple,146,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:243,Usability,simpl,simply,243,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:25,Modifiability,variab,variable,25,// Find a suitable local variable for the DBG_VALUE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:40,Modifiability,variab,variables,40,"// Here we save the number of lines and variables into ""llvm.mir.debugify"".; // It is useful for mir-check-debugify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:17,Modifiability,variab,variables,17,// Add number of variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:17,Modifiability,variab,variables,17,// Set number of variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp:404,Usability,simpl,simple,404,"//===- MachineDominators.cpp - Machine Dominator Calculation --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements simple dominator construction algorithms for finding; // forward dominators on machine functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp:3,Deployability,Update,Update,3,// Update dominator information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp:8,Deployability,update,update,8,"// Now, update DT with the collected dominance properties info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp:98,Modifiability,refactor,refactored,98,"// This code is very, very similar to PEI::calculateFrameObjectOffsets().; // It really should be refactored to share code. Until then, changes; // should keep in mind that there's tight coupling between the two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp:187,Modifiability,coupling,coupling,187,"// This code is very, very similar to PEI::calculateFrameObjectOffsets().; // It really should be refactored to share code. Until then, changes; // should keep in mind that there's tight coupling between the two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:85,Performance,load,load,85,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:178,Safety,avoid,avoid,178,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:97,Security,hash,hash,97,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:194,Security,access,access,194,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:255,Security,access,access,255,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:80,Energy Efficiency,allocate,allocate,80,"/// Get the JumpTableInfo for this function.; /// If it does not already exist, allocate one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate a new MachineInstr. Use this instead of `new MachineInstr'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:259,Deployability,update,updateCallSiteInfo,259,"// Verify that a call site info is at valid state. This assertion should; // be triggered during the implementation of support for the; // call site info of a new architecture. If the assertion is triggered,; // back trace will tell where to insert a call to updateCallSiteInfo().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:56,Testability,assert,assertion,56,"// Verify that a call site info is at valid state. This assertion should; // be triggered during the implementation of support for the; // call site info of a new architecture. If the assertion is triggered,; // back trace will tell where to insert a call to updateCallSiteInfo().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:184,Testability,assert,assertion,184,"// Verify that a call site info is at valid state. This assertion should; // be triggered during the implementation of support for the; // call site info of a new architecture. If the assertion is triggered,; // back trace will tell where to insert a call to updateCallSiteInfo().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate a new MachineBasicBlock. Use this instead of; /// `new MachineBasicBlock'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:93,Availability,robust,robust,93,// Set BBID for `-basic-block=sections=labels` and; // `-basic-block-sections=list` to allow robust mapping of profiles to basic; // blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:79,Safety,Avoid,Avoid,79,"// Iterate over all operands looking for defs to create substitutions for.; // Avoid creating new instr numbers unless we create a new substitution.; // While this has no functional effect, it risks confusing someone reading; // MIR output.; // Examine all the operands, or the first N specified by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:193,Safety,risk,risks,193,"// Iterate over all operands looking for defs to create substitutions for.; // Avoid creating new instr numbers unless we create a new substitution.; // While this has no functional effect, it risks confusing someone reading; // MIR output.; // Examine all the operands, or the first N specified by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:47,Deployability,install,install,47,"// Calculate the instruction number to use, or install a DBG_PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:206,Energy Efficiency,efficient,efficient,206,// Helper lambda to apply additional subregister substitutions to a known; // instruction/operand pair. Adds new (fake) substitutions so that we can; // record the subregister. FIXME: this isn't very space efficient if multiple; // values are tracked back through the same copies; cache something later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:281,Performance,cache,cache,281,// Helper lambda to apply additional subregister substitutions to a known; // instruction/operand pair. Adds new (fake) substitutions so that we can; // record the subregister. FIXME: this isn't very space efficient if multiple; // values are tracked back through the same copies; cache something later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:3,Testability,Test,Test,3,// Test for operand that defines something aliasing RegToSeek.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:400,Modifiability,variab,variable,400,"// We reached the start of the block before finding a defining instruction.; // There are numerous scenarios where this can happen:; // * Constant physical registers,; // * Several intrinsics that allow LLVM-IR to read arbitary registers,; // * Arguments in the entry block,; // * Exception handling landing pads.; // Validating all of them is too difficult, so just insert a DBG_PHI reading; // the variable value at this position, rather than checking it makes sense.; // Create DBG_PHI for specified physreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:318,Security,Validat,Validating,318,"// We reached the start of the block before finding a defining instruction.; // There are numerous scenarios where this can happen:; // * Constant physical registers,; // * Several intrinsics that allow LLVM-IR to read arbitary registers,; // * Arguments in the entry block,; // * Exception handling landing pads.; // Validating all of them is too difficult, so just insert a DBG_PHI reading; // the variable value at this position, rather than checking it makes sense.; // Create DBG_PHI for specified physreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:32,Availability,redundant,redundant,32,"// Some vregs can be deleted as redundant in the meantime. Mark those; // as DBG_VALUE $noreg. Additionally, some normal instructions are; // quickly deleted, leaving dangling references to vregs with no def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:32,Safety,redund,redundant,32,"// Some vregs can be deleted as redundant in the meantime. Mark those; // as DBG_VALUE $noreg. Additionally, some normal instructions are; // quickly deleted, leaving dangling references to vregs with no def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:85,Performance,optimiz,optimized,85,"// Disable instr-ref at -O0: it's very slow (in compile time). We can still; // have optimized code inlined into this unoptimized code, however with; // fewer and less aggressive optimizations happening, coverage and accuracy; // should not suffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:179,Performance,optimiz,optimizations,179,"// Disable instr-ref at -O0: it's very slow (in compile time). We can still; // have optimized code inlined into this unoptimized code, however with; // fewer and less aggressive optimizations happening, coverage and accuracy; // should not suffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:45,Deployability,update,update,45,"/// If Old is the target of any jump tables, update the jump tables to branch; /// to New instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:43,Deployability,update,update,43,"/// If Old is a target of the jump tables, update the jump table to branch to; /// New instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:123,Safety,avoid,avoid,123,"// A constant may be a member of both Constants and MachineCPVsSharingEntries,; // so keep track of which we've deleted to avoid double deletions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:48,Energy Efficiency,allocate,allocated,48,/// Test whether the given two constants can be allocated the same constant pool; /// entry referenced by \param A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:4,Testability,Test,Test,4,/// Test whether the given two constants can be allocated the same constant pool; /// entry referenced by \param A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:18,Safety,safe,safely,18,"// Constants only safely match if A doesn't contain undef/poison.; // As we'll be reusing A, it doesn't matter if B contain undef/poison.; // TODO: Handle cases where A and B have the same undef/poison elements.; // TODO: Merge A and B with mismatching undef/poison elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:94,Energy Efficiency,efficient,efficient,94,"// Check to see if we already have this constant.; //; // FIXME, this could be made much more efficient for large constant pools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:94,Energy Efficiency,efficient,efficient,94,"// Check to see if we already have this constant.; //; // FIXME, this could be made much more efficient for large constant pools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunctionSplitter.cpp:35,Integrability,depend,dependent,35,"// FIXME: This cutoff value is CPU dependent and should be moved to; // TargetTransformInfo once we consider enabling this on other platforms.; // The value is expressed as a ProfileSummaryInfo integer percentile cutoff.; // Defaults to 999950, i.e. all blocks colder than 99.995 percentile are split.; // The default was empirically determined to be optimal when considering cutoff; // values between 99%-ile to 100%-ile with respect to iTLB and icache metrics on; // Intel CPUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunctionSplitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunctionSplitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:80,Availability,reliab,reliably,80,"// Replicate ties between the operands, which addOperand was not; // able to do reliably.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:115,Deployability,update,update,115,"/// Move NumOps MachineOperands from Src to Dst, with support for overlapping; /// ranges. If MRI is non-null also update use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:64,Integrability,depend,depends,64,"// Don't call the MachineOperand destructor. A lot of this code depends on; // MachineOperand having a trivial destructor anyway, and adding a call here; // wouldn't make it 'destructor-correct'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:51,Energy Efficiency,allocate,allocated,51,// See if we can just steal the extra info already allocated for the; // instruction. We can do this whenever the pre- and post-instruction symbols; // are the same (including null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:41,Usability,simpl,simpler,41,// Try handling easy numbers of MIs with simpler mechanisms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:60,Usability,clear,clear,60,"// If there was only one symbol and we're removing it, just clear info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:60,Usability,clear,clear,60,"// If there was only one symbol and we're removing it, just clear info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:120,Testability,log,logic,120,"// For now, the just return the union of the flags. If the flags get more; // complicated over time, we might need more logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:12,Integrability,wrap,wrapping,12,// Copy the wrapping flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:22,Testability,test,test,22,"// We have passed the test above that both instructions have the same; // opcode, so we know that both instructions are bundles here. Let's compare; // MIs inside the bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:167,Safety,safe,safe,167,"// Clients may or may not want to ignore defs when testing for equality.; // For example, machine CSE pass only cares about finding common; // subexpressions, so it's safe to ignore virtual register defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:51,Testability,test,testing,51,"// Clients may or may not want to ignore defs when testing for equality.; // For example, machine CSE pass only cares about finding common; // subexpressions, so it's safe to ignore virtual register defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:4,Usability,clear,clearKillInfo,4,/// clearKillInfo - Clears kill flags on all operands.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:20,Usability,Clear,Clears,20,/// clearKillInfo - Clears kill flags on all operands.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:40,Safety,safe,safe,40,"/// isSafeToMove - Return true if it is safe to move this instruction. If; /// SawStore is set to true, it means that there is a store (or call) between; /// the instruction's location and its intended destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:69,Performance,load,loads,69,"// Ignore stuff that we obviously can't move.; //; // Treat volatile loads as stores. This is not strictly necessary for; // volatiles, but it is required for atomic loads. It is not allowed to move; // a load across an atomic load with Ordering > Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:166,Performance,load,loads,166,"// Ignore stuff that we obviously can't move.; //; // Treat volatile loads as stores. This is not strictly necessary for; // volatiles, but it is required for atomic loads. It is not allowed to move; // a load across an atomic load with Ordering > Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:205,Performance,load,load,205,"// Ignore stuff that we obviously can't move.; //; // Treat volatile loads as stores. This is not strictly necessary for; // volatiles, but it is required for atomic loads. It is not allowed to move; // a load across an atomic load with Ordering > Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:227,Performance,load,load,227,"// Ignore stuff that we obviously can't move.; //; // Treat volatile loads as stores. This is not strictly necessary for; // volatiles, but it is required for atomic loads. It is not allowed to move; // a load across an atomic load with Ordering > Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:34,Performance,load,load,34,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:81,Performance,load,loaded,81,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:121,Performance,load,load,121,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:242,Performance,load,load,242,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:304,Performance,load,load,304,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:29,Performance,load,load,29,"// Otherwise, this is a real load. If there is a store between the load and; // end of block, we can't move it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:67,Performance,load,load,67,"// Otherwise, this is a real load. If there is a store between the load and; // end of block, we can't move it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:407,Energy Efficiency,allocate,allocated,407,"// The following interface to AA is fashioned after DAGCombiner::isAlias and; // operates with MachineMemOperand offset with some important assumptions:; // - LLVM fundamentally assumes flat address spaces.; // - MachineOperand offset can *only* result from legalization and cannot; // affect queries other than the trivial case of overlap checking.; // - These offsets never wrap and never step outside of allocated objects.; // - There should never be any negative offsets here.; //; // FIXME: Modify API to hide this math from ""user""; // Even before we go to AA we can reason locally about some memory objects. It; // can save compile time, and possibly catch some corner cases not currently; // covered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:17,Integrability,interface,interface,17,"// The following interface to AA is fashioned after DAGCombiner::isAlias and; // operates with MachineMemOperand offset with some important assumptions:; // - LLVM fundamentally assumes flat address spaces.; // - MachineOperand offset can *only* result from legalization and cannot; // affect queries other than the trivial case of overlap checking.; // - These offsets never wrap and never step outside of allocated objects.; // - There should never be any negative offsets here.; //; // FIXME: Modify API to hide this math from ""user""; // Even before we go to AA we can reason locally about some memory objects. It; // can save compile time, and possibly catch some corner cases not currently; // covered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:376,Integrability,wrap,wrap,376,"// The following interface to AA is fashioned after DAGCombiner::isAlias and; // operates with MachineMemOperand offset with some important assumptions:; // - LLVM fundamentally assumes flat address spaces.; // - MachineOperand offset can *only* result from legalization and cannot; // affect queries other than the trivial case of overlap checking.; // - These offsets never wrap and never step outside of allocated objects.; // - There should never be any negative offsets here.; //; // FIXME: Modify API to hide this math from ""user""; // Even before we go to AA we can reason locally about some memory objects. It; // can save compile time, and possibly catch some corner cases not currently; // covered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:35,Security,access,accesses,35,// Let the target decide if memory accesses cannot possibly overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:49,Security,access,access,49,// Memory operations without memory operands may access anything. Be; // conservative and assume `MayAlias`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:179,Availability,avail,available,179,"/// hasOrderedMemoryRef - Return true if this instruction may have an ordered; /// or volatile memory reference, or if the information describing the memory; /// reference is not available. Return false if it is known to have no ordered; /// memory references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:33,Security,access,access,33,// An instruction known never to access memory won't have a volatile access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:69,Security,access,access,69,// An instruction known never to access memory won't have a volatile access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:97,Performance,load,loading,97,/// isDereferenceableInvariantLoad - Return true if this instruction will never; /// trap and is loading from a location whose value is invariant across a run of; /// this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:30,Performance,load,load,30,"// If the instruction doesn't load at all, it isn't an invariant load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:65,Performance,load,load,65,"// If the instruction doesn't load at all, it isn't an invariant load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:106,Performance,load,load,106,"// If the instruction has lost its memoperands, conservatively assume that; // it may not be an invariant load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:176,Deployability,update,updated,176,"// If the memory operand has ordering side effects, we can't move the; // instruction. Such an instruction is technically an invariant load,; // but the caller code would need updated to expect that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:135,Performance,load,load,135,"// If the memory operand has ordering side effects, we can't move the; // instruction. Such an instruction is technically an invariant load,; // but the caller code would need updated to expect that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:5,Performance,load,load,5,// A load from a constant PseudoSourceValue is invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:92,Availability,Failure,Failure,92,// DEBUG_VALUE nodes do not contribute to code generation and should; // always be ignored. Failure to do so may result in trying to modify; // KILL flags on DEBUG_VALUE nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:34,Availability,mask,mask,34,"// This is a call with a register mask operand.; // Mask clobbers are always dead, so add defs for the non-dead defines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:52,Availability,Mask,Mask,52,"// This is a call with a register mask operand.; // Mask clobbers are always dead, so add defs for the non-dead defines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:24,Security,hash,hash,24,// Build up a buffer of hash code components.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:44,Modifiability,Variab,Variable,44,"// Non-Variadic Operands: Location, Offset, Variable, Expression; // Variadic Operands: Variable, Expression, Locations...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:88,Modifiability,Variab,Variable,88,"// Non-Variadic Operands: Location, Offset, Variable, Expression; // Variadic Operands: Variable, Expression, Locations...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:44,Modifiability,Variab,Variable,44,"// Non-Variadic Operands: Location, Offset, Variable, Expression; // Variadic Operands: Variable, Expression, Locations...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:88,Modifiability,Variab,Variable,88,"// Non-Variadic Operands: Location, Offset, Variable, Expression; // Variadic Operands: Variable, Expression, Locations...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstrBundle.cpp:161,Integrability,rout,routine,161,"/// finalizeBundle - Finalize a machine instruction bundle which includes; /// a sequence of instructions starting from FirstMI to LastMI (exclusive).; /// This routine adds a BUNDLE instruction to represent the bundle, it adds; /// IsInternalRead markers to MachineOperands which are defined inside the; /// bundle, and it copies externally visible defs and uses to the BUNDLE; /// instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstrBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstrBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:426,Availability,redundant,redundant,426,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:596,Availability,redundant,redundant,596,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:461,Performance,load,loads,461,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:503,Performance,load,loads,503,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:426,Safety,redund,redundant,426,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:596,Safety,redund,redundant,596,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:388,Usability,simpl,simple,388,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:55,Availability,redundant,redundant,55,// Walk through the instructions in MBB and remove any redundant; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:55,Safety,redund,redundant,55,// Walk through the instructions in MBB and remove any redundant; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:3,Usability,Clear,Clear,3,// Clear any previous kill flag on Reg found before I in MBB. Walk backwards; // in MBB and if needed continue in predecessors until a use/def of Reg is; // encountered. This seems to be faster in practice than tracking kill flags; // in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:301,Performance,load,load,301,"// Return true if MI is a potential candidate for reuse/removal and if so; // also the register it defines in DefedReg. A candidate is a simple; // instruction that does not touch memory, has only one register definition; // and the only reg it may use is FrameReg. Typically this is an immediate; // load or a load-address instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:311,Performance,load,load-address,311,"// Return true if MI is a potential candidate for reuse/removal and if so; // also the register it defines in DefedReg. A candidate is a simple; // instruction that does not touch memory, has only one register definition; // and the only reg it may use is FrameReg. Typically this is an immediate; // load or a load-address instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:137,Usability,simpl,simple,137,"// Return true if MI is a potential candidate for reuse/removal and if so; // also the register it defines in DefedReg. A candidate is a simple; // instruction that does not touch memory, has only one register definition; // and the only reg it may use is FrameReg. Typically this is an immediate; // load or a load-address instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:40,Performance,load,load-address,40,"// If FrameReg is modified, no previous load-address instructions (using; // it) are valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:3,Usability,Clear,Clear,3,// Clear any entries in map that MI clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:393,Performance,perform,performs,393,"//===- MachineLICM.cpp - Machine Loop Invariant Code Motion Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion on machine instructions. We; // attempt to remove as much code from the body of a loop as possible.; //; // This pass is not intended to be a replacement or a complete alternative; // for the LLVM-IR-level LICM pass. It is only designed to hoist simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:710,Security,expose,exposed,710,"//===- MachineLICM.cpp - Machine Loop Invariant Code Motion Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion on machine instructions. We; // attempt to remove as much code from the body of a loop as possible.; //; // This pass is not intended to be a replacement or a complete alternative; // for the LLVM-IR-level LICM pass. It is only designed to hoist simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:675,Usability,simpl,simple,675,"//===- MachineLICM.cpp - Machine Loop Invariant Code Motion Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion on machine instructions. We; // attempt to remove as much code from the body of a loop as possible.; //; // This pass is not intended to be a replacement or a complete alternative; // for the LLVM-IR-level LICM pass. It is only designed to hoist simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:61,Deployability,update,updated,61,// Machine dominator tree for the cur loop; // State that is updated as we process loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:102,Performance,load,load,102,// True if it's the first LICM in the loop.; // Holds information about whether it is allowed to move load instructions; // out of the loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:84,Performance,load,loads,84,"// If a MBB does not dominate loop exiting blocks then it may not safe; // to hoist loads from this block.; // Tri-state: 0 - false, 1 - true, 2 - unknown",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:66,Safety,safe,safe,66,"// If a MBB does not dominate loop exiting blocks then it may not safe; // to hoist loads from this block.; // Tri-state: 0 - false, 1 - true, 2 - unknown",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:104,Deployability,update,update,104,/// Examine the instruction for potentai LICM candidate. Also; /// gather register def and frame object update information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:76,Safety,safe,safe,76,"// If it's using a non-loop-invariant register, then it's obviously not; // safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:19,Safety,avoid,avoid,19,"// FIXME: For now, avoid instructions with multiple defs, unless; // it's a dead implicit def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:100,Safety,safe,safe,100,"// If we have already seen another instruction that defines the same; // register, then this is not safe. Two defs is indicated by setting a; // PhysRegClobbers bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:108,Performance,load,load,108,// Only consider reloads for now and remats which do not have register; // operands. FIXME: Consider unfold load folding instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:185,Performance,load,load,185,"// Now evaluate whether the potential candidates qualify.; // 1. Check if the candidate defined register is defined by another; // instruction in the loop.; // 2. If the candidate is a load from stack slot (always true for now),; // check if the slot is stored anywhere in the loop.; // 3. Make sure candidate def should not clobber; // registers read by the terminator. Similarly its def should not be; // clobbered by the terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:76,Safety,safe,safe,76,"// If it's using a non-loop-invariant register, then it's obviously; // not safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:82,Safety,safe,safe,82,"/// When an instruction is found to only use loop invariant operands that is; /// safe to hoist, this instruction is called to do the dirty work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:62,Performance,load,load,62,/// Check if this mbb is guaranteed to execute. If not then a load from this mbb; /// may not be safe to hoist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:97,Safety,safe,safe,97,/// Check if this mbb is guaranteed to execute. If not then a load from this mbb; /// may not be safe to hoist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Performance,Perform,Perform,3,// Perform a DFS walk to determine the order of visit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:7,Performance,perform,perform,7,// Now perform LICM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:4,Deployability,Update,Update,4,/// Update estimate of register pressure after the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:126,Deployability,update,updates,126,"/// Calculate the additional register pressure that the registers used in MI; /// cause.; ///; /// If 'ConsiderSeen' is true, updates 'RegSeen' and uses the information to; /// figure out which usages are live-ins.; /// FIXME: Figure out a way to consider 'RegSeen' from all code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:44,Performance,load,loads,44,/// Return true if this machine instruction loads from global offset table or; /// constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:102,Deployability,update,updated,102,"// FIXME: If targets would like to look through instructions that aren't; // pure copies, this can be updated to a query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:138,Safety,safe,safe,138,"/// Returns true if the instruction may be a suitable candidate for LICM.; /// e.g. If the instruction is a call, then it's obviously not safe to hoist it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:14,Performance,load,load,14,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:202,Performance,load,load,202,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:234,Performance,Load,Loads,234,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:304,Performance,load,load,304,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:265,Safety,safe,safe,265,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:180,Safety,safe,safe,180,// Convergent attribute has been used on operations that involve inter-thread; // communication which results are implicitly affected by the enclosing; // control flows. It is not safe to hoist or sink such operations across; // control flow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:76,Modifiability,extend,extended,76,// A PHI inside the loop causes a copy because the live range of Reg is; // extended across the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:20,Performance,latency,latency,20,"/// Compute operand latency between a def of 'Reg' and an use in the current; /// loop, return true if the target considered it high.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:68,Performance,latency,latency,68,"/// Return true if the instruction is marked ""cheap"" or the operand latency; /// between its def and a use is one or less.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:65,Deployability,update,update,65,/// Traverse the back trace from header to the current block and update their; /// register pressures to reflect the effect of hoisting MI from the current; /// block to the preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Deployability,Update,Update,3,// Update register pressure of blocks from loop header to current block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:336,Modifiability,extend,extending,336,"// Besides removing computation from the loop, hoisting an instruction has; // these effects:; //; // - The value defined by the instruction becomes live across the entire; // loop. This increases register pressure in the loop.; //; // - If the value is used by a PHI in the loop, a copy will be required for; // lowering the PHI after extending the live range.; //; // - When hoisting the last use of a value in the loop, that value no longer; // needs to be live in the loop. This lowers register pressure in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:114,Availability,down,down,114,// Rematerializable instructions should always be hoisted providing the; // register allocator can just pull them down again when needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:28,Performance,latency,latency,28,"// FIXME: If there are long latency loop-invariant instructions inside the; // loop at this point, why didn't the optimizer's LICM hoist them?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:114,Performance,optimiz,optimizer,114,"// FIXME: If there are long latency loop-invariant instructions inside the; // loop at this point, why didn't the optimizer's LICM hoist them?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:189,Performance,latency,latency,189,"// Estimate register pressure to determine whether to LICM the instruction.; // In low register pressure situation, we can be more aggressive about; // hoisting. Also, favors hoisting long latency instructions even in; // moderately high pressure situation.; // Cheap instructions will only be hoisted if they don't increase register; // pressure at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:109,Safety,safe,safe,109,"// Visit BBs from header to current BB, if hoisting this doesn't cause; // high register pressure, then it's safe to proceed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:9,Safety,risk,risk,9,// Don't risk increasing register pressure if it would create copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:13,Performance,load,load,13,"/// Unfold a load from the given machineinstr if the load itself could be; /// hoisted. Return the unfolded and hoistable load, or null if the load; /// couldn't be unfolded or if it wouldn't be hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:53,Performance,load,load,53,"/// Unfold a load from the given machineinstr if the load itself could be; /// hoisted. Return the unfolded and hoistable load, or null if the load; /// couldn't be unfolded or if it wouldn't be hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:122,Performance,load,load,122,"/// Unfold a load from the given machineinstr if the load itself could be; /// hoisted. Return the unfolded and hoistable load, or null if the load; /// couldn't be unfolded or if it wouldn't be hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:143,Performance,load,load,143,"/// Unfold a load from the given machineinstr if the load itself could be; /// hoisted. Return the unfolded and hoistable load, or null if the load; /// couldn't be unfolded or if it wouldn't be hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:23,Performance,load,loads,23,// Don't unfold simple loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:16,Usability,simpl,simple,16,// Don't unfold simple loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:38,Performance,load,load,38,"// If not, we may be able to unfold a load and hoist that.; // First test whether the instruction is loading from an amenable; // memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:101,Performance,load,loading,101,"// If not, we may be able to unfold a load and hoist that.; // First test whether the instruction is loading from an amenable; // memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:69,Testability,test,test,69,"// If not, we may be able to unfold a load and hoist that.; // First test whether the instruction is loading from an amenable; // memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:27,Performance,load,load,27,"// If unfolding produced a load that wasn't loop-invariant or profitable to; // hoist, discard the new instructions and bail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Deployability,Update,Update,3,// Update register pressure for the unfolded instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:68,Deployability,Update,Update,68,// Otherwise we successfully unfolded a load that we can hoist.; // Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:40,Performance,load,load,40,// Otherwise we successfully unfolded a load that we can hoist.; // Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:81,Performance,load,loads,81,/// Initialize AllowedToHoistLoads with information about whether invariant; /// loads can be moved outside a given loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:106,Performance,load,load,106,"// Going from the innermost to outermost loops, check if a loop has; // instructions preventing invariant load hoisting. If such instruction is; // found, mark this loop and its parent as non-hoistable and continue; // investigating the next loop.; // Visiting in a reversed pre-ordered DFS manner; // allows us to not process all the instructions of the outer loop if the; // inner loop is proved to be non-load-hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:408,Performance,load,load-hoistable,408,"// Going from the innermost to outermost loops, check if a loop has; // instructions preventing invariant load hoisting. If such instruction is; // found, mark this loop and its parent as non-hoistable and continue; // investigating the next loop.; // Visiting in a reversed pre-ordered DFS manner; // allows us to not process all the instructions of the outer loop if the; // inner loop is proved to be non-load-hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:21,Performance,load,loads,21,// Do not CSE normal loads because between them could be store instructions; // that change the loaded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:96,Performance,load,loaded,96,// Do not CSE normal loads because between them could be store instructions; // that change the loaded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Usability,Clear,Clear,3,"// Clear Dup dead flag if any, we reuse it for Reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:83,Safety,safe,safe,83,"/// When an instruction is found to use only loop invariant operands; /// that are safe to hoist, this instruction is called to do the dirty work.; /// It returns true if the instruction is hoisted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:37,Performance,load,load,37,"// If not, try unfolding a hoistable load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Deployability,Update,Update,3,// Update register pressure for BBs from header to this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Usability,Clear,Clear,3,"// Clear the kill flags of any register this instruction defines,; // since they may need to be live throughout the entire loop; // rather than just live for part of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp:93,Safety,avoid,avoid,93,// Check if the preheader candidate is a successor of any other loop; // headers. We want to avoid having two loop setups in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp:160,Energy Efficiency,allocate,allocated,160,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp:306,Safety,safe,safe,306,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp:18,Safety,safe,safe,18,// Otherwise it's safe to move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp:12,Usability,clear,clear,12,// We don't clear the ExternalContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp:3,Deployability,Update,Update,3,// Update the set entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp:117,Availability,error,error,117,"// If the inline asm had metadata associated with it, pull out a location; // cookie corresponding to which line the error occurred on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:18,Usability,Clear,Clear,18,// No change.; // Clear the IsRenamable bit to keep it conservatively correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:114,Deployability,update,update,114,"// Otherwise, we have to change the register. If this operand is embedded; // into a machine function, we need to update the old and new register's; // use/def lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:83,Availability,mask,masks,83,"// We don't know the size of the RegMask, so we can't deep compare the two; // reg masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:59,Availability,mask,mask,59,// Check if the flag's bitmask has the bits of the current mask set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:3,Usability,Clear,Clear,3,// Clear the bits which were serialized from the flag's bitmask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:77,Usability,simpl,simply,77,// isDebug() is exactly true for register operands of a DBG_VALUE. So we; // simply infer it when parsing and do not need to print it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:3,Deployability,Update,Update,3,// Update the alignment value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:8,Deployability,update,update,8,"// Also update the base and offset, because the new alignment may; // not be applicable with the old ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:109,Availability,avail,available,109,"// FIXME: Implement addrspace printing/parsing in MIR.; // For now, print this even though parsing it is not available in MIR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp:420,Integrability,interface,interfaces,420,"///===- MachineOptimizationRemarkEmitter.cpp - Opt Diagnostic -*- C++ -*---===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp:534,Integrability,depend,dependent,534,"///===- MachineOptimizationRemarkEmitter.cpp - Opt Diagnostic -*- C++ -*---===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp:622,Integrability,message,message,622,"///===- MachineOptimizationRemarkEmitter.cpp - Opt Diagnostic -*- C++ -*---===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp:396,Performance,Optimiz,Optimization,396,"///===- MachineOptimizationRemarkEmitter.cpp - Opt Diagnostic -*- C++ -*---===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:1535,Availability,avail,available,1535,"by placing every instruction from every basic block in a; /// suffix tree, and repeatedly querying that tree for repeated sequences of; /// instructions. If a sequence of instructions appears often, then it ought; /// to be beneficial to pull out into a function.; ///; /// The MachineOutliner communicates with a given target using hooks defined in; /// TargetInstrInfo.h. The target supplies the outliner with information on how; /// a specific sequence of instructions should be outlined. This information; /// is used to deduce the number of instructions necessary to; ///; /// * Create an outlined function; /// * Call that outlined function; ///; /// Targets must implement; /// * getOutliningCandidateInfo; /// * buildOutlinedFrame; /// * insertOutlinedCall; /// * isFunctionSafeToOutlineFrom; ///; /// in order to make use of the MachineOutliner.; ///; /// This was originally presented at the 2016 LLVM Developers' Meeting in the; /// talk ""Reducing Code Size Using Outlining"". For a high-level overview of; /// how this pass works, the talk is available on YouTube at; ///; /// https://www.youtube.com/watch?v=yorld-WSOeU; ///; /// The slides for the talk are available at; ///; /// http://www.llvm.org/devmtg/2016-11/Slides/Paquette-Outliner.pdf; ///; /// The talk provides an overview of how the outliner finds candidates and; /// ultimately outlines them. It describes how the main data structure for this; /// pass, the suffix tree, is queried and purged for candidates. It also gives; /// a simplified suffix tree construction algorithm for suffix trees based off; /// of the algorithm actually used here, Ukkonen's algorithm.; ///; /// For the original RFC for this pass, please see; ///; /// http://lists.llvm.org/pipermail/llvm-dev/2016-August/104170.html; ///; /// For more information on the suffix tree data structure, please see; /// https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:1651,Availability,avail,available,1651,"by placing every instruction from every basic block in a; /// suffix tree, and repeatedly querying that tree for repeated sequences of; /// instructions. If a sequence of instructions appears often, then it ought; /// to be beneficial to pull out into a function.; ///; /// The MachineOutliner communicates with a given target using hooks defined in; /// TargetInstrInfo.h. The target supplies the outliner with information on how; /// a specific sequence of instructions should be outlined. This information; /// is used to deduce the number of instructions necessary to; ///; /// * Create an outlined function; /// * Call that outlined function; ///; /// Targets must implement; /// * getOutliningCandidateInfo; /// * buildOutlinedFrame; /// * insertOutlinedCall; /// * isFunctionSafeToOutlineFrom; ///; /// in order to make use of the MachineOutliner.; ///; /// This was originally presented at the 2016 LLVM Developers' Meeting in the; /// talk ""Reducing Code Size Using Outlining"". For a high-level overview of; /// how this pass works, the talk is available on YouTube at; ///; /// https://www.youtube.com/watch?v=yorld-WSOeU; ///; /// The slides for the talk are available at; ///; /// http://www.llvm.org/devmtg/2016-11/Slides/Paquette-Outliner.pdf; ///; /// The talk provides an overview of how the outliner finds candidates and; /// ultimately outlines them. It describes how the main data structure for this; /// pass, the suffix tree, is queried and purged for candidates. It also gives; /// a simplified suffix tree construction algorithm for suffix trees based off; /// of the algorithm actually used here, Ukkonen's algorithm.; ///; /// For the original RFC for this pass, please see; ///; /// http://lists.llvm.org/pipermail/llvm-dev/2016-August/104170.html; ///; /// For more information on the suffix tree data structure, please see; /// https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:1987,Usability,simpl,simplified,1987,"by placing every instruction from every basic block in a; /// suffix tree, and repeatedly querying that tree for repeated sequences of; /// instructions. If a sequence of instructions appears often, then it ought; /// to be beneficial to pull out into a function.; ///; /// The MachineOutliner communicates with a given target using hooks defined in; /// TargetInstrInfo.h. The target supplies the outliner with information on how; /// a specific sequence of instructions should be outlined. This information; /// is used to deduce the number of instructions necessary to; ///; /// * Create an outlined function; /// * Call that outlined function; ///; /// Targets must implement; /// * getOutliningCandidateInfo; /// * buildOutlinedFrame; /// * insertOutlinedCall; /// * isFunctionSafeToOutlineFrom; ///; /// in order to make use of the MachineOutliner.; ///; /// This was originally presented at the 2016 LLVM Developers' Meeting in the; /// talk ""Reducing Code Size Using Outlining"". For a high-level overview of; /// how this pass works, the talk is available on YouTube at; ///; /// https://www.youtube.com/watch?v=yorld-WSOeU; ///; /// The slides for the talk are available at; ///; /// http://www.llvm.org/devmtg/2016-11/Slides/Paquette-Outliner.pdf; ///; /// The talk provides an overview of how the outliner finds candidates and; /// ultimately outlines them. It describes how the main data structure for this; /// pass, the suffix tree, is queried and purged for candidates. It also gives; /// a simplified suffix tree construction algorithm for suffix trees based off; /// of the algorithm actually used here, Ukkonen's algorithm.; ///; /// For the original RFC for this pass, please see; ///; /// http://lists.llvm.org/pipermail/llvm-dev/2016-August/104170.html; ///; /// For more information on the suffix tree data structure, please see; /// https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:13,Availability,avail,available,13,/// The next available integer to assign to a \p MachineInstr that; /// cannot be outlined.; ///; /// Set to -3 for compatability with \p DenseMapInfo<unsigned>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:13,Availability,avail,available,13,/// The next available integer to assign to a \p MachineInstr that can; /// be outlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:46,Deployability,Update,Updates,46,"/// Maps \p *It to a legal integer.; ///; /// Updates \p CanOutlineWithPrevInstr, \p HaveLegalRange, \p InstrListForMBB,; /// \p UnsignedVecForMBB, \p InstructionIntegerMap, and \p LegalInstrNumber.; ///; /// \returns The integer that \p *It was mapped to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:49,Deployability,Update,Updates,49,"/// Maps \p *It to an illegal integer.; ///; /// Updates \p InstrListForMBB, \p UnsignedVecForMBB, and \p; /// IllegalInstrNumber.; ///; /// \returns The integer that \p *It was mapped to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:240,Safety,unsafe,unsafe,240,"/// Transforms a \p MachineBasicBlock into a \p vector of \p unsigneds; /// and appends it to \p UnsignedVec and \p InstrList.; ///; /// Two instructions are assigned the same integer if they are identical.; /// If an instruction is deemed unsafe to outline, then it will be assigned an; /// unique integer. The resulting mapping is placed into a suffix tree and; /// queried for candidates.; ///; /// \param MBB The \p MachineBasicBlock to be translated into integers.; /// \param TII \p TargetInstrInfo for the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:18,Performance,perform,perform,18,// True if we can perform outlining given the last mapped (non-invisible); // instruction. This lets us know if we have a legal range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:140,Safety,safe,safe,140,// `It` is now positioned at the beginning of a range of instructions; // which may be outlinable. Check if each instruction is known to be safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:90,Safety,safe,safe,90,/// Set to true if the outliner should run on all functions in the module; /// considered safe for outlining.; /// Set to true by default for compatibility with llc's -run-pass option.; /// Set when the pass is constructed in TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:20,Performance,optimiz,optimized,20,/* Outlined code is optimized code by definition. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:21,Modifiability,variab,variables,21,// Don't add any new variables to the subprogram.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:91,Deployability,update,updates,91,// The following code is to add implicit def operands to the call; // instruction. It also updates call site information for moved; // code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:301,Security,expose,exposed,301,// Copy over the defs in the outlined range.; // First inst in outlined range <-- Anything that's defined in this; // ... .. range has to be added as an; // implicit Last inst in outlined range <-- def to the call; // instruction. Also remove call site information for outlined block; // of code. The exposed uses need to be copied in the outlined range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:37,Availability,redundant,redundant,37,// Introduce DefRegs set to skip the redundant register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:37,Safety,redund,redundant,37,// Introduce DefRegs set to skip the redundant register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:13,Security,expose,exposed,13,"// If it's a exposed use, add it to the call instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:129,Deployability,pipeline,pipeline,129,// MachineModuleAnalysis is a module analysis pass that is never invalidated; // because we don't run any module pass in codegen pipeline. This is very; // important because the codegen state is stored in MMI which is the analysis; // result of MachineModuleAnalysis. MMI should not be recomputed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:48,Deployability,pipeline,pipeline,48,// No need to pop this callback later since MIR pipeline is flat which means; // current pipeline is the top-level pipeline. Callbacks are not used after; // current pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:89,Deployability,pipeline,pipeline,89,// No need to pop this callback later since MIR pipeline is flat which means; // current pipeline is the top-level pipeline. Callbacks are not used after; // current pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:115,Deployability,pipeline,pipeline,115,// No need to pop this callback later since MIR pipeline is flat which means; // current pipeline is the top-level pipeline. Callbacks are not used after; // current pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:166,Deployability,pipeline,pipeline,166,// No need to pop this callback later since MIR pipeline is flat which means; // current pipeline is the top-level pipeline. Callbacks are not used after; // current pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:47,Deployability,Pipeline,Pipeliner,47,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:447,Deployability,pipeline,pipeliner,447,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:809,Deployability,pipeline,pipelined,809,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1240,Deployability,pipeline,pipeline,1240,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1407,Deployability,pipeline,pipelined,1407,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:421,Energy Efficiency,Schedul,Scheduling,421,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:892,Energy Efficiency,schedul,scheduled,892,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1018,Energy Efficiency,Schedul,ScheduleDAGInstrs,1018,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1417,Energy Efficiency,schedul,schedule,1417,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1073,Integrability,depend,dependences,1073,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1578,Modifiability,rewrite,rewrite,1578,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:730,Performance,optimiz,optimized,730,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:750,Performance,optimiz,optimized,750,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1141,Performance,perform,perform,1141,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:37,Deployability,pipeline,pipeliner,37,/// A command line argument to force pipeliner to use specified initial; /// interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:65,Deployability,pipeline,pipeline,65,/// A command line argument to limit the number of stages in the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:58,Integrability,depend,dependences,58,/// A command line option to disable the pruning of chain dependences due to; /// an unrelated Phi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:76,Integrability,depend,dependences,76,/// A command line option to disable the pruning of loop carried order; /// dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:37,Deployability,pipeline,pipeliner,37,/// A command line argument to force pipeliner to use specified issue; /// width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:54,Energy Efficiency,Schedul,Scheduling,54,"/// The ""main"" function for implementing Swing Modulo Scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:10,Deployability,pipeline,pipeline,10,// Cannot pipeline loops without instruction itineraries if we are using; // DFA for the pipeliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,Deployability,pipeline,pipeliner,89,// Cannot pipeline loops without instruction itineraries if we are using; // DFA for the pipeliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:232,Energy Efficiency,schedul,schedule,232,"/// Attempt to perform the SMS algorithm on the specified loop. This function is; /// the main entry point for the algorithm. The function identifies candidate; /// loops, calculates the minimum initiation interval, and attempts to schedule; /// the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:15,Performance,perform,perform,15,"/// Attempt to perform the SMS algorithm on the specified loop. This function is; /// the main entry point for the algorithm. The function identifies candidate; /// loops, calculates the minimum initiation interval, and attempts to schedule; /// the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:44,Deployability,pipeline,pipelined,44,/// Return true if the loop can be software pipelined. The algorithm is; /// restricted to loops with a single basic block. Make sure that the; /// branch in the loop can be analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:183,Energy Efficiency,Schedul,Schedule,183,/// The SMS algorithm consists of the following main steps:; /// 1. Computation and analysis of the dependence graph.; /// 2. Ordering of the nodes (instructions).; /// 3. Attempt to Schedule the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:100,Integrability,depend,dependence,100,/// The SMS algorithm consists of the following main steps:; /// 1. Computation and analysis of the dependence graph.; /// 2. Ordering of the nodes (instructions).; /// 3. Attempt to Schedule the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,Energy Efficiency,schedul,schedule,20,/// We override the schedule function in ScheduleDAGInstrs to implement the; /// scheduling part of the Swing Modulo Scheduling algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:41,Energy Efficiency,Schedul,ScheduleDAGInstrs,41,/// We override the schedule function in ScheduleDAGInstrs to implement the; /// scheduling part of the Swing Modulo Scheduling algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:81,Energy Efficiency,schedul,scheduling,81,/// We override the schedule function in ScheduleDAGInstrs to implement the; /// scheduling part of the Swing Modulo Scheduling algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:117,Energy Efficiency,Schedul,Scheduling,117,/// We override the schedule function in ScheduleDAGInstrs to implement the; /// scheduling part of the Swing Modulo Scheduling algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:25,Testability,test,testing,25,// This flag is used for testing and can cause correctness problems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:9,Energy Efficiency,schedul,schedule,9,// Can't schedule a loop without a valid MII.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:9,Deployability,pipeline,pipeline,9,// Don't pipeline large loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:23,Deployability,pipeline,pipeline,23,// No need to generate pipeline if there are no overlapped iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:16,Energy Efficiency,schedul,schedule,16,// Generate the schedule as a ModuloSchedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:32,Deployability,pipeline,pipeliner,32,/// Clean up after the software pipeliner runs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:198,Energy Efficiency,Schedul,ScheduleDAGInstrs,198,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:145,Integrability,depend,dependence,145,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:263,Integrability,depend,dependences,263,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:31,Performance,load,load,31,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:87,Performance,load,load,87,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:163,Integrability,depend,dependence,163,"// First, perform the cheaper check that compares the base register.; // If they are the same and the load offset is less than the store; // offset, then mark the dependence as loop carried potentially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:10,Performance,perform,perform,10,"// First, perform the cheaper check that compares the base register.; // If they are the same and the load offset is less than the store; // offset, then mark the dependence as loop carried potentially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:102,Performance,load,load,102,"// First, perform the cheaper check that compares the base register.; // If they are the same and the load offset is less than the store; // offset, then mark the dependence as loop carried potentially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:171,Integrability,depend,dependence,171,"// Second, the more expensive check that uses alias analysis on the; // base registers. If they alias, and the load offset is less than; // the store offset, the mark the dependence as loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:111,Performance,load,load,111,"// Second, the more expensive check that uses alias analysis on the; // base registers. If they alias, and the load offset is less than; // the store offset, the mark the dependence as loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:4,Deployability,Update,Update,4,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:50,Energy Efficiency,Schedul,ScheduleDAGInstrs,50,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:19,Integrability,depend,dependences,19,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:93,Integrability,depend,dependences,93,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:139,Integrability,depend,dependences,139,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:196,Integrability,depend,dependence,196,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:254,Integrability,depend,dependence,254,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:291,Integrability,depend,dependence,291,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:346,Integrability,depend,dependences,346,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:57,Integrability,depend,dependence,57,"// If the register is used by a Phi, then create an anti dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:25,Integrability,depend,dependent,25,// Add a chain edge to a dependent Phi that isn't an existing; // predecessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:59,Integrability,depend,dependence,59,"// If the register is defined by a Phi, then create a true dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:25,Integrability,depend,dependent,25,// Add a chain edge to a dependent Phi that isn't an existing; // predecessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:16,Integrability,depend,dependences,16,// Remove order dependences from an unrelated Phi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,Energy Efficiency,reduce,reduce,89,/// Iterate over each DAG node and see if we can change any dependences; /// in order to reduce the recurrence MII.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:60,Integrability,depend,dependences,60,/// Iterate over each DAG node and see if we can change any dependences; /// in order to reduce the recurrence MII.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:84,Deployability,update,update,84,"// See if an instruction can use a value from the previous iteration.; // If so, we update the base and offset of the instruction and change; // the dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:149,Integrability,depend,dependences,149,"// See if an instruction can use a value from the previous iteration.; // If so, we update the base and offset of the instruction and change; // the dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Integrability,depend,dependence,14,// Remove the dependence. The value now depends on a prior iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:40,Integrability,depend,depends,40,// Remove the dependence. The value now depends on a prior iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,Integrability,depend,dependence,20,// Remove the chain dependence between the instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:9,Integrability,depend,dependence,9,// Add a dependence between the new instruction and the instruction; // that defines the new base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:59,Deployability,update,update,59,// Remember the base and offset information so that we can update the; // instruction during code generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:12,Energy Efficiency,Schedul,Schedule,12,"// No valid Schedule Class Desc for schedClass, should be; // Pseudo/PostRAPseudo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:12,Energy Efficiency,Schedul,Schedule,12,"// No valid Schedule Class Desc for schedClass, should be; // Pseudo/PostRAPseudo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:51,Energy Efficiency,schedul,scheduled,51,/// Calculate the maximum register pressure of the scheduled instructions stream,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:144,Energy Efficiency,schedul,scheduled,144,"// Indexed by PSet ID; // InitSetPressure takes into account the register pressure of live-in; // registers. It's not depend on how the loop is scheduled, so it's enough to; // calculate them once at the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:118,Integrability,depend,depend,118,"// Indexed by PSet ID; // InitSetPressure takes into account the register pressure of live-in; // registers. It's not depend on how the loop is scheduled, so it's enough to; // calculate them once at the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:171,Availability,alive,alive,171,"// Search for live-in variables. They are factored into the register pressure; // from the begining. Live-in variables used by every iteration should be; // considered as alive throughout the loop. For example, the variable `c` in; // following code. \code; // int c = ...;; // for (int i = 0; i < n; i++); // a[i] += b[i] + c;; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:22,Modifiability,variab,variables,22,"// Search for live-in variables. They are factored into the register pressure; // from the begining. Live-in variables used by every iteration should be; // considered as alive throughout the loop. For example, the variable `c` in; // following code. \code; // int c = ...;; // for (int i = 0; i < n; i++); // a[i] += b[i] + c;; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:109,Modifiability,variab,variables,109,"// Search for live-in variables. They are factored into the register pressure; // from the begining. Live-in variables used by every iteration should be; // considered as alive throughout the loop. For example, the variable `c` in; // following code. \code; // int c = ...;; // for (int i = 0; i < n; i++); // a[i] += b[i] + c;; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:215,Modifiability,variab,variable,215,"// Search for live-in variables. They are factored into the register pressure; // from the begining. Live-in variables used by every iteration should be; // considered as alive throughout the loop. For example, the variable `c` in; // following code. \code; // int c = ...;; // for (int i = 0; i < n; i++); // a[i] += b[i] + c;; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Modifiability,variab,variable,14,// Ignore the variable that appears only on one side of phi instruction; // because it's used only at the first iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:38,Modifiability,variab,variables,38,"// Indexed by #Iter. To treat ""local"" variables of each stage separately, we; // manage the liveness of the registers independently by iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:73,Energy Efficiency,schedul,scheduling,73,"// Used to calculate register pressure, which is independent of loop; // scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:210,Integrability,depend,dependences,210,"// end anonymous namespace; /// Calculate the resource constrained minimum initiation interval for the; /// specified loop. We use the DFA to model the resources needed for; /// each instruction, and we ignore dependences. A different DFA is created; /// for each cycle that is required. When adding a new instruction, we attempt; /// to add it to each existing DFA, until a legal space is found. If the; /// instruction cannot be reserved in an existing DFA, we create a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:22,Integrability,depend,dependences,22,"/// Swap all the anti dependences in the DAG. That means it is no longer a DAG,; /// but we do this to find the circuits, and then change them back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,Integrability,depend,dependency,20,// Remove this anti dependency and add one in the reverse direction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:60,Integrability,depend,dependence,60,// Only create a back-edge on the first and last nodes of a dependence; // chain. This records any chains and adds them later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:38,Performance,load,load,38,// A chain edge between a store and a load is treated as a back-edge in the; // adjacency matrix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:57,Integrability,depend,dependences,57,// Add back-edges in the adjacency matrix for the output dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,Integrability,depend,dependence,42,/// Identify an elementary circuit in the dependence graph starting at the; /// specified node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:48,Integrability,depend,dependence,48,/// Identify all the elementary circuits in the dependence graph using; /// Johnson's circuit algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:21,Integrability,depend,dependences,21,"// Swap all the anti dependences in the DAG. That means it is no longer a DAG,; // but we do this to find the circuits, and then change them back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Integrability,depend,dependences,14,// Change the dependences back so that we've created a DAG again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:144,Deployability,pipeline,pipeliner,144,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:572,Energy Efficiency,schedul,scheduled,572,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:668,Energy Efficiency,schedul,scheduled,668,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:746,Energy Efficiency,schedul,scheduling,746,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:21,Integrability,depend,dependencies,21,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:231,Integrability,depend,dependence,231,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:154,Safety,avoid,avoid,154,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:690,Safety,avoid,avoid,690,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:22,Integrability,depend,dependencies,22,// Add the artificial dependencies if it does not form a cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:132,Safety,avoid,avoid,132,"/// Return true for DAG nodes that we ignore when computing the cost functions.; /// We ignore the back-edge recurrence in order to avoid unbounded recursion; /// in the calculation of the ASAP, ALAP, etc functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:58,Energy Efficiency,schedul,scheduling,58,"/// Compute several functions need to order the nodes for scheduling.; /// ASAP - Earliest time to schedule a node.; /// ALAP - Latest time to schedule a node.; /// MOV - Mobility function, difference between ALAP and ASAP.; /// D - Depth of each node.; /// H - Height of each node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:99,Energy Efficiency,schedul,schedule,99,"/// Compute several functions need to order the nodes for scheduling.; /// ASAP - Earliest time to schedule a node.; /// ALAP - Latest time to schedule a node.; /// MOV - Mobility function, difference between ALAP and ASAP.; /// D - Depth of each node.; /// H - Height of each node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:143,Energy Efficiency,schedul,schedule,143,"/// Compute several functions need to order the nodes for scheduling.; /// ASAP - Earliest time to schedule a node.; /// ALAP - Latest time to schedule a node.; /// MOV - Mobility function, difference between ALAP and ASAP.; /// D - Depth of each node.; /// H - Height of each node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:44,Integrability,depend,dependence,44,// Back-edges are predecessors with an anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:117,Energy Efficiency,schedul,schedule,117,"/// Check if the existing node-sets are profitable. If not, then ignore the; /// recurrent node-sets, and attempt to schedule all nodes together. This is; /// a heuristic. If the MII is large and all the recurrent node-sets are small,; /// then it's best to try to schedule all instructions together instead of; /// starting with the recurrent node-sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:265,Energy Efficiency,schedul,schedule,265,"/// Check if the existing node-sets are profitable. If not, then ignore the; /// recurrent node-sets, and attempt to schedule all nodes together. This is; /// a heuristic. If the MII is large and all the recurrent node-sets are small,; /// then it's best to try to schedule all instructions together instead of; /// starting with the recurrent node-sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:41,Usability,simpl,simple,41,// Check if the node-set contains only a simple add recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:32,Energy Efficiency,schedul,scheduled,32,/// Remove nodes that have been scheduled in previous NodeSets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:113,Energy Efficiency,schedul,scheduled,113,"/// Compute an ordered list of the dependence graph nodes, which; /// indicates the order that the nodes will be scheduled. This is a; /// two-level algorithm. First, a partial order is created, which; /// consists of a list of sets ordered from highest to lowest priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:35,Integrability,depend,dependence,35,"/// Compute an ordered list of the dependence graph nodes, which; /// indicates the order that the nodes will be scheduled. This is a; /// two-level algorithm. First, a partial order is created, which; /// consists of a list of sets ordered from highest to lowest priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:80,Availability,down,down,80,"// If some of the successors are in the existing node-set, then use the; // top-down ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:44,Integrability,depend,dependence,44,// Back-edges are predecessors with an anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:44,Integrability,depend,dependence,44,// Back-edges are predecessors with an anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:59,Deployability,pipeline,pipelined,59,"/// Process the nodes in the computed order and create the pipelined schedule; /// of the instructions, if possible. Return true if a schedule is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:69,Energy Efficiency,schedul,schedule,69,"/// Process the nodes in the computed order and create the pipelined schedule; /// of the instructions, if possible. Return true if a schedule is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:134,Energy Efficiency,schedul,schedule,134,"/// Process the nodes in the computed order and create the pipelined schedule; /// of the instructions, if possible. Return true if a schedule is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:36,Energy Efficiency,schedul,schedule,36,// Keep increasing II until a valid schedule is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:15,Energy Efficiency,schedul,schedule,15,"// Compute the schedule time for the instruction, which is based; // upon the scheduled time for any predecessors/successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:78,Energy Efficiency,schedul,scheduled,78,"// Compute the schedule time for the instruction, which is based; // upon the scheduled time for any predecessors/successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:45,Energy Efficiency,schedul,schedule,45,// These values are set when the size of the schedule window is limited; // due to chain dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,Integrability,depend,dependences,89,// These values are set when the size of the schedule window is limited; // due to chain dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,Energy Efficiency,schedul,scheduling,8,// When scheduling a Phi it is better to start at the late cycle and go; // backwards. The default order may insert the Phi too far away from; // its first dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:156,Integrability,depend,dependence,156,// When scheduling a Phi it is better to start at the late cycle and go; // backwards. The default order may insert the Phi too far away from; // its first dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:21,Energy Efficiency,schedul,schedule,21,"// Even if we find a schedule, make sure the schedule doesn't exceed the; // allowable number of stages. We keep trying if this happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:45,Energy Efficiency,schedul,schedule,45,"// Even if we find a schedule, make sure the schedule doesn't exceed the; // allowable number of stages. We keep trying if this happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:38,Deployability,pipeline,pipelined,38,"// If a schedule is found, ensure non-pipelined instructions are in stage 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,Energy Efficiency,schedul,schedule,8,"// If a schedule is found, ensure non-pipelined instructions are in stage 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,Energy Efficiency,schedul,schedule,8,"// If a schedule is found, check if it is a valid schedule too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:50,Energy Efficiency,schedul,schedule,50,"// If a schedule is found, check if it is a valid schedule too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,Energy Efficiency,schedul,schedule,8,"// If a schedule was found and the option is enabled, check if the schedule; // might generate additional register spills/fills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:67,Energy Efficiency,schedul,schedule,67,"// If a schedule was found and the option is enabled, check if the schedule; // might generate additional register spills/fills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:174,Modifiability,rewrite,rewrite,174,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:186,Performance,load,load,186,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:238,Performance,load,load,238,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:310,Performance,load,load,310,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:339,Performance,load,load,339,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:11,Performance,load,load,11,// Get the load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:32,Performance,load,load,32,// Check for the post-increment load/store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,Security,access,access,42,// Make sure that the instructions do not access the same memory location in; // the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,Energy Efficiency,schedul,scheduling,89,/// Apply changes to the instruction if needed. The changes are need; /// to improve the scheduling and depend up on the final schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:127,Energy Efficiency,schedul,schedule,127,/// Apply changes to the instruction if needed. The changes are need; /// to improve the scheduling and depend up on the final schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:104,Integrability,depend,depend,104,/// Apply changes to the instruction if needed. The changes are need; /// to improve the scheduling and depend up on the final schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:39,Integrability,depend,dependence,39,/// Return true for an order or output dependence that is loop carried; /// potentially. A dependence is loop carried if the destination defines a value; /// that may be used or defined by the source in a subsequent iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:91,Integrability,depend,dependence,91,/// Return true for an order or output dependence that is loop carried; /// potentially. A dependence is loop carried if the destination defines a value; /// that may be used or defined by the source in a subsequent iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:59,Integrability,depend,dependence,59,// Assume ordered loads and stores may have a loop carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:18,Performance,load,loads,18,// Assume ordered loads and stores may have a loop carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:41,Integrability,depend,dependence,41,// The conservative assumption is that a dependence between memory operations; // may be loop carried. The following code checks when it can be proved that; // there is no loop carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:185,Integrability,depend,dependence,185,// The conservative assumption is that a dependence between memory operations; // may be loop carried. The following code checks when it can be proved that; // there is no loop carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:110,Security,access,accesses,110,"// This is the main test, which checks the offset values and the loop; // increment value to determine if the accesses may be loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,Testability,test,test,20,"// This is the main test, which checks the offset values and the loop; // increment value to determine if the accesses may be loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:11,Energy Efficiency,schedul,schedule,11,/// Try to schedule the node at the specified StartCycle and continue; /// until the node is schedule or the EndCycle is reached. This function; /// returns true if the node is scheduled. This routine may search either; /// forward or backward for a place to insert the instruction based upon; /// the relative values of StartCycle and EndCycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:93,Energy Efficiency,schedul,schedule,93,/// Try to schedule the node at the specified StartCycle and continue; /// until the node is schedule or the EndCycle is reached. This function; /// returns true if the node is scheduled. This routine may search either; /// forward or backward for a place to insert the instruction based upon; /// the relative values of StartCycle and EndCycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:177,Energy Efficiency,schedul,scheduled,177,/// Try to schedule the node at the specified StartCycle and continue; /// until the node is schedule or the EndCycle is reached. This function; /// returns true if the node is scheduled. This routine may search either; /// forward or backward for a place to insert the instruction based upon; /// the relative values of StartCycle and EndCycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:193,Integrability,rout,routine,193,/// Try to schedule the node at the specified StartCycle and continue; /// until the node is schedule or the EndCycle is reached. This function; /// returns true if the node is scheduled. This routine may search either; /// forward or backward for a place to insert the instruction based upon; /// the relative values of StartCycle and EndCycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:29,Integrability,depend,depends,29,// The terminating condition depends on the direction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:36,Energy Efficiency,schedul,scheduled,36,// Return the cycle of the earliest scheduled instruction in the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:34,Energy Efficiency,schedul,scheduled,34,// Return the cycle of the latest scheduled instruction in the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:16,Energy Efficiency,schedul,scheduling,16,/// Compute the scheduling start slot for the instruction. The start slot; /// depends on any predecessor or successor nodes scheduled already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:125,Energy Efficiency,schedul,scheduled,125,/// Compute the scheduling start slot for the instruction. The start slot; /// depends on any predecessor or successor nodes scheduled already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:79,Integrability,depend,depends,79,/// Compute the scheduling start slot for the instruction. The start slot; /// depends on any predecessor or successor nodes scheduled already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:47,Energy Efficiency,schedul,scheduled,47,// Iterate over each instruction that has been scheduled already. The start; // slot computation depends on whether the previously scheduled instruction; // is a predecessor or successor of the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:131,Energy Efficiency,schedul,scheduled,131,// Iterate over each instruction that has been scheduled already. The start; // slot computation depends on whether the previously scheduled instruction; // is a predecessor or successor of the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:97,Integrability,depend,depends,97,// Iterate over each instruction that has been scheduled already. The start; // slot computation depends on whether the previously scheduled instruction; // is a predecessor or successor of the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,Integrability,depend,dependences,42,"// Because we're processing a DAG for the dependences, we recognize; // the back-edge in recurrences by anti dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:109,Integrability,depend,dependences,109,"// Because we're processing a DAG for the dependences, we recognize; // the back-edge in recurrences by anti dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:106,Energy Efficiency,schedul,scheduled,106,"// For instruction that requires multiple iterations, make sure that; // the dependent instruction is not scheduled past the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:77,Integrability,depend,dependent,77,"// For instruction that requires multiple iterations, make sure that; // the dependent instruction is not scheduled past the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:33,Energy Efficiency,schedul,scheduled,33,// Add the instruction after the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:34,Energy Efficiency,schedul,scheduled,34,// Add the instruction before the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:19,Integrability,depend,dependences,19,// Check for order dependences between instructions. Make sure the source; // is ordered before the destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:24,Integrability,depend,dependences,24,"// We did not handle HW dependences in previous for loop,; // and we normally set Latency = 0 for Anti deps,; // so may have nodes in same cycle with Anti denpendent on HW regs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:82,Performance,Latency,Latency,82,"// We did not handle HW dependences in previous for loop,; // and we normally set Latency = 0 for Anti deps,; // so may have nodes in same cycle with Anti denpendent on HW regs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Integrability,depend,dependence,14,// A circular dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:96,Integrability,depend,dependence,96,// OrderAfterDef takes precedences over OrderBeforeDef. The latter is due; // to a loop-carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:60,Deployability,update,updated,60,// The uncommon case when the instruction order needs to be updated because; // there is both a use and def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:23,Energy Efficiency,schedul,scheduled,23,/// Return true if the scheduled Phi has a loop carried operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:25,Integrability,depend,dependences,25,/// Determine transitive dependences of unpipelineable instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:72,Integrability,depend,depends,72,"// Determine all instructions upon which any unpipelineable instruction depends; // and ensure that they are in stage 0. If unable to do so, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:15,Deployability,pipeline,pipelined,15,// Put the non-pipelined instruction as early as possible in the schedule,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:65,Energy Efficiency,schedul,schedule,65,// Put the non-pipelined instruction as early as possible in the schedule,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:522,Availability,robust,robust,522,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:181,Deployability,pipeline,pipeliner,181,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:26,Energy Efficiency,schedul,schedule,26,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:121,Energy Efficiency,schedul,scheduled,121,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:459,Testability,test,test,459,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:326,Deployability,update,updated,326,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:460,Deployability,pipeline,pipeliner,460,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:485,Deployability,pipeline,pipelined,485,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:49,Energy Efficiency,schedul,scheduling,49,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:142,Energy Efficiency,schedul,scheduled,142,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:495,Energy Efficiency,schedul,schedule,495,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:367,Testability,assert,assert,367,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:24,Performance,perform,perform,24,"// sort, so that we can perform a binary search",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:46,Energy Efficiency,schedul,scheduled,46,// instructions in circuits are allowed to be scheduled; // after both a successor and predecessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:320,Deployability,update,updates,320,"/// Attempt to fix the degenerate cases when the instruction serialization; /// causes the register lifetimes to overlap. For example,; /// p' = store_pi(p, b); /// = load p, offset; /// In this case p and p' overlap, which means that two registers are needed.; /// Instead, this function changes the load to use p' and updates the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:167,Performance,load,load,167,"/// Attempt to fix the degenerate cases when the instruction serialization; /// causes the register lifetimes to overlap. For example,; /// p' = store_pi(p, b); /// = load p, offset; /// In this case p and p' overlap, which means that two registers are needed.; /// Instead, this function changes the load to use p' and updates the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:301,Performance,load,load,301,"/// Attempt to fix the degenerate cases when the instruction serialization; /// causes the register lifetimes to overlap. For example,; /// p' = store_pi(p, b); /// = load p, offset; /// In this case p and p' overlap, which means that two registers are needed.; /// Instead, this function changes the load to use p' and updates the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:126,Deployability,update,updated,126,"// Check that the instruction appears in the InstrChanges structure,; // which contains instructions that can have the offset updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:3,Deployability,Update,Update,3,// Update the base register and adjust the offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:109,Energy Efficiency,allocate,allocated,109,"// Look for an instruction of the form p' = op(p), which uses and defines; // two virtual registers that get allocated to the same physical register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Energy Efficiency,schedul,schedule,14,"/// After the schedule has been formed, call this function to combine; /// the instructions from the different stages/cycles. That is, this; /// function creates a schedule that represents a single iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:164,Energy Efficiency,schedul,schedule,164,"/// After the schedule has been formed, call this function to combine; /// the instructions from the different stages/cycles. That is, this; /// function creates a schedule that represents a single iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:91,Energy Efficiency,schedul,scheduled,91,"// Erase all the elements in the later stages. Only one iteration should; // remain in the scheduled list, and it contains all the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Energy Efficiency,schedul,schedule,14,/// Print the schedule information to the given output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:53,Energy Efficiency,schedul,schedule,53,/// Utility function used for debugging to print the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:93,Availability,Mask,Masks,93,// We currently limit the resource kinds to 64 and below so that we can use; // uint64_t for Masks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,Availability,avail,available,42,"// Sort the instructions by the number of available choices for scheduling,; // least to most. Use the number of critical resources as the tie breaker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:64,Energy Efficiency,schedul,scheduling,64,"// Sort the instructions by the number of available choices for scheduling,; // least to most. Use the number of critical resources as the tie breaker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:23,Energy Efficiency,consumption,consumption,23,// Count each resource consumption and divide it by the number of units.; // ResMII is the max value among them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePostDominators.cpp:404,Usability,simpl,simple,404,"//===- MachinePostDominators.cpp -Machine Post Dominator Calculation ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements simple dominator construction algorithms for finding; // post dominators on machine functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePostDominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePostDominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp:18,Availability,avail,available,18,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp:155,Performance,optimiz,optimization,155,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:4,Usability,clear,clearVirtRegs,4,/// clearVirtRegs - Remove all virtual registers (after physreg assignment).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:3,Deployability,Update,Update,3,// Update Prev pointer. This also works when Src was pointing to itself; // in a 1-element list. In that case Head == Dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:28,Energy Efficiency,efficient,efficient,28,// TODO: This could be more efficient by bulk changing the operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:179,Modifiability,extend,extend,179,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:153,Performance,optimiz,optimization,153,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:4,Usability,clear,clearKillFlags,4,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:78,Usability,clear,clear,78,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:88,Safety,avoid,avoid,88,"// The livein has no non-dbg uses. Drop it.; //; // It would be preferable to have isel avoid creating live-in; // records for unused arguments in the first place, but it's; // complicated by the debug info code for arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:8,Availability,mask,masks,8,// Lane masks are only defined for vregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:50,Energy Efficiency,Schedul,Scheduler,50,"//===- MachineScheduler.cpp - Machine Instruction Scheduler ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:400,Energy Efficiency,schedul,schedules,400,"//===- MachineScheduler.cpp - Machine Instruction Scheduler ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:49,Integrability,depend,depend,49,"/// In some situations a few uninteresting nodes depend on nearly all other; /// nodes in the graph, provide a cutoff to hide them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Safety,Avoid,Avoid,15,// NDEBUG; /// Avoid quadratic complexity in unusually large basic blocks by limiting the; /// size of the ready lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:105,Energy Efficiency,Schedul,Scheduling,105,//===----------------------------------------------------------------------===//; // Machine Instruction Scheduling Pass and Registry; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,scheduler,29,/// Base class for a machine scheduler class that can run at any point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Energy Efficiency,schedul,scheduler,20,/// A dummy default scheduler factory indicates whether the scheduler; /// is overridden on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:60,Energy Efficiency,schedul,scheduler,60,/// A dummy default scheduler factory indicates whether the scheduler; /// is overridden on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:57,Energy Efficiency,schedul,scheduler,57,/// MachineSchedOpt allows command line selection of the scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Energy Efficiency,Schedul,ScheduleDAGInstrs,18,/// Instantiate a ScheduleDAGInstrs that will be owned by the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduler,14,"// Select the scheduler, or set the default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:19,Energy Efficiency,schedul,scheduler,19,// Get the default scheduler set by the target for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Energy Efficiency,Schedul,ScheduleDAGInstrs,18,/// Instantiate a ScheduleDAGInstrs for PostRA scheduling that will be owned by; /// the caller. We don't have a command line option to override the postRA; /// scheduler. The Target must configure it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:47,Energy Efficiency,schedul,scheduling,47,/// Instantiate a ScheduleDAGInstrs for PostRA scheduling that will be owned by; /// the caller. We don't have a command line option to override the postRA; /// scheduler. The Target must configure it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:161,Energy Efficiency,schedul,scheduler,161,/// Instantiate a ScheduleDAGInstrs for PostRA scheduling that will be owned by; /// the caller. We don't have a command line option to override the postRA; /// scheduler. The Target must configure it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:188,Modifiability,config,configure,188,/// Instantiate a ScheduleDAGInstrs for PostRA scheduling that will be owned by; /// the caller. We don't have a command line option to override the postRA; /// scheduler. The Target must configure it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Energy Efficiency,schedul,scheduler,18,// Get the postRA scheduler set by the target for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:723,Deployability,update,update,723,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:109,Energy Efficiency,schedul,scheduling,109,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:289,Energy Efficiency,schedul,scheduling,289,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:357,Energy Efficiency,schedul,scheduling,357,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:524,Energy Efficiency,schedul,schedulers,524,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:558,Energy Efficiency,schedul,scheduling,558,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:708,Energy Efficiency,schedul,scheduler,708,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:785,Energy Efficiency,Schedul,ScheduleDAGInstrs,785,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:900,Energy Efficiency,schedul,scheduling,900,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:770,Performance,cache,cached,770,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:341,Safety,avoid,avoids,341,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:404,Usability,simpl,simplifying,404,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:852,Usability,simpl,simpler,852,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:1006,Usability,simpl,simplicity,1006,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,Energy Efficiency,schedul,scheduler,28,"// Instantiate the selected scheduler for this target, function, and; // optimization level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:73,Performance,optimiz,optimization,73,"// Instantiate the selected scheduler for this target, function, and; // optimization level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,Energy Efficiency,schedul,scheduler,28,"// Instantiate the selected scheduler for this target, function, and; // optimization level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:73,Performance,optimiz,optimization,73,"// Instantiate the selected scheduler for this target, function, and; // optimization level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:69,Energy Efficiency,schedul,scheduling,69,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:147,Energy Efficiency,schedul,scheduling,147,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:352,Energy Efficiency,schedul,scheduling,352,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:415,Energy Efficiency,schedul,scheduling,415,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:450,Energy Efficiency,schedul,scheduling,450,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:551,Energy Efficiency,schedul,scheduling,551,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:267,Integrability,depend,dependencies,267,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,Energy Efficiency,schedul,scheduling,27,/// A region of an MBB for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:48,Energy Efficiency,schedul,scheduling,48,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:114,Energy Efficiency,schedul,scheduling,114,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:173,Energy Efficiency,schedul,scheduling,173,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:268,Energy Efficiency,schedul,scheduling,268,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:329,Energy Efficiency,schedul,scheduling,329,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid decrementing RegionEnd for blocks with no terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,Energy Efficiency,schedul,scheduling,28,// It's possible we found a scheduling region that only has debug; // instructions. Don't bother scheduling these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:97,Energy Efficiency,schedul,scheduling,97,// It's possible we found a scheduling region that only has debug; // instructions. Don't bother scheduling these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:467,Availability,down,down,467,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:24,Energy Efficiency,schedul,scheduling,24,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:87,Energy Efficiency,schedul,scheduling,87,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:510,Energy Efficiency,Schedul,Scheduler,510,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:558,Energy Efficiency,schedul,schedule,558,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduler,14,"// Notify the scheduler of the region, even if we may skip scheduling; // it. Perhaps it still needs to be bundled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:59,Energy Efficiency,schedul,scheduling,59,"// Notify the scheduler of the region, even if we may skip scheduling; // it. Perhaps it still needs to be bundled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduling,14,// Skip empty scheduling regions (0 or 1 schedulable instructions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:41,Energy Efficiency,schedul,schedulable,41,// Skip empty scheduling regions (0 or 1 schedulable instructions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,Schedule,3,// Schedule a region: possibly reorder instructions.; // This invalidates the original region iterators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:85,Energy Efficiency,Schedul,ScheduleDAGMI,85,//===----------------------------------------------------------------------===//; // ScheduleDAGMI - Basic machine instruction scheduling. This is; // independent of PreRA/PostRA scheduling and involves no extra book-keeping for; // virtual registers.; // ===----------------------------------------------------------------------===/; // Provide a vtable anchor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:127,Energy Efficiency,schedul,scheduling,127,//===----------------------------------------------------------------------===//; // ScheduleDAGMI - Basic machine instruction scheduling. This is; // independent of PreRA/PostRA scheduling and involves no extra book-keeping for; // virtual registers.; // ===----------------------------------------------------------------------===/; // Provide a vtable anchor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:179,Energy Efficiency,schedul,scheduling,179,//===----------------------------------------------------------------------===//; // ScheduleDAGMI - Basic machine instruction scheduling. This is; // independent of PreRA/PostRA scheduling and involves no extra book-keeping for; // virtual registers.; // ===----------------------------------------------------------------------===/; // Provide a vtable anchor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Release,ReleaseSucc,4,"/// ReleaseSucc - Decrement the NumPredsLeft count of a successor. When; /// NumPredsLeft reaches zero, release the successor node.; ///; /// FIXME: Adjust SuccSU height based on MinLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:104,Deployability,release,release,104,"/// ReleaseSucc - Decrement the NumPredsLeft count of a successor. When; /// NumPredsLeft reaches zero, release the successor node.; ///; /// FIXME: Adjust SuccSU height based on MinLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,Energy Efficiency,schedul,scheduled,54,"// SU->TopReadyCycle was set to CurrCycle when it was scheduled. However,; // CurrCycle may have advanced since then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,release,releaseSuccessors,4,/// releaseSuccessors - Call releaseSucc on each of SU's successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Deployability,release,releaseSucc,29,/// releaseSuccessors - Call releaseSucc on each of SU's successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Release,ReleasePred,4,"/// ReleasePred - Decrement the NumSuccsLeft count of a predecessor. When; /// NumSuccsLeft reaches zero, release the predecessor node.; ///; /// FIXME: Adjust PredSU height based on MinLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:106,Deployability,release,release,106,"/// ReleasePred - Decrement the NumSuccsLeft count of a predecessor. When; /// NumSuccsLeft reaches zero, release the predecessor node.; ///; /// FIXME: Adjust PredSU height based on MinLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,Energy Efficiency,schedul,scheduled,54,"// SU->BotReadyCycle was set to CurrCycle when it was scheduled. However,; // CurrCycle may have advanced since then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,release,releasePredecessors,4,/// releasePredecessors - Call releasePred on each of SU's predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:31,Deployability,release,releasePred,31,/// releasePredecessors - Call releasePred on each of SU's predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:100,Energy Efficiency,schedul,scheduling,100,"/// enterRegion - Called back from PostMachineScheduler::runOnMachineFunction; /// after crossing a scheduling boundary. [begin, end) includes all instructions; /// in the region, including the boundary itself and single-instruction regions; /// that don't get scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:261,Energy Efficiency,schedul,scheduled,261,"/// enterRegion - Called back from PostMachineScheduler::runOnMachineFunction; /// after crossing a scheduling boundary. [begin, end) includes all instructions; /// in the region, including the boundary itself and single-instruction regions; /// that don't get scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Energy Efficiency,schedul,scheduler,42,/// This is normally called from the main scheduler loop but may also be invoked; /// by the scheduling strategy to perform additional code motion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:93,Energy Efficiency,schedul,scheduling,93,/// This is normally called from the main scheduler loop but may also be invoked; /// by the scheduling strategy to perform additional code motion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:116,Performance,perform,perform,116,/// This is normally called from the main scheduler loop but may also be invoked; /// by the scheduling strategy to perform additional code motion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,Availability,down,down,54,// Advance RegionBegin if the first instruction moves down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update the instruction stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:2,Deployability,Update,UpdateFlags,2,/*UpdateFlags=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Energy Efficiency,schedul,scheduling,15,"/// Per-region scheduling driver, called back from; /// PostMachineScheduler::runOnMachineFunction. This is a simplified driver; /// that does not consider liveness or register pressure. It is useful for; /// PostRA scheduling and potentially other custom schedulers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:216,Energy Efficiency,schedul,scheduling,216,"/// Per-region scheduling driver, called back from; /// PostMachineScheduler::runOnMachineFunction. This is a simplified driver; /// that does not consider liveness or register pressure. It is useful for; /// PostRA scheduling and potentially other custom schedulers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:256,Energy Efficiency,schedul,schedulers,256,"/// Per-region scheduling driver, called back from; /// PostMachineScheduler::runOnMachineFunction. This is a simplified driver; /// that does not consider liveness or register pressure. It is useful for; /// PostRA scheduling and potentially other custom schedulers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:110,Usability,simpl,simplified,110,"/// Per-region scheduling driver, called back from; /// PostMachineScheduler::runOnMachineFunction. This is a simplified driver; /// that does not consider liveness or register pressure. It is useful for; /// PostRA scheduling and potentially other custom schedulers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:104,Performance,queue,queue,104,// Initialize the strategy before modifying the DAG.; // This may initialize a DFSResult to be used for queue priority.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Performance,queue,queues,20,// Initialize ready queues now that the DAG and priority data are finalized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:124,Deployability,update,updateQueues,124,"// Notify the scheduling strategy before updating the DAG.; // This sets the scheduled node's ReadyCycle to CurrCycle. When updateQueues; // runs, it can then use the accurate ReadyCycle time to determine whether; // newly released nodes can move to the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:223,Deployability,release,released,223,"// Notify the scheduling strategy before updating the DAG.; // This sets the scheduled node's ReadyCycle to CurrCycle. When updateQueues; // runs, it can then use the accurate ReadyCycle time to determine whether; // newly released nodes can move to the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduling,14,"// Notify the scheduling strategy before updating the DAG.; // This sets the scheduled node's ReadyCycle to CurrCycle. When updateQueues; // runs, it can then use the accurate ReadyCycle time to determine whether; // newly released nodes can move to the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:77,Energy Efficiency,schedul,scheduled,77,"// Notify the scheduling strategy before updating the DAG.; // This sets the scheduled node's ReadyCycle to CurrCycle. When updateQueues; // runs, it can then use the accurate ReadyCycle time to determine whether; // newly released nodes can move to the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Energy Efficiency,Schedul,ScheduleDAGMutation,15,/// Apply each ScheduleDAGMutation step in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,Energy Efficiency,schedul,schedule,27,// A SUnit is ready to top schedule if it has no predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,Energy Efficiency,schedul,schedule,30,// A SUnit is ready to bottom schedule if it has no successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:33,Energy Efficiency,schedul,scheduler,33,/// Identify DAG roots and setup scheduler queues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:43,Performance,queue,queues,43,/// Identify DAG roots and setup scheduler queues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Release,Release,3,"// Release all DAG roots for scheduling, not including EntrySU/ExitSU.; //; // Nodes with unreleased weak edges can still be roots.; // Release top roots in forward order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:136,Deployability,Release,Release,136,"// Release all DAG roots for scheduling, not including EntrySU/ExitSU.; //; // Nodes with unreleased weak edges can still be roots.; // Release top roots in forward order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,scheduling,29,"// Release all DAG roots for scheduling, not including EntrySU/ExitSU.; //; // Nodes with unreleased weak edges can still be roots.; // Release top roots in forward order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Release,Release,3,// Release bottom roots in reverse order so the higher priority nodes appear; // first. This is more natural and slightly more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:127,Energy Efficiency,efficient,efficient,127,// Release bottom roots in reverse order so the higher priority nodes appear; // first. This is more natural and slightly more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Update,Update,4,/// Update scheduler queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:11,Energy Efficiency,schedul,scheduler,11,/// Update scheduler queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:34,Energy Efficiency,schedul,scheduling,34,/// Update scheduler queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:21,Performance,queue,queues,21,/// Update scheduler queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Release,Release,3,// Release dependent instructions for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:38,Energy Efficiency,schedul,scheduling,38,// Release dependent instructions for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:11,Integrability,depend,dependent,11,// Release dependent instructions for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:62,Energy Efficiency,schedul,scheduler,62,"/// Reinsert any remaining debug_values, just like the PostRA scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,schedule,29,// Bail off when there is no schedule model to query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,schedule,29,// Bail off when there is no schedule model to query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:85,Energy Efficiency,Schedul,ScheduleDAGMILive,85,//===----------------------------------------------------------------------===//; // ScheduleDAGMILive - Base class for MachineInstr scheduling with LiveIntervals; // preservation.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:133,Energy Efficiency,schedul,scheduling,133,//===----------------------------------------------------------------------===//; // ScheduleDAGMILive - Base class for MachineInstr scheduling with LiveIntervals; // preservation.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:96,Energy Efficiency,schedul,scheduling,96,"/// enterRegion - Called back from MachineScheduler::runOnMachineFunction after; /// crossing a scheduling boundary. [begin, end) includes all instructions in; /// the region, including the boundary itself and single-instruction regions; /// that don't get scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:257,Energy Efficiency,schedul,scheduled,257,"/// enterRegion - Called back from MachineScheduler::runOnMachineFunction after; /// crossing a scheduling boundary. [begin, end) includes all instructions in; /// the region, including the boundary itself and single-instruction regions; /// that don't get scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,ScheduleDAGMI,3,// ScheduleDAGMI initializes SchedImpl's per-region policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Energy Efficiency,schedul,scheduled,52,// Setup the register pressure trackers for the top scheduled and bottom; // scheduled regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:77,Energy Efficiency,schedul,scheduled,77,// Setup the register pressure trackers for the top scheduled and bottom; // scheduled regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:64,Availability,Down,DownwardPressureDelta,64,// Close one end of the tracker so we can call; // getMaxUpward/DownwardPressureDelta before advancing across any; // instructions. This converts currently live regs into live ins/outs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,Energy Efficiency,reduce,reduce,26,// For each live out vreg reduce the pressure change associated with other; // uses of the same vreg below the live-out reaching def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:107,Energy Efficiency,schedul,scheduled,107,// Cache the list of excess pressure sets in this region. This will also track; // the max pressure in the scheduled code for these sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Performance,Cache,Cache,3,// Cache the list of excess pressure sets in this region. This will also track; // the max pressure in the scheduled code for these sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Update,Update,4,/// Update the PressureDiff array for liveness after scheduling this; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:53,Energy Efficiency,schedul,scheduling,53,/// Update the PressureDiff array for liveness after scheduling this; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:631,Deployability,update,update,631,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Energy Efficiency,schedul,schedule,4,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:105,Energy Efficiency,schedul,scheduling,105,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:206,Energy Efficiency,schedul,scheduling,206,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:369,Energy Efficiency,schedul,schedulers,369,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:476,Energy Efficiency,schedul,scheduling,476,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:512,Energy Efficiency,schedul,scheduler,512,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:546,Energy Efficiency,Schedul,ScheduleDAGMILive,546,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:344,Modifiability,extend,extended,344,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:104,Performance,queue,queue,104,// Initialize the strategy before modifying the DAG.; // This may initialize a DFSResult to be used for queue priority.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Performance,queue,queues,20,// Initialize ready queues now that the DAG and priority data are finalized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduling,14,// Notify the scheduling strategy after updating the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:311,Availability,avail,available,311,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:62,Energy Efficiency,schedul,scheduling,62,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:336,Energy Efficiency,schedul,scheduler,336,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:1197,Energy Efficiency,schedul,scheduling,1197,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:585,Performance,latency,latency,585,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:124,Performance,latency,latency,124,"// Assume that a path spanning two iterations is a cycle, which could; // overestimate in strange cases. This allows cyclic latency to be; // estimated as the minimum slack of the vreg's depth or height.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Release,Release,4,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Energy Efficiency,schedul,scheduler,42,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Performance,queue,queues,52,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,Deployability,update,update,28,/// Move an instruction and update register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update top scheduled pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduled,14,// Update top scheduled pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:143,Performance,load,loads,143,//===----------------------------------------------------------------------===//; // BaseMemOpClusterMutation - DAG post-processing to cluster loads or stores.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:74,Performance,load,loads,74,/// Post-process the DAG to create cluster edges between neighboring; /// loads or between neighboring stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:101,Availability,avail,available,101,// FIXME: Don't compare everything twice. Maybe use C++20 three way; // comparison instead when it's available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:164,Integrability,depend,dependent,164,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:352,Integrability,depend,dependencies,352,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Performance,load,loads,42,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:76,Performance,load,load,76,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:115,Performance,load,load,115,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:286,Performance,load,loads,286,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,Integrability,depend,dependent,56,// Decision to cluster mem ops is taken based on target dependent logic,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:66,Testability,log,logic,66,// Decision to cluster mem ops is taken based on target dependent logic,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:21,Performance,load,load,21,// Seek for the next load/store to do the cluster.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Integrability,depend,dependency,52,// Skip if MemOpb has been clustered already or has dependency with; // MemOpa.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:70,Integrability,depend,dependent,70,// Copy successor edges from SUa to SUb. Interleaving computation; // dependent on SUa can prevent load combining due to register reuse.; // Predecessor edges do not need to be copied from SUb to SUa since; // nearby loads should have effectively the same inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:99,Performance,load,load,99,// Copy successor edges from SUa to SUb. Interleaving computation; // dependent on SUa can prevent load combining due to register reuse.; // Predecessor edges do not need to be copied from SUb to SUa since; // nearby loads should have effectively the same inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:217,Performance,load,loads,217,// Copy successor edges from SUa to SUb. Interleaving computation; // dependent on SUa can prevent load combining due to register reuse.; // Predecessor edges do not need to be copied from SUb to SUa since; // nearby loads should have effectively the same inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:88,Energy Efficiency,schedul,scheduled,88,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:75,Integrability,depend,dependent,75,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:201,Integrability,depend,depend,201,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:279,Integrability,depend,dependency,279,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:350,Integrability,depend,dependency,350,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:45,Safety,avoid,avoid,45,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:112,Integrability,depend,dependency,112,"// We only want to cluster the mem ops that have the same ctrl(non-data); // pred so that they didn't have ctrl dependency for each other. But for; // store instrs, we can still cluster them if the pred is load instr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:206,Performance,load,load,206,"// We only want to cluster the mem ops that have the same ctrl(non-data); // pred so that they didn't have ctrl dependency for each other. But for; // store instrs, we can still cluster them if the pred is load instr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:65,Performance,load,loads,65,/// Callback from DAG postProcessing to create cluster edges for loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:31,Performance,load,loads,31,// Collect all the clusterable loads/stores,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:32,Integrability,depend,dependency,32,"// Put the loads/stores without dependency into the same group with some; // heuristic if the DAG is too complex to avoid compiling time blow up.; // Notice that, some fusion pair could be lost with this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:11,Performance,load,loads,11,"// Put the loads/stores without dependency into the same group with some; // heuristic if the DAG is too complex to avoid compiling time blow up.; // Notice that, some fusion pair could be lost with this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:116,Safety,avoid,avoid,116,"// Put the loads/stores without dependency into the same group with some; // heuristic if the DAG is too complex to avoid compiling time blow up.; // Notice that, some fusion pair could be lost with this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Performance,load,loads,15,"// Sorting the loads/stores, so that, we can stop the cluster as early as; // possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:41,Performance,load,loads,41,// Trying to cluster all the neighboring loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:157,Modifiability,variab,variable,157,"/// Post-process the DAG to create weak edges from all uses of a copy to; /// the one use that defines the copy's source vreg, most likely an induction; /// variable increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:79,Energy Efficiency,schedul,scheduling,79,// RegionEndIdx is the slot index of the last non-debug instruction in the; // scheduling region. So we may have RegionBeginIdx == RegionEndIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:476,Modifiability,extend,extended,476,"// end namespace llvm; /// constrainLocalCopy handles two possibilities:; /// 1) Local src:; /// I0: = dst; /// I1: src = ...; /// I2: = dst; /// I3: dst = src (copy); /// (create pred->succ edges I0->I1, I2->I1); ///; /// 2) Local copy:; /// I0: dst = src (copy); /// I1: = dst; /// I2: src = ...; /// I3: = dst; /// (create pred->succ edges I1->I2, I3->I2); ///; /// Although the MachineScheduler is currently constrained to single blocks,; /// this algorithm should handle extended blocks. An EBB is a set of; /// contiguously numbered blocks such that the previous block in the EBB is; /// always the single predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:216,Energy Efficiency,schedul,scheduling,216,"// Check if either the dest or source is local. If it's live across a back; // edge, it's not local. Note that if both vregs are live across the back; // edge, we cannot successfully contrain the copy without cyclic scheduling.; // If both the copy's source and dest are local live intervals, then we; // should treat the dest as the global for the purpose of adding; // constraints. This adds edges from source's other uses to the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:191,Energy Efficiency,schedul,schedulers,191,"//===----------------------------------------------------------------------===//; // MachineSchedStrategy helpers used by GenericScheduler, GenericPostScheduler; // and possibly other custom schedulers.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:149,Energy Efficiency,schedul,scheduling,149,"/// Given a Count of resource usage and a Latency value, return true if a; /// SchedBoundary becomes resource limited.; /// If we are checking after scheduling a node, we should return true when; /// we just reach the resource limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Performance,Latency,Latency,42,"/// Given a Count of resource usage and a Latency value, return true if a; /// SchedBoundary becomes resource limited.; /// If we are checking after scheduling a node, we should return true when; /// we just reach the resource limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:9,Safety,Hazard,HazardRec,9,"// A new HazardRec is created for each DAG and owned by SchedBoundary.; // Destroying and reconstructing it is very expensive though. So keep; // invalid, placeholder HazardRecs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:167,Safety,Hazard,HazardRecs,167,"// A new HazardRec is created for each DAG and owned by SchedBoundary.; // Destroying and reconstructing it is very expensive though. So keep; // invalid, placeholder HazardRecs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:81,Performance,latency,latency,81,// Track the maximum number of stall cycles that could arise either from the; // latency of a DAG edge or the number of cycles that a processor resource is; // reserved (SchedBoundary::ReservedCycles).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:312,Availability,avail,available,312,"/// Compute the stall cycles based on this SUnit's ready time. Heuristics treat; /// these ""soft stalls"" differently than the hard stall cycles based on CPU; /// resources and computed by checkHazard(). A fully in-order model; /// (MicroOpBufferSize==0) will not make use of this since instructions are not; /// available for scheduling until they are ready. However, a weaker in-order; /// model may use this for heuristics. For example, if a processor has in-order; /// behavior when reading certain resources, this may come into play.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:326,Energy Efficiency,schedul,scheduling,326,"/// Compute the stall cycles based on this SUnit's ready time. Heuristics treat; /// these ""soft stalls"" differently than the hard stall cycles based on CPU; /// resources and computed by checkHazard(). A fully in-order model; /// (MicroOpBufferSize==0) will not make use of this since instructions are not; /// available for scheduling until they are ready. However, a weaker in-order; /// model may use this for heuristics. For example, if a processor has in-order; /// behavior when reading certain resources, this may come into play.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:82,Energy Efficiency,schedul,scheduled,82,/// Compute the next cycle at which the given processor resource unit; /// can be scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:17,Energy Efficiency,schedul,scheduling,17,// For bottom-up scheduling add the cycles needed for the current operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:77,Energy Efficiency,schedul,scheduled,77,/// Compute the next cycle at which the given processor resource can be; /// scheduled. Returns the next cycle and the index of the processor resource; /// instance in the reserved cycles vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:103,Availability,avail,available,103,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:157,Availability,avail,available,157,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:316,Availability,avail,available,316,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:513,Energy Efficiency,schedul,schedule,513,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:215,Safety,hazard,hazarding,215,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:240,Safety,hazard,hazarding,240,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:83,Energy Efficiency,schedul,scheduler,83,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:157,Energy Efficiency,Schedul,ScheduleHazardRecognizer,157,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:475,Energy Efficiency,schedul,scheduler,475,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:24,Safety,hazard,hazard,24,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:115,Safety,hazard,hazard,115,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:209,Safety,hazard,hazard,209,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:428,Safety,hazard,hazards,428,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:357,Testability,log,logic,357,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:450,Usability,simpl,simple,450,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:58,Performance,latency,latency,58,// Find the unscheduled node in ReadySUs with the highest latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:73,Energy Efficiency,schedul,scheduled,73,"// ReadyCycle was been bumped up to the CurrCycle when this node was; // scheduled, but CurrCycle may have been eagerly advanced immediately after; // scheduling, so may now be greater than ReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:151,Energy Efficiency,schedul,scheduling,151,"// ReadyCycle was been bumped up to the CurrCycle when this node was; // scheduled, but CurrCycle may have been eagerly advanced immediately after; // scheduling, so may now be greater than ReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,Safety,interlock,interlocks,13,"// Check for interlocks first. For the purpose of other heuristics, an; // instruction that cannot issue appears as if it's not in the ReadyQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,Security,interlock,interlocks,13,"// Check for interlocks first. For the purpose of other heuristics, an; // instruction that cannot issue appears as if it's not in the ReadyQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:25,Energy Efficiency,schedul,scheduled,25,/// Move the boundary of scheduled code by one cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,"// Update the current micro-ops, which will issue in the next cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,Integrability,Depend,DependentLatency,13,// Decrement DependentLatency based on the next cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:10,Safety,Hazard,HazardRec,10,// Bypass HazardRec virtual calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:46,Performance,latency,latency,46,// Bypass getHazardType calls in case of long latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:78,Deployability,Release,ReleaseAtCycle,78,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:134,Deployability,pipeline,pipelined,134,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:187,Deployability,release,released,187,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:270,Deployability,pipeline,pipelined,270,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:45,Energy Efficiency,schedul,scheduled,45,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update Executed resources counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:25,Energy Efficiency,schedul,scheduled,25,/// Move the boundary of scheduled code by one SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update the reservation table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:98,Deployability,pipeline,pipeline,98,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,Energy Efficiency,schedul,scheduled,13,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:76,Energy Efficiency,schedul,scheduling,76,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:88,Usability,clear,clear,88,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:64,Availability,avail,available,64,// Scheduling an instruction may have made pending instructions available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling an instruction may have made pending instructions available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,Energy Efficiency,schedul,scheduling,30,// checkHazard should prevent scheduling multiple instructions per cycle that; // exceed the issue width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:72,Energy Efficiency,schedul,scheduled,72,"// We don't currently model the OOO reorder buffer, so consider all; // scheduled MOps to be ""retired"". We do loosely model in-order resource; // latency. If this instruction uses an in-order resource, account for any; // likely stall cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:146,Performance,latency,latency,146,"// We don't currently model the OOO reorder buffer, so consider all; // scheduled MOps to be ""retired"". We do loosely model in-order resource; // latency. If this instruction uses an in-order resource, account for any; // likely stall cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update resource counts and critical resource.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:9,Energy Efficiency,schedul,scheduled,9,// Scale scheduled micro-ops for comparing with the critical resource.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:84,Availability,down,down,84,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:89,Energy Efficiency,schedul,scheduling,89,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:131,Energy Efficiency,schedul,schedule,131,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:249,Usability,simpl,simply,249,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update ExpectedLatency and DependentLatency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,Integrability,Depend,DependentLatency,30,// Update ExpectedLatency and DependentLatency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,"// Update CurrMOps after calling bumpCycle to handle stalls, since bumpCycle; // resets CurrMOps. Loop to handle instructions with more MOps than issue in; // one cycle. Since we commonly reach the max MOps here, opportunistically; // bump the cycle to avoid uselessly checking everything in the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:253,Safety,avoid,avoid,253,"// Update CurrMOps after calling bumpCycle to handle stalls, since bumpCycle; // resets CurrMOps. Loop to handle instructions with more MOps than issue in; // one cycle. Since we commonly reach the max MOps here, opportunistically; // bump the cycle to avoid uselessly checking everything in the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:159,Energy Efficiency,reduce,reduce,159,// Bump the cycle count for issue group constraints.; // This must be done after NextCycle has been adjust for all other stalls.; // Calling bumpCycle(X) will reduce CurrMOps by one issue group and set; // currCycle to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Availability,avail,available,42,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Release,Release,4,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Performance,queue,queue,52,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:10,Availability,avail,available,10,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Performance,queue,queue,20,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Safety,safe,safe,42,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:98,Availability,avail,available,98,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:108,Performance,queue,queue,108,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:12,Performance,queue,queue,12,"/// If this queue only has one ready candidate, return it. As a side effect,; /// defer any nodes that now hit a hazard, and advance the cycle until at least; /// one node is ready. If multiple instructions are ready, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:113,Safety,hazard,hazard,113,"/// If this queue only has one ready candidate, return it. As a side effect,; /// defer any nodes that now hit a hazard, and advance the cycle until at least; /// one node is ready. If multiple instructions are ready, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Safety,hazard,hazard,42,// Defer any ready instrs that now have a hazard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:70,Safety,Hazard,HazardRec,70,"// FIXME: Re-enable assert once PR20057 is resolved.; // assert(i <= (HazardRec->getMaxLookAhead() + MaxObservedStall) &&; // ""permanent hazard"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:137,Safety,hazard,hazard,137,"// FIXME: Re-enable assert once PR20057 is resolved.; // assert(i <= (HazardRec->getMaxLookAhead() + MaxObservedStall) &&; // ""permanent hazard"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Testability,assert,assert,20,"// FIXME: Re-enable assert once PR20057 is resolved.; // assert(i <= (HazardRec->getMaxLookAhead() + MaxObservedStall) &&; // ""permanent hazard"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:57,Testability,assert,assert,57,"// FIXME: Re-enable assert once PR20057 is resolved.; // assert(i <= (HazardRec->getMaxLookAhead() + MaxObservedStall) &&; // ""permanent hazard"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:72,Performance,Queue,Queue,72,// This is useful information to dump after bumpNode.; // Note that the Queue contents are more useful before pickNodeFromQueue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:546,Availability,Avail,Available,546,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:245,Deployability,update,updated,245,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:87,Energy Efficiency,schedul,schedule,87,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:274,Energy Efficiency,schedul,scheduling,274,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:317,Energy Efficiency,schedul,scheduled,317,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:368,Energy Efficiency,schedul,scheduled,368,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:223,Integrability,depend,dependent,223,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:625,Integrability,depend,dependent,625,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:22,Performance,latency,latency,22,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:107,Performance,latency,latency-limited,107,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:191,Performance,latency,latency,191,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:234,Performance,latency,latency,234,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:475,Performance,latency,latency,475,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:500,Performance,queue,queue,500,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:635,Performance,latency,latency,635,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:106,Energy Efficiency,schedul,scheduling,106,/// Returns true if the current cycle plus remaning latency is greater than; /// the critical path in the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Performance,latency,latency,52,/// Returns true if the current cycle plus remaning latency is greater than; /// the critical path in the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:86,Performance,latency,latency,86,"// The current cycle is already greater than the critical path, so we are; // already latency limited and don't need to compute the remaining latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:142,Performance,latency,latency,142,"// The current cycle is already greater than the critical path, so we are; // already latency limited and don't need to compute the remaining latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:17,Energy Efficiency,schedul,scheduled,17,"// If we haven't scheduled anything yet, then we aren't latency limited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,Performance,latency,latency,56,"// If we haven't scheduled anything yet, then we aren't latency limited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:31,Energy Efficiency,schedul,scheduling,31,/// Set the CandPolicy given a scheduling zone given the current resources and; /// latencies inside and outside the zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:50,Performance,latency,latency,50,// Apply preemptive heuristics based on the total latency and resources; // inside and outside this zone. Potential stalls should be considered before; // following this policy.; // Compute the critical resource outside the zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule aggressively for latency in PostRA mode. We don't check for; // acyclic latency during PostRA, and highly out-of-order processors will; // skip PostRA scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:163,Energy Efficiency,schedul,scheduling,163,"// Schedule aggressively for latency in PostRA mode. We don't check for; // acyclic latency during PostRA, and highly out-of-order processors will; // skip PostRA scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Performance,latency,latency,29,"// Schedule aggressively for latency in PostRA mode. We don't check for; // acyclic latency during PostRA, and highly out-of-order processors will; // skip PostRA scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:84,Performance,latency,latency,84,"// Schedule aggressively for latency in PostRA mode. We don't check for; // acyclic latency during PostRA, and highly out-of-order processors will; // skip PostRA scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:72,Modifiability,refactor,refactor,72,"/// Return true if this heuristic determines order.; /// TODO: Consider refactor return type of these functions as integer or enum,; /// as we may need to differentiate whether TryCand is better than Cand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:116,Energy Efficiency,schedul,scheduled,116,"// Prefer the candidate with the lesser depth, but only if one of them has; // depth greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:172,Energy Efficiency,schedul,scheduled,172,"// Prefer the candidate with the lesser depth, but only if one of them has; // depth greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:108,Performance,latency,latency,108,"// Prefer the candidate with the lesser depth, but only if one of them has; // depth greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:118,Energy Efficiency,schedul,scheduled,118,"// Prefer the candidate with the lesser height, but only if one of them has; // height greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:174,Energy Efficiency,schedul,scheduled,174,"// Prefer the candidate with the lesser height, but only if one of them has; // height greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:110,Performance,latency,latency,110,"// Prefer the candidate with the lesser height, but only if one of them has; // height greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:50,Safety,Hazard,HazardRecognizers,50,"// Initialize resource counts.; // Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:140,Safety,Hazard,HazardRecs,140,"// Initialize resource counts.; // Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,Energy Efficiency,schedul,scheduling,30,/// Initialize the per-region scheduling policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:159,Energy Efficiency,schedul,schedulable,159,"// Avoid setting up the register pressure tracker for small regions to save; // compile time. As a rough heuristic, only track pressure when the number of; // schedulable instructions exceeds half the integer register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,"// Avoid setting up the register pressure tracker for small regions to save; // compile time. As a rough heuristic, only track pressure when the number of; // schedulable instructions exceeds half the integer register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:96,Performance,optimiz,optimizations,96,"// For generic targets, we default to bottom-up, because it's simpler and more; // compile-time optimizations have been implemented in that direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:62,Usability,simpl,simpler,62,"// For generic targets, we default to bottom-up, because it's simpler and more; // compile-time optimizations have been implemented in that direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,Energy Efficiency,schedul,scheduling,56,// Check -misched-topdown/bottomup can force or unforce scheduling direction.; // e.g. -misched-bottomup=false allows scheduling in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:118,Energy Efficiency,schedul,scheduling,118,// Check -misched-topdown/bottomup can force or unforce scheduling direction.; // e.g. -misched-bottomup=false allows scheduling in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:53,Deployability,release,release,53,// Cannot completely remove virtual function even in release mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:129,Energy Efficiency,drain,drain,129,"/// Set IsAcyclicLatencyLimited if the acyclic path is longer than the cyclic; /// critical path by more cycles than it takes to drain the instruction buffer.; /// We estimate an upper bounds on in-flight instructions as:; ///; /// CyclesPerIteration = max( CyclicPath, Loop-Resource-Height ); /// InFlightIterations = AcyclicPath / CyclesPerIteration; /// InFlightResources = InFlightIterations * LoopResources; ///; /// TODO: Check execution resources in addition to IssueCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:22,Energy Efficiency,schedul,scheduled,22,"// If we have already scheduled the physreg produce/consumer, immediately; // schedule the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:78,Energy Efficiency,schedul,schedule,78,"// If we have already scheduled the physreg produce/consumer, immediately; // schedule the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:58,Energy Efficiency,schedul,schedule,58,"// If the physreg is at the boundary, defer it. Otherwise schedule it; // immediately to free the dependent. We can hoist the copy later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:98,Integrability,depend,dependent,98,"// If the physreg is at the boundary, defer it. Otherwise schedule it; // immediately to free the dependent. We can hoist the copy later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:87,Energy Efficiency,schedul,scheduling,87,"// If we have a move immediate and all successors have been assigned, bias; // towards scheduling this later. Make sure all register defs are to; // physical registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:111,Energy Efficiency,efficient,efficient,111,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:520,Energy Efficiency,schedul,scheduled,520,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:547,Modifiability,extend,extending,547,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:239,Performance,queue,queue,239,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid exceeding the target's limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:53,Energy Efficiency,schedul,scheduled,53,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:118,Usability,simpl,simply,118,"// We only compare a subset of features when comparing nodes between; // Top and Bottom boundary. Some properties are simply incomparable, in many; // other instances we should only override the other boundary if something; // is a clear good pick on one boundary. Skip heuristics that are more; // ""tie-breaking"" in nature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:232,Usability,clear,clear,232,"// We only compare a subset of features when comparing nodes between; // Top and Bottom boundary. Some properties are simply incomparable, in many; // other instances we should only override the other boundary if something; // is a clear good pick on one boundary. Skip heuristics that are more; // ""tie-breaking"" in nature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:57,Energy Efficiency,schedul,schedule,57,"// For loops that are acyclic path limited, aggressively schedule for; // latency. Within an single cycle, whenever CurrMOps > 0, allow normal; // heuristics to take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:74,Performance,latency,latency,74,"// For loops that are acyclic path limited, aggressively schedule for; // latency. Within an single cycle, whenever CurrMOps > 0, allow normal; // heuristics to take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:46,Availability,down,downstream,46,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:94,Energy Efficiency,reduce,reduce,94,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:291,Energy Efficiency,schedul,scheduler,291,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:70,Performance,optimiz,optimizations,70,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:191,Performance,Optimiz,Optimizations,191,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:225,Performance,load,loads,225,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:323,Performance,load,loads,323,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing the max pressure of the entire region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,Energy Efficiency,consumption,consumption,27,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:55,Energy Efficiency,schedul,schedule,55,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:34,Integrability,depend,dependence,34,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,Performance,latency,latency,26,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:89,Performance,latency,latency,89,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:176,Energy Efficiency,schedul,scheduling,176,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:265,Energy Efficiency,schedul,scheduled,265,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:37,Performance,queue,queue,37,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:102,Performance,cache,cached,102,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:63,Performance,queue,queue,63,/// Pick the best candidate node from either the top or bottom queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule as far as possible in the direction of no choice. This is most; // efficient, but also provides the best heuristics for CriticalPSets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:79,Energy Efficiency,efficient,efficient,79,"// Schedule as far as possible in the direction of no choice. This is most; // efficient, but also provides the best heuristics for CriticalPSets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Availability,down,down,15,"// Set the top-down policy based on the state of the current top zone and; // the instructions outside the zone, including the bottom zone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,Energy Efficiency,schedul,scheduled,56,// See if BotCand is still valid (because we previously scheduled from Top).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:38,Energy Efficiency,schedul,schedule,38,/// Pick the best node to balance the schedule. Implements MachineSchedStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:16,Energy Efficiency,schedul,scheduled,16,// Find already scheduled copies with a single physreg dependence and move; // them just above the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:99,Energy Efficiency,schedul,scheduled,99,// Find already scheduled copies with a single physreg dependence and move; // them just above the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:55,Integrability,depend,dependence,55,// Find already scheduled copies with a single physreg dependence and move; // them just above the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Update,Update,4,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:164,Deployability,update,update,164,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Energy Efficiency,schedul,scheduler,15,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:39,Energy Efficiency,schedul,scheduling,39,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:132,Energy Efficiency,Schedul,ScheduleDAGMILive,132,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:43,Energy Efficiency,schedul,scheduler,43,/// Create the standard converging machine scheduler. This will be used as the; /// default scheduler if the target does not set a default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:92,Energy Efficiency,schedul,scheduler,92,/// Create the standard converging machine scheduler. This will be used as the; /// default scheduler if the target does not set a default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:48,Modifiability,extend,extend,48,// Register DAG post-processors.; //; // FIXME: extend the mutation API to allow earlier mutations to instantiate; // data and pass it to later mutations. Have a single mutation that gathers; // the interesting nodes in one pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Safety,Hazard,HazardRecognizers,18,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty,; // or are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:108,Safety,Hazard,HazardRecs,108,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty,; // or are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:60,Energy Efficiency,schedul,scheduling,60,"/// Apply a set of heuristics to a new candidate for PostRA scheduling.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,Energy Efficiency,consumption,consumption,27,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:55,Energy Efficiency,schedul,schedule,55,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:34,Integrability,depend,dependence,34,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,Performance,latency,latency,26,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,Energy Efficiency,schedul,schedule,26,/// Pick the next node to schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Availability,down,down,15,"// Set the top-down policy based on the state of the current top zone and; // the instructions outside the zone, including the bottom zone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:64,Deployability,update,updated,64,/// Called after ScheduleDAGMI has scheduled an instruction and updated; /// scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:17,Energy Efficiency,Schedul,ScheduleDAGMI,17,/// Called after ScheduleDAGMI has scheduled an instruction and updated; /// scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:35,Energy Efficiency,schedul,scheduled,35,/// Called after ScheduleDAGMI has scheduled an instruction and updated; /// scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:77,Energy Efficiency,schedul,scheduled,77,/// Called after ScheduleDAGMI has scheduled an instruction and updated; /// scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:89,Energy Efficiency,Schedul,Scheduler,89,//===----------------------------------------------------------------------===//; // ILP Scheduler. Currently for experimental analysis of heuristics.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Energy Efficiency,Schedul,Schedule,4,/// Schedule based on the ILP metric.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:39,Deployability,update,updated,39,// Restore the heap in ReadyQ with the updated DFS results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:35,Integrability,interface,interface,35,/// Implement MachineSchedStrategy interface.; /// -----------------------------------------; /// Callback to select the highest priority node from the ready Q.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Energy Efficiency,Schedul,Scheduler,4,/// Scheduler callback to notify that a new subtree is scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:55,Energy Efficiency,schedul,scheduled,55,/// Scheduler callback to notify that a new subtree is scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,scheduled,29,"/// Callback after a node is scheduled. Mark a newly scheduled tree, notify; /// DFSResults, and resort the priority Q.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:53,Energy Efficiency,schedul,scheduled,53,"/// Callback after a node is scheduled. Mark a newly scheduled tree, notify; /// DFSResults, and resort the priority Q.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:130,Testability,Test,Testing,130,//===----------------------------------------------------------------------===//; // Machine Instruction Shuffler for Correctness Testing; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:107,Energy Efficiency,schedul,scheduling,107,"/// Apply a less-than relation on the node order, which corresponds to the; /// instruction order prior to scheduling. IsReverse implements greater-than.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:167,Energy Efficiency,schedul,scheduled,167,// Using a less-than relation (SUnitOrder<false>) for the TopQ priority; // gives nodes with a higher number higher priority causing the latest; // instructions to be scheduled first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:8,Energy Efficiency,schedul,scheduling,8,"// When scheduling bottom-up, use greater-than as the queue priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,Performance,queue,queue,54,"// When scheduling bottom-up, use greater-than as the queue priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:35,Integrability,interface,interface,35,/// Implement MachineSchedStrategy interface.; /// -----------------------------------------,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:121,Energy Efficiency,Schedul,ScheduleDAGMILive,121,// !NDEBUG; //===----------------------------------------------------------------------===//; // GraphWriter support for ScheduleDAGMILive.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:708,Security,expose,exposed,708,"//===- MachineSink.cpp - Sinking for machine instructions -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass moves instructions into successor blocks when possible, so that; // they aren't executed on paths where their results aren't needed.; //; // This pass is not intended to be a replacement or a complete alternative; // for an LLVM-IR-level sinking pass. It is only designed to sink simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:673,Usability,simpl,simple,673,"//===- MachineSink.cpp - Sinking for machine instructions -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass moves instructions into successor blocks when possible, so that; // they aren't executed on paths where their results aren't needed.; //; // This pass is not intended to be a replacement or a complete alternative; // for an LLVM-IR-level sinking pass. It is only designed to sink simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:123,Modifiability,variab,variable,123,"/// DBG_VALUE pointer and flag. The flag is true if this DBG_VALUE is; /// post-dominated by another DBG_VALUE of the same variable location.; /// This is necessary to detect sequences such as:; /// %0 = someinst; /// DBG_VALUE %0, !123, !DIExpression(); /// %1 = anotherinst; /// DBG_VALUE %1, !123, !DIExpression(); /// Where if %0 were to sink, the DBG_VAUE should not sink with it, as that; /// would re-order assignments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:168,Safety,detect,detect,168,"/// DBG_VALUE pointer and flag. The flag is true if this DBG_VALUE is; /// post-dominated by another DBG_VALUE of the same variable location.; /// This is necessary to detect sequences such as:; /// %0 = someinst; /// DBG_VALUE %0, !123, !DIExpression(); /// %1 = anotherinst; /// DBG_VALUE %1, !123, !DIExpression(); /// Where if %0 were to sink, the DBG_VAUE should not sink with it, as that; /// would re-order assignments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:20,Modifiability,variab,variables,20,/// Record of debug variables that have had their locations set in the; /// current block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:4,Performance,Cache,Cached,4,/// Cached BB's register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:208,Deployability,update,updates,208,"/// Postpone the splitting of the given critical; /// edge (\p From, \p To).; ///; /// We do not split the edges on the fly. Indeed, this invalidates; /// the dominance information and thus triggers a lot of updates; /// of that information underneath.; /// Instead, we postpone all the splits after each iteration of; /// the main loop. That way, the information is at least valid; /// for the lifetime of an iteration.; ///; /// \return True if the edge is marked as toSplit, false otherwise.; /// False can be returned if, for instance, this is not profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:19,Usability,clear,clear,19,"// Conservatively, clear any kill flags, since it's possible that they are no; // longer correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:49,Integrability,depend,dependent,49,// Convergent operations may not be made control-dependent on additional; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:191,Usability,simpl,simplifies,191,// Don't sink defs/uses of hard registers or if the instruction defines more; // than one register.; // Don't sink more than two register uses - it'll cover most of the cases and; // greatly simplifies the register pressure checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:175,Performance,load,load,175,"// Scan uses of the destination register. Every use, except the last, must be; // a copy, with a chain of copies terminating with either a copy into a hard; // register, or a load/store instruction where the use is part of the; // address (*not* the stored value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:190,Modifiability,extend,extended,190,// If the register class of the register we are replacing is a superset; // of any of the register classes of the operands of the materialized; // instruction don't consider that live range extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:105,Availability,avail,available,105,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:244,Deployability,update,updated,244,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:15,Performance,perform,performing,15,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:319,Usability,clear,clear,319,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:77,Modifiability,extend,extended,77,"// The operand registers of the ""sunk"" instruction have their live range; // extended and their kill flags may no longer be correct. Conservatively; // clear the kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:152,Usability,clear,clear,152,"// The operand registers of the ""sunk"" instruction have their live range; // extended and their kill flags may no longer be correct. Conservatively; // clear the kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:66,Modifiability,extend,extended,66,// The registers of the addressing mode may have their live range extended; // and their kill flags may no longer be correct. Conservatively clear the; // kill flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:141,Usability,clear,clear,141,// The registers of the addressing mode may have their live range extended; // and their kill flags may no longer be correct. Conservatively clear the; // kill flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Usability,Clear,Clear,3,"// Clear the StoreInstrCache, since we may invalidate it by erasing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:161,Usability,clear,clear,161,// Collect operands that need to be cleaned up because the registers no longer; // exist (in COPYs and debug instructions). We cannot delete instructions or; // clear operands while traversing register uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:29,Usability,clear,clear,29,// Delete the dead COPYs and clear operands in debug instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:44,Performance,load,loads,44,/// Return true if this machine instruction loads from global offset table or; /// constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:7,Usability,clear,clear,7,// Now clear any kill flags for recorded registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Performance,Cache,Cache,3,"// Cache all successors, sorted by frequency info and cycle depth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:14,Modifiability,variab,variable,14,"// Record the variable for any DBG_VALUE, to avoid re-ordering any of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:45,Safety,avoid,avoid,45,"// Record the variable for any DBG_VALUE, to avoid re-ordering any of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Safety,Avoid,Avoid,3,// Avoid breaking back edge. From == To means backedge for single BB cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:122,Performance,Cache,CachedRegisterPressure,122,"// Currently to save compiling time, MBB's register pressure will not change; // in one ProcessBlock iteration because of CachedRegisterPressure. but MBB's; // register pressure is changed after sinking any instructions into it.; // FIXME: need a accurate and cheap register pressure estiminate model here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:63,Performance,cache,cache,63,// FIXME - If finding successor is compile time expensive then cache results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:46,Availability,alive,alive,46,"// If MI is in cycle and all its operands are alive across the whole cycle or; // if no operand sinking make register pressure set exceed limit, it is; // profitable to sink MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:119,Performance,cache,cached,119,"/// Get the sorted sequence of successors for this MachineBasicBlock, possibly; /// computing it if it was not already cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:39,Performance,cache,cache,39,// Do we have the sorted successors in cache ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:160,Energy Efficiency,allocate,allocated,160,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:36,Safety,safe,safe,36,// Virtual register uses are always safe to sink.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:15,Safety,safe,safe,15,"// If it's not safe to move defs of the register class, then abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:61,Safety,abort,abort,61,"// If it's not safe to move defs of the register class, then abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:106,Availability,reliab,reliable,106,"// Otherwise, we should look at all the successors and decide which one; // we should sink to. If we have reliable block frequency information; // (frequency != 0) available, give successors with smaller frequencies; // higher priority, otherwise prioritize smaller cycle depths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:164,Availability,avail,available,164,"// Otherwise, we should look at all the successors and decide which one; // we should sink to. If we have reliable block frequency information; // (frequency != 0) available, give successors with smaller frequencies; // higher priority, otherwise prioritize smaller cycle depths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:35,Safety,safe,safe,35,"// Def is used locally, it's never safe to move this def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:12,Safety,safe,safe,12,// It's not safe to sink instructions to EH landing pad. Control flow into; // landing pad is implicitly defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:99,Performance,optimiz,optimization,99,"/// Return true if MI is likely to be usable as a memory operation by the; /// implicit null check optimization.; ///; /// This is a ""best effort"" heuristic, and should not be relied upon for; /// correctness. This returning true does not guarantee that the implicit null; /// check optimization is legal over MI, and this returning false does not; /// guarantee MI cannot possibly be used to do a null check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:283,Performance,optimiz,optimization,283,"/// Return true if MI is likely to be usable as a memory operation by the; /// implicit null check optimization.; ///; /// This is a ""best effort"" heuristic, and should not be relied upon for; /// correctness. This returning true does not guarantee that the implicit null; /// check optimization is legal over MI, and this returning false does not; /// guarantee MI cannot possibly be used to do a null check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:38,Usability,usab,usable,38,"/// Return true if MI is likely to be usable as a memory operation by the; /// implicit null check optimization.; ///; /// This is a ""best effort"" heuristic, and should not be relied upon for; /// correctness. This returning true does not guarantee that the implicit null; /// check optimization is legal over MI, and this returning false does not; /// guarantee MI cannot possibly be used to do a null check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:114,Availability,recover,recover,114,"// Pre-regalloc, only forward if all subregisters agree (or there are no; // subregs at all). More analysis might recover some forwardable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:114,Safety,recover,recover,114,"// Pre-regalloc, only forward if all subregisters agree (or there are no; // subregs at all). More analysis might recover some forwardable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:135,Modifiability,variab,variable,135,"// Sink a copy of debug users to the insert position. Mark the original; // DBG_VALUE location as 'undef', indicating that any earlier variable; // location should be terminated as we've optimised away the value at this; // point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:68,Performance,cache,cached,68,// Does these two blocks pair be queried before and have a definite cached; // result?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:88,Performance,Cache,Cache,88,"// We still have chance to sink MI if all stores between are not; // aliased to MI.; // Cache all store instructions, so that we don't need to go through; // all From reachable blocks for next load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:193,Performance,load,load,193,"// We still have chance to sink MI if all stores between are not; // aliased to MI.; // Cache all store instructions, so that we don't need to go through; // all From reachable blocks for next load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:32,Performance,cache,cache,32,"// If there is no store at all, cache the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:18,Usability,clear,clear,18,// Conservatively clear any kill flags on uses of sunk instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:46,Safety,safe,safe,46,/// SinkInstruction - Determine whether it is safe to sink the specified machine; /// instruction out of its current block into a successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:49,Integrability,depend,dependent,49,// Convergent operations may not be made control-dependent on additional; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:47,Performance,perform,performance,47,"// Don't break implicit null checks. This is a performance heuristic, and not; // required for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:245,Availability,down,down,245,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:393,Availability,down,down,393,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:20,Performance,load,load,20,// We cannot sink a load across a critical edge - there may be stores in; // other code paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:64,Modifiability,variab,variable,64,// Sink any users that don't pass any other DBG_VALUEs for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:93,Availability,recover,recovered,93,"// This DBG_VALUE would re-order assignments. If we can't copy-propagate; // it, it can't be recovered. Set it undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:93,Safety,recover,recovered,93,"// This DBG_VALUE would re-order assignments. If we can't copy-propagate; // it, it can't be recovered. Set it undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:19,Usability,clear,clear,19,"// Conservatively, clear any kill flags, since it's possible that they are no; // longer correct.; // Note that we have to clear the kill flags for any register this instruction; // uses as we may sink over another instruction which currently kills the; // used registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:123,Usability,clear,clear,123,"// Conservatively, clear any kill flags, since it's possible that they are no; // longer correct.; // Note that we have to clear the kill flags for any register this instruction; // uses as we may sink over another instruction which currently kills the; // used registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:15,Usability,clear,clear,15,// Remember to clear kill flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:657,Integrability,wrap,wrapping,657,"//===----------------------------------------------------------------------===//; // This pass is not intended to be a replacement or a complete alternative; // for the pre-ra machine sink pass. It is only designed to sink COPY; // instructions which should be handled after RA.; //; // This pass sinks COPY instructions into a successor block, if the COPY is not; // used in the current block and the COPY is live-in to a single successor; // (i.e., doesn't require the COPY to be duplicated). This avoids executing the; // copy on paths where their results aren't needed. This also exposes; // additional opportunites for dead copy elimination and shrink wrapping.; //; // These copies were either not handled by or are inserted after the MachineSink; // pass. As an example of the former case, the MachineSink pass cannot sink; // COPY instructions with allocatable source registers; for AArch64 these type; // of copy instructions are frequently used to move function parameters (PhyReg); // into virtual registers in the entry block.; //; // For the machine IR below, this pass will sink %w19 in the entry into its; // successor (%bb.1) because %w19 is only live-in in %bb.1.; // %bb.0:; // %wzr = SUBSWri %w1, 1; // %w19 = COPY %w0; // Bcc 11, %bb.2; // %bb.1:; // Live Ins: %w19; // BL @fun; // %w0 = ADDWrr %w0, %w19; // RET %w0; // %bb.2:; // %w0 = COPY %wzr; // RET %w0; // As we sink %w19 (CSR in AArch64) into %bb.1, the shrink-wrapping pass will be; // able to see %bb.0 as a candidate.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:1440,Integrability,wrap,wrapping,1440,"//===----------------------------------------------------------------------===//; // This pass is not intended to be a replacement or a complete alternative; // for the pre-ra machine sink pass. It is only designed to sink COPY; // instructions which should be handled after RA.; //; // This pass sinks COPY instructions into a successor block, if the COPY is not; // used in the current block and the COPY is live-in to a single successor; // (i.e., doesn't require the COPY to be duplicated). This avoids executing the; // copy on paths where their results aren't needed. This also exposes; // additional opportunites for dead copy elimination and shrink wrapping.; //; // These copies were either not handled by or are inserted after the MachineSink; // pass. As an example of the former case, the MachineSink pass cannot sink; // COPY instructions with allocatable source registers; for AArch64 these type; // of copy instructions are frequently used to move function parameters (PhyReg); // into virtual registers in the entry block.; //; // For the machine IR below, this pass will sink %w19 in the entry into its; // successor (%bb.1) because %w19 is only live-in in %bb.1.; // %bb.0:; // %wzr = SUBSWri %w1, 1; // %w19 = COPY %w0; // Bcc 11, %bb.2; // %bb.1:; // Live Ins: %w19; // BL @fun; // %w0 = ADDWrr %w0, %w19; // RET %w0; // %bb.2:; // %w0 = COPY %wzr; // RET %w0; // As we sink %w19 (CSR in AArch64) into %bb.1, the shrink-wrapping pass will be; // able to see %bb.0 as a candidate.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:500,Safety,avoid,avoids,500,"//===----------------------------------------------------------------------===//; // This pass is not intended to be a replacement or a complete alternative; // for the pre-ra machine sink pass. It is only designed to sink COPY; // instructions which should be handled after RA.; //; // This pass sinks COPY instructions into a successor block, if the COPY is not; // used in the current block and the COPY is live-in to a single successor; // (i.e., doesn't require the COPY to be duplicated). This avoids executing the; // copy on paths where their results aren't needed. This also exposes; // additional opportunites for dead copy elimination and shrink wrapping.; //; // These copies were either not handled by or are inserted after the MachineSink; // pass. As an example of the former case, the MachineSink pass cannot sink; // COPY instructions with allocatable source registers; for AArch64 these type; // of copy instructions are frequently used to move function parameters (PhyReg); // into virtual registers in the entry block.; //; // For the machine IR below, this pass will sink %w19 in the entry into its; // successor (%bb.1) because %w19 is only live-in in %bb.1.; // %bb.0:; // %wzr = SUBSWri %w1, 1; // %w19 = COPY %w0; // Bcc 11, %bb.2; // %bb.1:; // Live Ins: %w19; // BL @fun; // %w0 = ADDWrr %w0, %w19; // RET %w0; // %bb.2:; // %w0 = COPY %wzr; // RET %w0; // As we sink %w19 (CSR in AArch64) into %bb.1, the shrink-wrapping pass will be; // able to see %bb.0 as a candidate.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:584,Security,expose,exposes,584,"//===----------------------------------------------------------------------===//; // This pass is not intended to be a replacement or a complete alternative; // for the pre-ra machine sink pass. It is only designed to sink COPY; // instructions which should be handled after RA.; //; // This pass sinks COPY instructions into a successor block, if the COPY is not; // used in the current block and the COPY is live-in to a single successor; // (i.e., doesn't require the COPY to be duplicated). This avoids executing the; // copy on paths where their results aren't needed. This also exposes; // additional opportunites for dead copy elimination and shrink wrapping.; //; // These copies were either not handled by or are inserted after the MachineSink; // pass. As an example of the former case, the MachineSink pass cannot sink; // COPY instructions with allocatable source registers; for AArch64 these type; // of copy instructions are frequently used to move function parameters (PhyReg); // into virtual registers in the entry block.; //; // For the machine IR below, this pass will sink %w19 in the entry into its; // successor (%bb.1) because %w19 is only live-in in %bb.1.; // %bb.0:; // %wzr = SUBSWri %w1, 1; // %w19 = COPY %w0; // Bcc 11, %bb.2; // %bb.1:; // Live Ins: %w19; // BL @fun; // %w0 = ADDWrr %w0, %w19; // RET %w0; // %bb.2:; // %w0 = COPY %wzr; // RET %w0; // As we sink %w19 (CSR in AArch64) into %bb.1, the shrink-wrapping pass will be; // able to see %bb.0 as a candidate.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:204,Safety,safe,safe,204,"// FIXME: instead of isUse(), readsReg() would be a better fix here,; // For example, we can ignore modifications in reg with undef. However,; // it's not perfectly clear if skipping the internal read is safe in all; // other targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:165,Usability,clear,clear,165,"// FIXME: instead of isUse(), readsReg() would be a better fix here,; // For example, we can ignore modifications in reg with undef. However,; // it's not perfectly clear if skipping the internal read is safe in all; // other targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:58,Safety,avoid,avoid,58,"// We must sink this DBG_VALUE if its operand is sunk. To avoid searching; // for DBG_VALUEs later, record them when they're encountered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:54,Integrability,depend,dependency,54,// Don't sink the COPY if it would violate a register dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Usability,Clear,Clear,3,// Clear the kill flag if SrcReg is killed between MI and the end of the; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp:39,Performance,optimiz,optimization,39,"//===- MachineSizeOpts.cpp - code size optimization related code ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared machine IR code size optimization related; // code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp:435,Performance,optimiz,optimization,435,"//===- MachineSizeOpts.cpp - code size optimization related code ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared machine IR code size optimization related; // code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:48,Deployability,Update,Update,48,"//===- MachineSSAUpdater.cpp - Unstructured SSA Update Tool ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MachineSSAUpdater class. It's based on SSAUpdater; // class in lib/Transforms/Utils.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:74,Deployability,update,updates,74,/// Initialize - Reset this object to get ready for a new set of SSA; /// updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:59,Availability,avail,available,59,/// AddAvailableValue - Indicate that a rewritten value is available in the; /// specified block with the specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:652,Availability,Avail,AvailableVals,652,"/// GetValueInMiddleOfBlock - Construct SSA form, materializing a value that; /// is live in the middle of the specified block. If ExistingValueOnly is; /// true then this will only return an existing value or $noreg; otherwise new; /// instructions may be inserted to materialize a value.; ///; /// GetValueInMiddleOfBlock is the same as GetValueAtEndOfBlock except in one; /// important case: if there is a definition of the rewritten value after the; /// 'use' in BB. Consider code like this:; ///; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:696,Modifiability,rewrite,rewriter,696,"/// GetValueInMiddleOfBlock - Construct SSA form, materializing a value that; /// is live in the middle of the specified block. If ExistingValueOnly is; /// true then this will only return an existing value or $noreg; otherwise new; /// instructions may be inserted to materialize a value.; ///; /// GetValueInMiddleOfBlock is the same as GetValueAtEndOfBlock except in one; /// important case: if there is a definition of the rewritten value after the; /// 'use' in BB. Consider code like this:; ///; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:44,Modifiability,variab,variable,44,"// If there is no definition of the renamed variable in this block, just use; // GetValueAtEndOfBlock to do our work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:4,Modifiability,Rewrite,RewriteUse,4,"/// RewriteUse - Rewrite a use of the symbolic value. This handles PHI nodes,; /// which use their value in the corresponding predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:17,Modifiability,Rewrite,Rewrite,17,"/// RewriteUse - Rewrite a use of the symbolic value. This handles PHI nodes,; /// which use their value in the corresponding predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:74,Availability,Avail,AvailableVals,74,"// end namespace llvm; /// GetValueAtEndOfBlockInternal - Check to see if AvailableVals has an entry; /// for the specified BB and if so, return it. If not, construct SSA form by; /// first calculating the required placement of PHIs and then inserting new; /// PHIs where needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:390,Security,hash,hashing,390,"//===- lib/CodeGen/MachineStableHash.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stable hashing for MachineInstr and MachineOperand. Useful or getting a; // hash across runs, modules, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:459,Security,hash,hash,459,"//===- lib/CodeGen/MachineStableHash.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stable hashing for MachineInstr and MachineOperand. Useful or getting a; // hash across runs, modules, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:13,Security,hash,hash,13,"/// A stable hash value for machine instructions.; /// Returns 0 if no stable hash could be computed.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:78,Security,hash,hash,78,"/// A stable hash value for machine instructions.; /// Returns 0 if no stable hash could be computed.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:111,Security,hash,hashing,111,"/// A stable hash value for machine instructions.; /// Returns 0 if no stable hash could be computed.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:132,Testability,test,testing,132,"/// A stable hash value for machine instructions.; /// Returns 0 if no stable hash could be computed.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:24,Security,hash,hash,24,// Build up a buffer of hash code components.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:9,Security,Hash,Hash,9,// TODO: Hash more stuff like block alignment and branch probabilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:9,Security,Hash,Hash,9,// TODO: Hash lots more stuff like function alignment and stack objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp:462,Testability,test,tests,462,"//===- MachineStripDebug.cpp - Strip debug info ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This removes debug info from everything. It can be used to ensure; /// tests can be debugified without affecting the output MIR.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp:167,Integrability,depend,depends,167,"// FIXME: We should remove all of them. However, AArch64 emits an; // invalid `DBG_VALUE $lr` with only one operand instead of; // the usual three and has a test that depends on it's; // preservation. Preserve it for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp:157,Testability,test,test,157,"// FIXME: We should remove all of them. However, AArch64 emits an; // invalid `DBG_VALUE $lr` with only one operand instead of; // the usual three and has a test that depends on it's; // preservation. Preserve it for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:302,Integrability,depend,depend,302,//===----------------------------------------------------------------------===//; // Fixed block information; //===----------------------------------------------------------------------===//; //; // The number of instructions in a basic block and the CPU resources used by; // those instructions don't depend on any given trace strategy.; /// Compute the resource usage in basic block MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update resource-related information in the TraceBlockInfo for MBB.; // Only update resources related to the trace above MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:79,Deployability,update,update,79,// Update resource-related information in the TraceBlockInfo for MBB.; // Only update resources related to the trace above MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:56,Usability,simpl,simple,56,// Compute resources from trace above. The top block is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update resource-related information in the TraceBlockInfo for MBB.; // Only update resources related to the trace below MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:79,Deployability,update,update,79,// Update resource-related information in the TraceBlockInfo for MBB.; // Only update resources related to the trace below MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:391,Availability,down,downwards,391,"//===----------------------------------------------------------------------===//; // Trace Selection Strategies; //===----------------------------------------------------------------------===//; //; // A trace selection strategy is implemented as a sub-class of Ensemble. The; // trace through a block B is computed by two DFS traversals of the CFG; // starting from B. One upwards, and one downwards. During the upwards DFS,; // pickTracePred() is called on the post-ordered blocks. During the downwards; // DFS, pickTraceSucc() is called in a post-order.; //; // We never allow traces that leave loops, but we do allow traces to enter; // nested loops. We also never allow traces to contain back-edges.; //; // This means that a loop header can never appear above the center block of a; // trace, except as the trace head. Below the center block, loop exiting edges; // are banned.; //; // Return true if an edge from the From loop to the To loop is leaving a loop.; // Either of To and From can be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:495,Availability,down,downwards,495,"//===----------------------------------------------------------------------===//; // Trace Selection Strategies; //===----------------------------------------------------------------------===//; //; // A trace selection strategy is implemented as a sub-class of Ensemble. The; // trace through a block B is computed by two DFS traversals of the CFG; // starting from B. One upwards, and one downwards. During the upwards DFS,; // pickTracePred() is called on the post-ordered blocks. During the downwards; // DFS, pickTraceSucc() is called in a post-order.; //; // We never allow traces that leave loops, but we do allow traces to enter; // nested loops. We also never allow traces to contain back-edges.; //; // This means that a loop header can never appear above the center block of a; // trace, except as the trace head. Below the center block, loop exiting edges; // are banned.; //; // Return true if an edge from the From loop to the To loop is leaving a loop.; // Either of To and From can be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new Ensemble on demand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:233,Safety,avoid,avoid,233,"//===----------------------------------------------------------------------===//; // Trace building; //===----------------------------------------------------------------------===//; //; // Traces are built by two CFG traversals. To avoid recomputing too much, use a; // set abstraction that confines the search to the current loop, and doesn't; // revisit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:9,Availability,down,downwards,9,// Run a downwards post-order search for the trace end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Usability,Clear,Clear,3,"// Clear any per-instruction data. We only have to do this for BadMBB itself; // because the instructions in that block may change. Other blocks may be; // invalidated, but their instructions will stay the same, so there is no; // need to erase the Cycle entries. They will be overwritten when we; // recompute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:90,Integrability,Depend,Dependencies,90,//===----------------------------------------------------------------------===//; // Data Dependencies; //===----------------------------------------------------------------------===//; //; // Compute the depth and height of each instruction based on data dependencies; // and instruction latencies. These cycle numbers assume that the CPU can issue; // an infinite number of instructions per cycle as long as their dependencies; // are ready.; // A data dependency is represented as a defining MI and operand numbers on the; // defining and using MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:256,Integrability,depend,dependencies,256,//===----------------------------------------------------------------------===//; // Data Dependencies; //===----------------------------------------------------------------------===//; //; // Compute the depth and height of each instruction based on data dependencies; // and instruction latencies. These cycle numbers assume that the CPU can issue; // an infinite number of instructions per cycle as long as their dependencies; // are ready.; // A data dependency is represented as a defining MI and operand numbers on the; // defining and using MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:416,Integrability,depend,dependencies,416,//===----------------------------------------------------------------------===//; // Data Dependencies; //===----------------------------------------------------------------------===//; //; // Compute the depth and height of each instruction based on data dependencies; // and instruction latencies. These cycle numbers assume that the CPU can issue; // an infinite number of instructions per cycle as long as their dependencies; // are ready.; // A data dependency is represented as a defining MI and operand numbers on the; // defining and using MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:455,Integrability,depend,dependency,455,//===----------------------------------------------------------------------===//; // Data Dependencies; //===----------------------------------------------------------------------===//; //; // Compute the depth and height of each instruction based on data dependencies; // and instruction latencies. These cycle numbers assume that the CPU can issue; // an infinite number of instructions per cycle as long as their dependencies; // are ready.; // A data dependency is represented as a defining MI and operand numbers on the; // defining and using MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:50,Integrability,depend,dependencies,50,// end anonymous namespace; // Get the input data dependencies that must be ready before UseMI can issue.; // Return true if UseMI has any physreg operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:22,Integrability,depend,dependencies,22,"// Get the input data dependencies of a PHI instruction, using Pred as the; // preferred predecessor.; // This will add at most one dependency to Deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:132,Integrability,depend,dependency,132,"// Get the input data dependencies of a PHI instruction, using Pred as the; // preferred predecessor.; // This will add at most one dependency to Deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:54,Integrability,depend,dependencies,54,// No predecessor at the beginning of a trace. Ignore dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:116,Availability,down,downwards,116,"// Identify physreg dependencies for UseMI, and update the live regunit; // tracking set when scanning instructions downwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:48,Deployability,update,update,48,"// Identify physreg dependencies for UseMI, and update the live regunit; // tracking set when scanning instructions downwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:20,Integrability,depend,dependencies,20,"// Identify physreg dependencies for UseMI, and update the live regunit; // tracking set when scanning instructions downwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:12,Integrability,depend,dependencies,12,// Identify dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update RegUnits to reflect live registers after UseMI.; // First kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:217,Integrability,depend,dependency,217,"/// The length of the critical path through a trace is the maximum of two path; /// lengths:; ///; /// 1. The maximum height+depth over all instructions in the trace center block.; ///; /// 2. The longest cross-block dependency chain. For small blocks, it is; /// possible that the critical path through the trace doesn't include any; /// instructions in the block.; ///; /// This function computes the second number from the live-in list of the; /// center block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:10,Integrability,depend,dependencies,10,// Ignore dependencies outside the current trace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:20,Integrability,depend,dependencies,20,// Collect all data dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:22,Integrability,depend,dependencies,22,"// Filter and process dependencies, computing the earliest issue cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:10,Integrability,depend,dependencies,10,// Ignore dependencies from outside the current trace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:7,Performance,latency,latency,7,// Add latency if DefMI is a real instruction. Transients get latency 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:62,Performance,latency,latency,62,// Add latency if DefMI is a real instruction. Transients get latency 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update critical path length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,Availability,down,down,34,"// Go through trace blocks in top-down order, stopping after the center block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:20,Integrability,depend,dependencies,20,// Identify physreg dependencies for MI when scanning instructions upwards.; // Return the issue height of MI after considering any live regunits.; // Height is the issue height computed from virtual register dependencies alone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:209,Integrability,depend,dependencies,209,// Identify physreg dependencies for MI when scanning instructions upwards.; // Return the issue height of MI after considering any live regunits.; // Height is the issue height computed from virtual register dependencies alone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:77,Deployability,update,update,77,"// This is a def of Reg. Remove corresponding entries from RegUnits, and; // update MI Height to consider the physreg dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:118,Integrability,depend,dependencies,118,"// This is a def of Reg. Remove corresponding entries from RegUnits, and; // update MI Height to consider the physreg dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:37,Integrability,depend,dependency,37,"// We may not know the UseMI of this dependency, if it came from the; // live-in list. SchedModel can handle a NULL UseMI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:33,Deployability,Update,Update,33,// Now we know the height of MI. Update any regunits read.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:30,Performance,latency,latency,30,// Adjust height by Dep.DefMI latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update Heights[DefMI] to be the maximum height seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:45,Deployability,update,updated,45,// Just add the register. The height will be updated later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:63,Deployability,update,updates,63,/// Compute instruction heights in the trace through MBB. This updates MBB and; /// the blocks below it in the trace. It is assumed that the trace has already; /// been computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,Performance,latency,latency,34,"// For virtual registers, the def latency is included.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:31,Performance,latency,latency,31,"// For register units, the def latency is not included because we don't; // know the def yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:7,Integrability,depend,dependencies,7,// Get dependencies from PHIs in the trace successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:106,Integrability,depend,dependencies,106,"// If MBB is the last block in the trace, and it has a back-edge to the; // loop header, get loop-carried dependencies from PHIs in the header. For; // that purpose, pretend that all the loop header PHIs have height 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:32,Integrability,depend,depend,32,"// Don't process PHI deps. They depend on the specific predecessor, and; // we'll get them when visiting the predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:29,Integrability,depend,dependencies,29,// There may also be regunit dependencies to include in the height.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update the required height of any virtual registers read by MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update critical path length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update virtual live-in heights. They were added by addLiveIns() with a 0; // height because the final height isn't known until now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:7,Performance,latency,latency,7,// Add latency if DefMI is a real instruction. Transients get latency 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:62,Performance,latency,latency,62,// Add latency if DefMI is a real instruction. Transients get latency 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,Energy Efficiency,schedul,schedule,34,// Assume issue width 1 without a schedule model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,Energy Efficiency,schedul,schedule,34,// Assume issue width 1 without a schedule model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:3,Safety,Avoid,Avoid,3,// Avoid querying the MachineFunctionProperties for each operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:27,Availability,avail,available,27,// Analysis information if available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:148,Availability,error,error,148,// If a pass has introduced virtual registers without clearing the; // NoVRegs property (or set it without allocating the vregs); // then report an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:54,Usability,clear,clearing,54,// If a pass has introduced virtual registers without clearing the; // NoVRegs property (or set it without allocating the vregs); // then report an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:168,Usability,clear,clear,168,// If we're mid-GlobalISel and we already triggered the fallback path then; // it's expected that the MIR is somewhat broken but that's ok since we'll; // reset it and clear the FailedISel attribute in ResetMachineFunctions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:61,Availability,avail,available,61,// We don't want to verify LiveVariables if LiveIntervals is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:275,Integrability,message,message,275,"// Generally we try to report as many issues as possible at once, but in; // this case it's not clear what should we be comparing the size of the; // scalar with: the size of the whole vector or its lane. Instead of; // making an arbitrary choice and emitting not so helpful message, let's; // avoid the extra noise and stop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:294,Safety,avoid,avoid,294,"// Generally we try to report as many issues as possible at once, but in; // this case it's not clear what should we be comparing the size of the; // scalar with: the size of the whole vector or its lane. Instead of; // making an arbitrary choice and emitting not so helpful message, let's; // avoid the extra noise and stop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:96,Usability,clear,clear,96,"// Generally we try to report as many issues as possible at once, but in; // this case it's not clear what should we be comparing the size of the; // scalar with: the size of the whole vector or its lane. Instead of; // making an arbitrary choice and emitting not so helpful message, let's; // avoid the extra noise and stop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:92,Energy Efficiency,reduce,reduce,92,"// Don't report a type mismatch if there is no actual mismatch, only a; // type missing, to reduce noise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:107,Usability,clear,clear,107,// Only the first valid type for a type index will be printed: don't; // overwrite it later so it's always clear which type was expected:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:3,Safety,Avoid,Avoid,3,// Avoid out of bounds in checks below. This was already reported earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:11,Performance,load,loads,11,// Generic loads and stores must have a single MachineMemOperand; // describing that access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:85,Security,access,access,85,// Generic loads and stores must have a single MachineMemOperand; // describing that access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:75,Integrability,interface,interface,75,"// TODO: Should verify number of def and use operands, but the current; // interface requires passing in IR types for mangling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:121,Testability,test,tests,121,"// A fully-formed DBG_VALUE must have a location. Ignore partially formed; // DBG_VALUEs: these are convenient to use in tests, but should never get; // generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:110,Performance,scalab,scalable,110,"// The next two checks allow COPY between physical and virtual registers,; // when the virtual register has a scalable size and the physical register; // has a fixed size. These checks allow COPY between *potentialy* mismatched; // sizes. However, once RegisterBankSelection occurs, MachineVerifier should; // be able to resolve a fixed size for the scalable vector, and at that; // point this function will know for sure whether the sizes are mismatched; // and correctly report a size mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:350,Performance,scalab,scalable,350,"// The next two checks allow COPY between physical and virtual registers,; // when the virtual register has a scalable size and the physical register; // has a fixed size. These checks allow COPY between *potentialy* mismatched; // sizes. However, once RegisterBankSelection occurs, MachineVerifier should; // be able to resolve a fixed size for the scalable vector, and at that; // point this function will know for sure whether the sizes are mismatched; // and correctly report a size mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:270,Safety,Detect,DetectDeadLanes,270,"// This is a generic virtual register.; // Do not allow undef uses for generic virtual registers. This ensures; // getVRegDef can never fail and return null on a generic register.; //; // FIXME: This restriction should probably be broadened to all SSA; // MIR. However, DetectDeadLanes/ProcessImplicitDefs technically still; // run on the SSA function just before phi elimination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:231,Energy Efficiency,allocate,allocated,231,"// Debug value instruction is permitted to use undefined vregs.; // This is a performance measure to skip the overhead of immediately; // pruning unused debug operands. The final undef substitution occurs; // when debug values are allocated in LDVImpl::handleDebugValue, so; // these verifications always apply after this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:78,Performance,perform,performance,78,"// Debug value instruction is permitted to use undefined vregs.; // This is a performance measure to skip the overhead of immediately; // pruning unused debug operands. The final undef substitution occurs; // when debug values are allocated in LDVImpl::handleDebugValue, so; // these verifications always apply after this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:95,Performance,load,loading,95,"// For a memory-to-memory move, we need to check if the frame; // index is used for storing or loading, by inspecting the; // memory operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:483,Performance,perform,performed,483,"// The LR can correspond to the whole reg and its def slot is not obliged; // to be the same as the MO' def slot. E.g. when we check here ""normal""; // subreg MO but there is other EC subreg MO in the same instruction so the; // whole reg has EC def slot and differs from the currently checked MO' def; // slot. For example:; // %0 [16e,32r:0) 0@16e L..3 [16e,32r:0) 0@16e L..C [16r,32r:0) 0@16r; // Check that there is an early-clobber def of the same superregister; // somewhere is performed in visitMachineFunctionAfter()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:13,Performance,cache,cached,13,// Check the cached regunit intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:12,Availability,mask,masked,12,// Kill any masked registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:344,Energy Efficiency,efficient,efficient,344,"// This implements a set of registers that serves as a filter: can filter other; // sets by passing through elements not in the filter and blocking those that; // are. Any filter implicitly includes the full set of physical registers upon; // creation, thus filtering them all out. The filter itself as a set only grows,; // and needs to be as efficient as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:175,Availability,down,down,175,"// Reserving space in sets once performs better than doing so continuously; // and pays easily for double look-ups (even in Dense with SparseUniverseMax; // tuned all the way down) and double iteration (the second one is over a; // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:62,Deployability,continuous,continuously,62,"// Reserving space in sets once performs better than doing so continuously; // and pays easily for double look-ups (even in Dense with SparseUniverseMax; // tuned all the way down) and double iteration (the second one is over a; // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:32,Performance,perform,performs,32,"// Reserving space in sets once performs better than doing so continuously; // and pays easily for double look-ups (even in Dense with SparseUniverseMax; // tuned all the way down) and double iteration (the second one is over a; // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:157,Performance,tune,tuned,157,"// Reserving space in sets once performs better than doing so continuously; // and pays easily for double look-ups (even in Dense with SparseUniverseMax; // tuned all the way down) and double iteration (the second one is over a; // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:474,Energy Efficiency,efficient,efficient,474,"// VRegs indexed within SparseUniverseMax are tracked by Sparse, those beyound; // are tracked by Dense. The only purpose of the threashold and the Dense set; // is to have a reasonably growing memory usage in pathological cases (large; // number of very sparse VRegFilter instances live at the same time). In; // practice even in the worst-by-execution time cases having all elements; // tracked by Sparse (very large SparseUniverseMax scenario) tends to be more; // space efficient than if tracked by Dense. The threashold is set to keep the; // worst-case memory usage within 2x of figures determined empirically for; // ""all Dense"" scenario in such worst-by-execution-time cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:30,Availability,avail,available,30,// Now check liveness info if available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:59,Availability,Alive,AliveBlocks,59,// Our vregsRequired should be identical to LiveVariables' AliveBlocks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:18,Performance,cache,cached,18,// Verify all the cached regunit intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:60,Availability,mask,mask,60,// An operand %0:sub0 reads %0:sub1..n. Invert the lane; // mask for subregister defs. Read-undef defs will be handled by; // readsReg below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:109,Performance,perform,perform,109,"// Make sure that the corresponding machine operand for a ""dead"" live; // range has the dead flag. We cannot perform this check for subregister; // liveranges as partially dead values are allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:3,Deployability,Update,Update,3,// Update stack state by checking contents of MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:439,Energy Efficiency,schedul,scheduling,439,"//===- MacroFusion.cpp - Macro Fusion -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the implementation of the DAG scheduling mutation; /// to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:91,Energy Efficiency,Schedul,ScheduleDAGInstrs,91,"// Though the reachability checks above could be made more generic,; // perhaps as part of ScheduleDAGInstrs::addEdge(), since such edges are valid,; // the extra computation cost makes it less interesting in general cases.; // Create a single weak edge between the adjacent instrs. The only effect is; // to cause bottom-up scheduling to heavily prioritize the clustered instrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:325,Energy Efficiency,schedul,scheduling,325,"// Though the reachability checks above could be made more generic,; // perhaps as part of ScheduleDAGInstrs::addEdge(), since such edges are valid,; // the extra computation cost makes it less interesting in general cases.; // Create a single weak edge between the adjacent instrs. The only effect is; // to cause bottom-up scheduling to heavily prioritize the clustered instrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:302,Energy Efficiency,schedul,scheduled,302,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:104,Integrability,depend,dependencies,104,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:139,Integrability,depend,dependent,139,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:224,Integrability,depend,dependent,224,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:241,Integrability,depend,dependencies,241,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:14,Performance,latency,latency,14,// Adjust the latency between both instrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:105,Energy Efficiency,schedul,scheduled,105,// Make data dependencies from the FirstSU also dependent on the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:13,Integrability,depend,dependencies,13,// Make data dependencies from the FirstSU also dependent on the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:48,Integrability,depend,dependent,48,// Make data dependencies from the FirstSU also dependent on the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:102,Energy Efficiency,schedul,scheduled,102,// Make the FirstSU also dependent on the dependencies of the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:25,Integrability,depend,dependent,25,// Make the FirstSU also dependent on the dependencies of the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:42,Integrability,depend,dependencies,42,// Make the FirstSU also dependent on the dependencies of the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:60,Integrability,depend,dependency,60,"// ExitSU comes last by design, which acts like an implicit dependency; // between ExitSU and any bottom root in the graph. We should transfer; // this to FirstSU as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:33,Energy Efficiency,schedul,scheduling,33,"// For each of the SUnits in the scheduling block, try to fuse the instr in; // it with one in its predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:47,Energy Efficiency,schedul,scheduling,47,"/// Implement the fusion of instr pairs in the scheduling DAG,; /// anchored at the instr in AnchorSU..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:44,Integrability,depend,dependencies,44,// Explorer for fusion candidates among the dependencies of the anchor instr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:10,Integrability,depend,dependencies,10,// Ignore dependencies other than data or strong ordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MBFIWrapper.cpp:51,Integrability,wrap,wrapper,51,"//===- MBFIWrapper.cpp - MachineBlockFrequencyInfo wrapper ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class keeps track of branch frequencies of newly created blocks and; // tail-merged blocks. Used by the TailDuplication and MachineBlockPlacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MBFIWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MBFIWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp:669,Energy Efficiency,schedul,scheduling,669,"//===-------------- MIRCanonicalizer.cpp - MIR Canonicalizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The purpose of this pass is to employ a canonical code transformation so; // that code compiled with slightly different IR passes can be diffed more; // effectively than otherwise. This is done by renaming vregs in a given; // LiveRange in a canonical way. This pass also does a pseudo-scheduling to; // move defs closer to their use inorder to reduce diffs caused by slightly; // different schedules.; //; // Basic Usage:; //; // llc -o - -run-pass mir-canonicalizer example.mir; //; // Reorders instructions canonically.; // Renames virtual register operands canonically.; // Strips certain MIR artifacts (optionally).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp:728,Energy Efficiency,reduce,reduce,728,"//===-------------- MIRCanonicalizer.cpp - MIR Canonicalizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The purpose of this pass is to employ a canonical code transformation so; // that code compiled with slightly different IR passes can be diffed more; // effectively than otherwise. This is done by renaming vregs in a given; // LiveRange in a canonical way. This pass also does a pseudo-scheduling to; // move defs closer to their use inorder to reduce diffs caused by slightly; // different schedules.; //; // Basic Usage:; //; // llc -o - -run-pass mir-canonicalizer example.mir; //; // Reorders instructions canonically.; // Renames virtual register operands canonically.; // Strips certain MIR artifacts (optionally).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp:774,Energy Efficiency,schedul,schedules,774,"//===-------------- MIRCanonicalizer.cpp - MIR Canonicalizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The purpose of this pass is to employ a canonical code transformation so; // that code compiled with slightly different IR passes can be diffed more; // effectively than otherwise. This is done by renaming vregs in a given; // LiveRange in a canonical way. This pass also does a pseudo-scheduling to; // move defs closer to their use inorder to reduce diffs caused by slightly; // different schedules.; //; // Basic Usage:; //; // llc -o - -run-pass mir-canonicalizer example.mir; //; // Reorders instructions canonically.; // Renames virtual register operands canonically.; // Strips certain MIR artifacts (optionally).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp:238,Deployability,patch,patch,238,// Not folding COPY instructions if regbankselect has not set the RCs.; // Why are we only considering Register Classes? Because the verifier; // sometimes gets upset if the register classes don't match even if the; // types do. A future patch might add COPY folding for matching types in; // pre-registerbankselect code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:83,Security,hash,hash,83,"// TODO(xur): Remove this once we switch to ImprovedFSDiscriminator.; // Compute a hash value using debug line number, and the line numbers from the; // inline stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:3,Availability,Mask,Mask,3,// Mask of discriminators before this pass.; // TODO(xur): simplify this once we switch to ImprovedFSDiscriminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:59,Usability,simpl,simplify,59,// Mask of discriminators before this pass.; // TODO(xur): simplify this once we switch to ImprovedFSDiscriminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:3,Availability,Mask,Mask,3,// Mask of discriminators including this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:3,Availability,Mask,Mask,3,// Mask of discriminators for bits specific to this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRNamerPass.cpp:510,Testability,test,tests,510,"//===----------------------- MIRNamer.cpp - MIR Namer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The purpose of this pass is to rename virtual register operands with the goal; // of making it easier to author easier to read tests for MIR. This pass reuses; // the vreg renamer used by MIRCanonicalizerPass.; //; // Basic Usage:; //; // llc -o - -run-pass mir-namer example.mir; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRNamerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRNamerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp:4,Integrability,Synchroniz,Synchronization,4,/// Synchronization scope names registered with LLVMContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp:33,Testability,assert,asserted,33,// Check whether the register is asserted in regmask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp:19,Modifiability,variab,variable,19,// Print the debug variable information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp:31,Performance,load,load,31,// Machine memory operands can load/store to/from constant value pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:445,Performance,load,loader,445,"//===-------- MIRSampleProfile.cpp: MIRSampleFDO (For FSAFDO) -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the implementation of the MIRSampleProfile loader, mainly; // for flow sensitive SampleFDO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:3,Performance,Load,Load,3,// Load pseudo probe descriptors for probe-based function samples.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:355,Availability,mainten,maintenance,355,"// Do not load non-FS profiles. A line or probe can get a zero-valued; // discriminator at certain pass which could result in accidentally loading; // the corresponding base counter in the non-FS profile, while a non-zero; // discriminator would end up getting zero samples. This could in turn undo; // the sample distribution effort done by previous BFI maintenance and the; // probe distribution factor work for pseudo probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:10,Performance,load,load,10,"// Do not load non-FS profiles. A line or probe can get a zero-valued; // discriminator at certain pass which could result in accidentally loading; // the corresponding base counter in the non-FS profile, while a non-zero; // discriminator would end up getting zero samples. This could in turn undo; // the sample distribution effort done by previous BFI maintenance and the; // probe distribution factor work for pseudo probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:139,Performance,load,loading,139,"// Do not load non-FS profiles. A line or probe can get a zero-valued; // discriminator at certain pass which could result in accidentally loading; // the corresponding base counter in the non-FS profile, while a non-zero; // discriminator would end up getting zero samples. This could in turn undo; // the sample distribution effort done by previous BFI maintenance and the; // probe distribution factor work for pseudo probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:294,Usability,undo,undo,294,"// Do not load non-FS profiles. A line or probe can get a zero-valued; // discriminator at certain pass which could result in accidentally loading; // the corresponding base counter in the non-FS profile, while a non-zero; // discriminator would end up getting zero samples. This could in turn undo; // the sample distribution effort done by previous BFI maintenance and the; // probe distribution factor work for pseudo probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:3,Security,Hash,HashVRegs,3,/* HashVRegs */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:3,Security,Hash,HashConstantPoolIndices,3,/* HashConstantPoolIndices */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:3,Security,Hash,HashMemOperands,3,/* HashMemOperands */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:10,Security,hash,hashable,10,// Gets a hashable artifact from a given MachineOperand (ie an unsigned).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:226,Security,hash,hash,226,"// We could explicitly handle all the types of the MachineOperand,; // here but we can just return a common number until we find a; // compelling test case where this is bad. The only side effect here; // is contributing to a hash collision but there's enough information; // (Opcodes,other registers etc) that this will likely not be a problem.; // TODO: Handle the following Index/ID/Predicate cases. They can; // be hashed on in a stable manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:419,Security,hash,hashed,419,"// We could explicitly handle all the types of the MachineOperand,; // here but we can just return a common number until we find a; // compelling test case where this is bad. The only side effect here; // is contributing to a hash collision but there's enough information; // (Opcodes,other registers etc) that this will likely not be a problem.; // TODO: Handle the following Index/ID/Predicate cases. They can; // be hashed on in a stable manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:146,Testability,test,test,146,"// We could explicitly handle all the types of the MachineOperand,; // here but we can just return a common number until we find a; // compelling test case where this is bad. The only side effect here; // is contributing to a hash collision but there's enough information; // (Opcodes,other registers etc) that this will likely not be a problem.; // TODO: Handle the following Index/ID/Predicate cases. They can; // be hashed on in a stable manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:100,Security,hash,hash,100,"// In the cases below we havn't found a way to produce an artifact that will; // result in a stable hash, in most cases because they are pointers. We want; // stable hashes because we want the hash to be the same run to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:166,Security,hash,hashes,166,"// In the cases below we havn't found a way to produce an artifact that will; // result in a stable hash, in most cases because they are pointers. We want; // stable hashes because we want the hash to be the same run to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:193,Security,hash,hash,193,"// In the cases below we havn't found a way to produce an artifact that will; // result in a stable hash, in most cases because they are pointers. We want; // stable hashes because we want the hash to be the same run to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:3,Safety,Avoid,Avoid,3,"// Avoid non regs, instructions defining physical regs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h:38,Security,hash,hash,38,"/// Given an Instruction, construct a hash of the operands; /// of the instructions along with the opcode.; /// When dealing with virtual registers, just hash the opcode of; /// the instruction defining that vreg.; /// Handle immediates, registers (physical and virtual) explicitly,; /// and return a common value for the other cases.; /// Instruction will be named in the following scheme; /// bb<block_no>_hash_<collission_count>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h:154,Security,hash,hash,154,"/// Given an Instruction, construct a hash of the operands; /// of the instructions along with the opcode.; /// When dealing with virtual registers, just hash the opcode of; /// the instruction defining that vreg.; /// Handle immediates, registers (physical and virtual) explicitly,; /// and return a common value for the other cases.; /// Instruction will be named in the following scheme; /// bb<block_no>_hash_<collission_count>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h:4,Performance,Perform,Perform,4,"/// Perform replacing of registers based on the <old,new> vreg map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h:40,Integrability,depend,depending,40,"/// Same as the above, but sets a BBNum depending on BB traversal that; /// will be used as prefix for the vreg names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:436,Integrability,inject,injection,436,"//===- MLRegAllocEvictAdvisor.cpp - ML eviction advisor -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of the ML eviction advisor and reward injection pass; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:436,Security,inject,injection,436,"//===- MLRegAllocEvictAdvisor.cpp - ML eviction advisor -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of the ML eviction advisor and reward injection pass; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:23,Deployability,release,release,23,// Generated header in release (AOT) mode,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:42,Integrability,inject,injection,42,"// #ifdef LLVM_HAVE_TFLITE; /// The score injection pass.; /// This pass calculates the score for a function and inserts it in the log, but; /// this happens only in development mode. It's a no-op otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:42,Security,inject,injection,42,"// #ifdef LLVM_HAVE_TFLITE; /// The score injection pass.; /// This pass calculates the score for a function and inserts it in the log, but; /// this happens only in development mode. It's a no-op otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:131,Testability,log,log,131,"// #ifdef LLVM_HAVE_TFLITE; /// The score injection pass.; /// This pass calculates the score for a function and inserts it in the log, but; /// this happens only in development mode. It's a no-op otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:4,Performance,Perform,Performs,4,/// Performs this pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:68,Availability,error,error,68,// The model can only accept a specified number of opcodes and will error it if; // fed an opcode it hasn't seen before. This constant sets the current cutoff.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:39,Availability,mask,mask,39,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:188,Availability,mask,mask,188,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:111,Integrability,contract,contract,111,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:234,Safety,avoid,avoid,234,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:13,Usability,learn,learns,13,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:110,Availability,avail,available,110,"// The ML advisor will typically have a sparse input to the evaluator, because; // various phys regs won't be available. It's easier (maintenance-wise) to; // bulk-reset the state of the evaluator each time we are about to use it; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:134,Availability,mainten,maintenance-wise,134,"// The ML advisor will typically have a sparse input to the evaluator, because; // various phys regs won't be available. It's easier (maintenance-wise) to; // bulk-reset the state of the evaluator each time we are about to use it; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:42,Deployability,release,release,42,/// The ML evictor (commonalities between release and development mode),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:81,Availability,error,error,81,"// The assumption is that if the Runner could not be constructed, we emit-ed; // error, and we shouldn't be asking for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:111,Testability,log,log,111,"/// This just calls Evaluate on the Runner, but in the development mode; /// case, if we're just capturing the log of the default advisor, it needs; /// to call the latter instead, so we need to pass all the necessary; /// parameters for it. In the development case, it will also log.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:280,Testability,log,log,280,"/// This just calls Evaluate on the Runner, but in the development mode; /// case, if we're just capturing the log of the default advisor, it needs; /// to call the latter instead, so we need to pass all the necessary; /// parameters for it. In the development case, it will also log.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:44,Energy Efficiency,allocate,allocated,44,"/// Load the features of the given VirtReg (allocated or not) at column Pos,; /// but if that can't be evicted, return false instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:4,Performance,Load,Load,4,"/// Load the features of the given VirtReg (allocated or not) at column Pos,; /// but if that can't be evicted, return false instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:28,Usability,learn,learn,28,"// Point-in-time: we didn't learn this, so we always delegate to the; // default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:159,Testability,log,logging,159,"// Hold on to a default advisor for:; // 1) the implementation of canEvictHintInterference, because we didn't; // learn that nuance yet; 2) for bootstrapping (logging) in the development; // mode case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:114,Usability,learn,learn,114,"// Hold on to a default advisor for:; // 1) the implementation of canEvictHintInterference, because we didn't; // learn that nuance yet; 2) for bootstrapping (logging) in the development; // mode case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:43,Deployability,Release,Release,43,// ===================================; // Release (AOT) - specifics; // ===================================,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:130,Testability,log,log,130,// ===================================; // Development mode-specifics; // ===================================; //; // Features we log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:255,Availability,error,error,255,"// The function pass manager would run all the function passes for a; // function, so we assume the last context belongs to this function. If; // this invariant ever changes, we can implement at that time switching; // contexts. At this point, it'd be an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:13,Testability,log,log,13,"// We always log the output; in particular, if we're not evaluating, we; // don't have an output spec json file. That's why we handle the; // 'normal' output separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:68,Performance,load,load,68,"// OK, so if we made it this far, this LR is an eviction candidate, load its; // features.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:13,Availability,avail,available,13,"// Number of available candidates - if 0, no need to continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:86,Availability,avail,available,86,// Make sure we don't have leftover partial state from an attempt where we; // had no available candidates and bailed out early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:128,Availability,mask,mask,128,"// Track the index->register mapping because AllocationOrder doesn't do that; // and we'd have to scan it.; // Also track their mask, to write asserts/debug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:143,Testability,assert,asserts,143,"// Track the index->register mapping because AllocationOrder doesn't do that; // and we'd have to scan it.; // Also track their mask, to write asserts/debug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:140,Usability,simpl,simpler,140,"// Track the largest value of features seen during this eviction session. We; // only normalize (some of) the float features, but it's just simpler to; // dimension 'Largest' to all the features, especially since we have the; // 'DoNotNormalize' list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:134,Availability,avail,available,134,"// Same overal idea as in the default eviction policy - we visit the values; // of AllocationOrder one at a time. If it's not legally available, we mask; // off the corresponding feature column (==do nothing because we already; // reset all the features to 0) Use Pos to capture the column we load; // features at - in AllocationOrder order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:148,Availability,mask,mask,148,"// Same overal idea as in the default eviction policy - we visit the values; // of AllocationOrder one at a time. If it's not legally available, we mask; // off the corresponding feature column (==do nothing because we already; // reset all the features to 0) Use Pos to capture the column we load; // features at - in AllocationOrder order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:293,Performance,load,load,293,"// Same overal idea as in the default eviction policy - we visit the values; // of AllocationOrder one at a time. If it's not legally available, we mask; // off the corresponding feature column (==do nothing because we already; // reset all the features to 0) Use Pos to capture the column we load; // features at - in AllocationOrder order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:33,Usability,learn,learn,33,"// Nothing to decide, nothing to learn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:53,Availability,mask,masked,53,"// If we must find eviction, the candidate should be masked out of the; // decision making process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:57,Availability,mask,mask,57,// The contract with the ML side is that CandidatePos is mask == 1 (i.e.; // Regs[CandidatePos].second),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:7,Integrability,contract,contract,7,// The contract with the ML side is that CandidatePos is mask == 1 (i.e.; // Regs[CandidatePos].second),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:106,Safety,avoid,avoid,106,"// If the segments are not overlapping, we need to move to the beginning; // index of the next segment to avoid having instructions not attached to; // any register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:58,Testability,log,logging,58,"// Find the index of the selected PhysReg. We need it for logging,; // otherwise this is wasted cycles (but so would starting development mode; // without a model nor logging)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:167,Testability,log,logging,167,"// Find the index of the selected PhysReg. We need it for logging,; // otherwise this is wasted cycles (but so would starting development mode; // without a model nor logging)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:94,Testability,log,log,94,"// TODO(mtrofin): when we support optional rewards, this can go away. In the; // meantime, we log the ""pretend"" reward (0) for the previous observation; // before starting a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h:461,Testability,test,testing,461,"//===- MLRegAllocEvictAdvisor.cpp - ML eviction advisor -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Function declarations of utilities related to feature extraction for unit; // testing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h:3,Testability,Log,Logically,3,"// Logically, we can think of the feature set given to the evaluator as a 2D; // matrix. The rows are the features (see next). The columns correspond to the; // interferences. We treat the candidate virt reg as an 'interference', too, as; // its feature set is the same as that of the interferring ranges. So we'll have; // MaxInterferences + 1 columns and by convention, we will use the last column; // for the virt reg seeking allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h:71,Modifiability,variab,variable,71,"// The number of instructions that a specific live range might have is variable,; // but we're passing in a single matrix of instructions and tensorflow saved; // models only support a fixed input size, so we have to cap the number of; // instructions that can be passed along. The specific value was derived from; // experimentation such that the majority of eviction problems would be; // completely covered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:436,Integrability,inject,injection,436,"//===- MLRegAllocPriorityAdvisor.cpp - ML priority advisor-----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of the ML priority advisor and reward injection pass; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:436,Security,inject,injection,436,"//===- MLRegAllocPriorityAdvisor.cpp - ML priority advisor-----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of the ML priority advisor and reward injection pass; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:81,Availability,error,error,81,"// The assumption is that if the Runner could not be constructed, we emit-ed; // error, and we shouldn't be asking for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:43,Deployability,Release,Release,43,// ===================================; // Release (AOT) - specifics; // ===================================,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:130,Testability,log,log,130,// ===================================; // Development mode-specifics; // ===================================; //; // Features we log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:255,Availability,error,error,255,"// The function pass manager would run all the function passes for a; // function, so we assume the last context belongs to this function. If; // this invariant ever changes, we can implement at that time switching; // contexts. At this point, it'd be an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:16,Testability,log,logs,16,// Save all the logs (when requested).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:13,Testability,log,log,13,"// We always log the output; in particular, if we're not evaluating, we; // don't have an output spec json file. That's why we handle the; // 'normal' output separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:94,Testability,log,log,94,"// TODO(mtrofin): when we support optional rewards, this can go away. In the; // meantime, we log the ""pretend"" reward (0) for the previous observation; // before starting a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:37,Deployability,pipeline,pipeline,37,"//===- ModuloSchedule.cpp - Software pipeline schedule expansion ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:46,Energy Efficiency,schedul,schedule,46,"//===- ModuloSchedule.cpp - Software pipeline schedule expansion ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:251,Deployability,pipeline,pipelined,251,"// Remember the registers that are used in different stages. The index is; // the iteration, or stage, that the instruction is scheduled in. This is; // a map between register names in the original block and the names created; // in each stage of the pipelined loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:127,Energy Efficiency,schedul,scheduled,127,"// Remember the registers that are used in different stages. The index is; // the iteration, or stage, that the instruction is scheduled in. This is; // a map between register names in the original block and the names created; // in each stage of the pipelined loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:85,Deployability,update,updated,85,// The renaming destination by Phis for the registers across stages.; // This map is updated during Phis generation to point to the most recent; // renaming destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:52,Deployability,pipeline,pipeline,52,// Generate the prolog instructions that set up the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:51,Deployability,pipeline,pipelined,51,"// Rearrange the instructions to generate the new, pipelined loop,; // and update register names as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:75,Deployability,update,update,75,"// Rearrange the instructions to generate the new, pipelined loop,; // and update register names as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:59,Deployability,update,update,59,"// Copy any terminator instructions to the new kernel, and update; // names as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:52,Deployability,pipeline,pipeline,52,// Generate the epilog instructions to complete the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:50,Modifiability,variab,variables,50,// Remove dead instructions due to loop induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:17,Deployability,pipeline,pipeline,17,/// Generate the pipeline prolog code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:17,Deployability,pipeline,pipeline,17,/// Generate the pipeline epilog code. The epilog code finishes the iterations; /// that were started in either the prolog or the kernel. We create a basic; /// block for each stage that needs to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:34,Integrability,depend,depending,34,// Add instructions to the epilog depending on the current block.; // Process instructions in original program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:51,Deployability,update,updated,51,// Instructions with memoperands in the epilog are updated with; // conservative values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:58,Deployability,pipeline,pipelined,58,/// Generate Phis for the specific block in the generated pipelined code.; /// This function looks at the Phis from the original code to guide the; /// creation of new Phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:137,Usability,guid,guide,137,/// Generate Phis for the specific block in the generated pipelined code.; /// This function looks at the Phis from the original code to guide the; /// creation of new Phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:113,Integrability,depend,depends,113,"// Compute the stage number for the initial value of the Phi, which; // comes from the prolog. The prolog to use depends on to which kernel/; // epilog that we're adding the Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:126,Energy Efficiency,schedul,scheduled,126,"// Adjust the number of Phis needed depending on the number of prologs left,; // and the distance from where the Phi is first scheduled. The number of; // Phis cannot exceed the number of prolog stages. Each stage can; // potentially define two values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:36,Integrability,depend,depending,36,"// Adjust the number of Phis needed depending on the number of prologs left,; // and the distance from where the Phi is first scheduled. The number of; // Phis cannot exceed the number of prolog stages. Each stage can; // potentially define two values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:237,Energy Efficiency,schedul,scheduled,237,"// In the epilog, we may need to look back one stage to get the correct; // Phi name, because the epilog and prolog blocks execute the same stage.; // The correct name is from the previous block only when the Phi has; // been completely scheduled prior to the epilog, and Phi value is not; // needed in multiple stages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:78,Energy Efficiency,schedul,scheduled,78,// Adjust the computations below when the phi and the loop definition; // are scheduled in different stages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:26,Energy Efficiency,schedul,scheduled,26,"// If the Phi hasn't been scheduled, then use the initial Phi operand; // value. Otherwise, use the scheduled version of the instruction. This; // is a little complicated when a Phi references another Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:100,Energy Efficiency,schedul,scheduled,100,"// If the Phi hasn't been scheduled, then use the initial Phi operand; // value. Otherwise, use the scheduled version of the instruction. This; // is a little complicated when a Phi references another Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:37,Energy Efficiency,schedul,scheduled,37,// Check if the Phi has already been scheduled in a prolog stage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:37,Energy Efficiency,schedul,scheduled,37,"// Check if the Phi has already been scheduled, but the loop instruction; // is either another Phi, or doesn't occur in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:159,Energy Efficiency,schedul,scheduled,159,"// In the epilog, a map lookup is needed to get the value from the kernel,; // or previous epilog block. How is does this depends on if the; // instruction is scheduled in the previous block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:122,Integrability,depend,depends,122,"// In the epilog, a map lookup is needed to get the value from the kernel,; // or previous epilog block. How is does this depends on if the; // instruction is scheduled in the previous block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:114,Energy Efficiency,schedul,scheduled,114,"// Check if we can reuse an existing Phi. This occurs when a Phi; // references another Phi, and the other Phi is scheduled in an; // earlier stage. We can try to reuse an existing Phi up until the last; // stage of the current Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:3,Deployability,Update,Update,3,// Update the map with the new Phi name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:45,Deployability,pipeline,pipelined,45,"// We define the Phis after creating the new pipelined code, so; // we need to rename the Phi values in scheduled instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:104,Energy Efficiency,schedul,scheduled,104,"// We define the Phis after creating the new pipelined code, so; // we need to rename the Phi values in scheduled instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:23,Energy Efficiency,schedul,scheduled,23,"// If the Phi has been scheduled, use the new name for rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:125,Energy Efficiency,schedul,scheduled,125,// Check if we need to rename any uses that occurs after the loop. The; // register to replace depends on whether the Phi is scheduled in the; // epilog.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:95,Integrability,depend,depends,95,// Check if we need to rename any uses that occurs after the loop. The; // register to replace depends on whether the Phi is scheduled in the; // epilog.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:20,Integrability,depend,dependent,20,"// In the kernel, a dependent Phi uses the value from this Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:3,Deployability,Update,Update,3,// Update the map with the new Phi name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:72,Energy Efficiency,schedul,scheduling,72,// Check if we need to rename a Phi that has been eliminated due to; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:59,Deployability,pipeline,pipelined,59,/// Generate Phis for the specified block in the generated pipelined code.; /// These are new Phis needed because the definition is scheduled after the; /// use in the pipelined sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:168,Deployability,pipeline,pipelined,168,/// Generate Phis for the specified block in the generated pipelined code.; /// These are new Phis needed because the definition is scheduled after the; /// use in the pipelined sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:132,Energy Efficiency,schedul,scheduled,132,/// Generate Phis for the specified block in the generated pipelined code.; /// These are new Phis needed because the definition is scheduled after the; /// use in the pipelined sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:18,Energy Efficiency,schedul,scheduled,18,// An instruction scheduled in stage 0 and is used after the loop; // requires a phi in the epilog for the last definition from either; // the kernel or prolog.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:40,Energy Efficiency,Schedul,Scheduled,40,"// Example for; // Org:; // %Org = ... (Scheduled at Stage#0, NumPhi = 2); //; // Prolog0 (Stage0):; // %Clone0 = ...; // Prolog1 (Stage1):; // %Clone1 = ...; // Kernel (Stage2):; // %Phi0 = Phi %Clone1, Prolog1, %Clone2, Kernel; // %Phi1 = Phi %Clone0, Prolog1, %Phi0, Kernel; // %Clone2 = ...; // Epilog0 (Stage3):; // %Phi2 = Phi %Clone1, Prolog1, %Clone2, Kernel; // %Phi3 = Phi %Clone0, Prolog1, %Phi0, Kernel; // Epilog1 (Stage4):; // %Phi4 = Phi %Clone0, Prolog0, %Phi2, Epilog0; //; // VRMap = {0: %Clone0, 1: %Clone1, 2: %Clone2}; // VRMapPhi (after Kernel) = {0: %Phi1, 1: %Phi0}; // VRMapPhi (after Epilog0) = {0: %Phi3, 1: %Phi2}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:20,Deployability,update,update,20,// Rewrite uses and update the map. The actions depend upon whether; // we generating code for the kernel or epilog blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:48,Integrability,depend,depend,48,// Rewrite uses and update the map. The actions depend upon whether; // we generating code for the kernel or epilog blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite uses and update the map. The actions depend upon whether; // we generating code for the kernel or epilog blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:95,Modifiability,variab,variable,95,"/// Remove instructions that generate values with no uses.; /// Typically, these are induction variable operations that generate values; /// used in the loop itself. A dead instruction has a definition with; /// no uses, or uses that occur in the original loop only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:17,Safety,safe,safe,17,"// Check if it's safe to remove the instruction due to side effects.; // We can, and want to, remove Phis here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Deployability,Update,Update,4,/// Update the memory operand with a new offset when the pipeliner; /// generates a new copy of the instruction that refers to a; /// different memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:57,Deployability,pipeline,pipeliner,57,/// Update the memory operand with a new offset when the pipeliner; /// generates a new copy of the instruction that refers to a; /// different memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:38,Deployability,pipeline,pipelined,38,"/// Clone the instruction for the new pipelined loop and update the; /// memory operands, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:57,Deployability,update,update,57,"/// Clone the instruction for the new pipelined loop and update the; /// memory operands, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:38,Deployability,pipeline,pipelined,38,"/// Clone the instruction for the new pipelined loop. If needed, this; /// function updates the instruction using the values saved in the; /// InstrChanges structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:84,Deployability,update,updates,84,"/// Clone the instruction for the new pipelined loop. If needed, this; /// function updates the instruction using the values saved in the; /// InstrChanges structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Deployability,Update,Update,4,/// Update the machine instruction with new virtual registers. This; /// function may change the definitions and/or uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:34,Energy Efficiency,schedul,scheduled,34,// The loop value hasn't yet been scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:53,Energy Efficiency,schedul,scheduled,53,"// The loop value is another phi, which has not been scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:49,Energy Efficiency,schedul,scheduled,49,"// The loop value is another phi, which has been scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:117,Energy Efficiency,schedul,scheduled,117,"/// Rewrite the Phi values in the specified block to use the mappings; /// from the initial operand. Once the Phi is scheduled, we switch; /// to using the loop value instead of the Phi value, so those names; /// do not need to be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the Phi values in the specified block to use the mappings; /// from the initial operand. Once the Phi is scheduled, we switch; /// to using the loop value instead of the Phi value, so those names; /// do not need to be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:25,Energy Efficiency,schedul,scheduled,25,"/// Rewrite a previously scheduled instruction to use the register value; /// from the new instruction. Make sure the instruction occurs in the; /// basic block, and we don't change the uses in the new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite a previously scheduled instruction to use the register value; /// from the new instruction. Make sure the instruction occurs in the; /// basic block, and we don't change the uses in the new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:31,Energy Efficiency,schedul,scheduled,31,// Rewrite uses that have been scheduled already to use the new; // Phi register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite uses that have been scheduled already to use the new; // Phi register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:29,Energy Efficiency,schedul,scheduled,29,// This is the stage for the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:7,Energy Efficiency,schedul,scheduled,7,"// The scheduled instruction occurs before the scheduled Phi, and the; // Phi is not loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:47,Energy Efficiency,schedul,scheduled,47,"// The scheduled instruction occurs before the scheduled Phi, and the; // Phi is not loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:62,Energy Efficiency,schedul,schedule,62,/// Rewrites the kernel block in-place to adhere to the given schedule.; /// KernelRewriter holds all of the state required to perform the rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Modifiability,Rewrite,Rewrites,4,/// Rewrites the kernel block in-place to adhere to the given schedule.; /// KernelRewriter holds all of the state required to perform the rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:127,Performance,perform,perform,127,/// Rewrites the kernel block in-place to adhere to the given schedule.; /// KernelRewriter holds all of the state required to perform the rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:81,Energy Efficiency,schedul,schedule,81,// Reg is used by MI. Return the new register MI should use to adhere to the; // schedule. Insert phis as necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:31,Energy Efficiency,schedul,schedule,31,"// Rearrange the loop to be in schedule order. Note that the schedule may; // contain instructions that are not owned by the loop block (InstrChanges and; // friends), so we gracefully handle unowned instructions and delete any; // instructions that weren't in the schedule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:61,Energy Efficiency,schedul,schedule,61,"// Rearrange the loop to be in schedule order. Note that the schedule may; // contain instructions that are not owned by the loop block (InstrChanges and; // friends), so we gracefully handle unowned instructions and delete any; // instructions that weren't in the schedule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:265,Energy Efficiency,schedul,schedule,265,"// Rearrange the loop to be in schedule order. Note that the schedule may; // contain instructions that are not owned by the loop block (InstrChanges and; // friends), so we gracefully handle unowned instructions and delete any; // instructions that weren't in the schedule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:28,Energy Efficiency,schedul,scheduled,28,// At this point all of the scheduled instructions are between FirstMI; // and the end of the block. Kill from the first non-phi to FirstMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:25,Usability,simpl,simple,25,// Non-phi producers are simple to remap. Insert as many phis as the; // difference between the consumer and producer stages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:196,Deployability,pipeline,pipeliner,196,"// This schedule is only representable if ProducerStage == ConsumerStage+1.; // In addition, Consumer's cycle must be scheduled after Producer in the; // rescheduled loop. This is enforced by the pipeliner's ASAP and ALAP; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:8,Energy Efficiency,schedul,schedule,8,"// This schedule is only representable if ProducerStage == ConsumerStage+1.; // In addition, Consumer's cycle must be scheduled after Producer in the; // rescheduled loop. This is enforced by the pipeliner's ASAP and ALAP; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:118,Energy Efficiency,schedul,scheduled,118,"// This schedule is only representable if ProducerStage == ConsumerStage+1.; // In addition, Consumer's cycle must be scheduled after Producer in the; // rescheduled loop. This is enforced by the pipeliner's ASAP and ALAP; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:18,Modifiability,variab,variables,18,// Silence unused variables in non-asserts mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:35,Testability,assert,asserts,35,// Silence unused variables in non-asserts mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:200,Modifiability,rewrite,rewrite,200,// Peel off the first phi from Defaults and insert a phi between producer; // and consumer. This phi will not be at the front of the block so we; // consider it illegal. It will only exist during the rewrite process; it; // needs to exist while we peel off prologs because these could take the; // default value. After that we can replace all uses with the loop producer; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:100,Energy Efficiency,schedul,scheduled,100,// The consumer optionally consumes LoopProducer in the same iteration; // (because the producer is scheduled at an earlier cycle than the consumer); // or the initial value. To facilitate this we create an illegal block here; // by embedding a phi in the middle of the block. We will fix this up; // immediately prior to pruning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:41,Modifiability,rewrite,rewrite,41,"// Found a phi taking undef as input, so rewrite it to take InitReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:44,Deployability,pipeline,pipelined,44,"/// Describes an operand in the kernel of a pipelined loop. Characteristics of; /// the operand are discovered, such as how many in-loop PHIs it has to jump; /// through and defaults for these phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:93,Safety,avoid,avoid,93,// Helper to clone Phi instructions into the destination block. We clone Phi; // greedily to avoid combinatorial explosion of Phi instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:97,Modifiability,variab,variable,97,// Keep track at which iteration each phi belongs to. We need it to know; // what version of the variable to use during prologue/epilogue stitching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:56,Deployability,update,updated,56,// Move stage one block at a time so that Phi nodes are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:50,Performance,optimiz,optimize,50,"// Now all remapping has been done, we're free to optimize the generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:39,Modifiability,rewrite,rewrite,39,// Clone all phis in BB into NewBB and rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:133,Availability,error,error,133,// Dump the schedule before we invalidate and remap all its instructions.; // Stash it in a string so we can print it if we found an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:12,Energy Efficiency,schedul,schedule,12,// Dump the schedule before we invalidate and remap all its instructions.; // Stash it in a string so we can print it if we found an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:16,Performance,optimiz,optimized,16,// The expander optimized away the kernel. We can't do any useful checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp:35,Energy Efficiency,Schedul,Scheduler,35,"//===- MultiHazardRecognizer.cpp - Scheduler Support ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MultiHazardRecognizer class, which is a wrapper; // for a set of ScheduleHazardRecognizer instances; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp:473,Energy Efficiency,Schedul,ScheduleHazardRecognizer,473,"//===- MultiHazardRecognizer.cpp - Scheduler Support ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MultiHazardRecognizer class, which is a wrapper; // for a set of ScheduleHazardRecognizer instances; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp:448,Integrability,wrap,wrapper,448,"//===- MultiHazardRecognizer.cpp - Scheduler Support ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MultiHazardRecognizer class, which is a wrapper; // for a set of ScheduleHazardRecognizer instances; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:7,Performance,Optimiz,OptimizePHIs,7,"//===- OptimizePHIs.cpp - Optimize machine instruction PHIs ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes machine instruction PHIs to take advantage of; // opportunities created during DAG legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:26,Performance,Optimiz,Optimize,26,"//===- OptimizePHIs.cpp - Optimize machine instruction PHIs ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes machine instruction PHIs to take advantage of; // opportunities created during DAG legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:393,Performance,optimiz,optimizes,393,"//===- OptimizePHIs.cpp - Optimize machine instruction PHIs ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes machine instruction PHIs to take advantage of; // opportunities created during DAG legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:106,Performance,optimiz,optimizations,106,"// Find dead PHI cycles and PHI cycles that can be replaced by a single; // value. InstCombine does these optimizations, but DAG legalization may; // introduce new opportunities, e.g., when i64 values are split up for; // 32-bit targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:4,Performance,Optimiz,OptimizeBB,4,/// OptimizeBB - Remove dead PHI cycles and PHI cycles that can be replaced by; /// a single value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp:51,Performance,multi-thread,multi-thread,51,"// We want to clone the module in a new context to multi-thread the; // codegen. We do it by serializing partition modules to bitcode; // (while still on the main thread, in order to avoid data races) and; // spinning up new threads which deserialize the partitions into; // separate contexts.; // FIXME: Provide a more direct way to do this in LLVM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp:183,Safety,avoid,avoid,183,"// We want to clone the module in a new context to multi-thread the; // codegen. We do it by serializing partition modules to bitcode; // (while still on the main thread, in order to avoid data races) and; // spinning up new threads which deserialize the partitions into; // separate contexts.; // FIXME: Provide a more direct way to do this in LLVM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp:8,Deployability,Patch,PatchableFunction,8,"//===-- PatchableFunction.cpp - Patchable prologues for LLVM -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements edits function bodies in place to support the; // ""patchable-function"" attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp:32,Deployability,Patch,Patchable,32,"//===-- PatchableFunction.cpp - Patchable prologues for LLVM -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements edits function bodies in place to support the; // ""patchable-function"" attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp:454,Deployability,patch,patchable-function,454,"//===-- PatchableFunction.cpp - Patchable prologues for LLVM -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements edits function bodies in place to support the; // ""patchable-function"" attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:535,Modifiability,extend,extended,535,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1760,Modifiability,Rewrite,Rewrite,1760,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:40,Performance,Optimiz,Optimizations,40,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:383,Performance,Perform,Perform,383,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:400,Performance,optimiz,optimizations,400,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:445,Performance,Optimiz,Optimize,445,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:473,Performance,Optimiz,Optimization,473,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:747,Performance,optimiz,optimization,747,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:874,Performance,Optimiz,Optimize,874,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:903,Performance,Optimiz,Optimization,903,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1486,Performance,Optimiz,Optimize,1486,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1495,Performance,Load,Loads,1495,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1510,Performance,Load,Loads,1510,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1563,Performance,load,load,1563,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1590,Performance,load,loads,1590,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1682,Performance,Optimiz,Optimize,1682,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1791,Safety,avoid,avoid,1791,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Performance,Optimiz,Optimize,3,// Optimize Extensions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:290,Modifiability,rewrite,rewrite,290,"/// Helper class to track the possible sources of a value defined by; /// a (chain of) copy related instructions.; /// Given a definition (instruction and definition index), this class; /// follows the use-def chain to find successive suitable sources.; /// The given source can be used to rewrite the definition into; /// def = COPY src.; ///; /// For instance, let us consider the following snippet:; /// v0 =; /// v2 = INSERT_SUBREG v1, v0, sub0; /// def = COPY v2.sub0; ///; /// Using a ValueTracker for def = COPY v2.sub0 will give the following; /// suitable sources:; /// v2.sub0 and v0.; /// Then, def can be rewritten into def = COPY v0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:32,Performance,perform,perform,32,/// MachineRegisterInfo used to perform tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:37,Performance,perform,perform,37,/// Optional TargetInstrInfo used to perform some complex tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:46,Availability,avail,available,46,"/// Following the use-def chain, get the next available source; /// for the tracked value.; /// \return A ValueTrackerResult containing a set of registers; /// and sub registers with tracked values. A ValueTrackerResult with; /// an empty set of registers means no source was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:11,Availability,error,error,11,"// It's an error to translate this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1026 = SUBREG_TO_REG 0, %reg1024, 4; //; // into this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1027 = COPY %reg1025:4; // %reg1026 = SUBREG_TO_REG 0, %reg1027, 4; //; // The problem here is that SUBREG_TO_REG is there to assert that an; // implicit zext occurs. It doesn't insert a zext instruction. If we allow; // the COPY here, it will give us the value after the <sext>, not the; // original value of %reg1024 before <sext>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:319,Testability,assert,assert,319,"// It's an error to translate this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1026 = SUBREG_TO_REG 0, %reg1024, 4; //; // into this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1027 = COPY %reg1025:4; // %reg1026 = SUBREG_TO_REG 0, %reg1027, 4; //; // The problem here is that SUBREG_TO_REG is there to assert that an; // implicit zext occurs. It doesn't insert a zext instruction. If we allow; // the COPY here, it will give us the value after the <sext>, not the; // original value of %reg1024 before <sext>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:18,Modifiability,extend,extend,18,// We may want to extend the live range of the extension result in order; // to replace these uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:54,Modifiability,extend,extend,54,// Both will be live out of the def MBB anyway. Don't extend live range of; // the extension result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Extend,Extend,3,// Extend the liveness of the extension result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:137,Availability,down,down,137,"// Look for PHI uses of the extended result, we don't want to extend the; // liveness of a PHI input. It breaks all kinds of assumptions down; // stream. A PHI use is expected to be the kill of its source values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:28,Modifiability,extend,extended,28,"// Look for PHI uses of the extended result, we don't want to extend the; // liveness of a PHI input. It breaks all kinds of assumptions down; // stream. A PHI use is expected to be the kill of its source values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:62,Modifiability,extend,extend,62,"// Look for PHI uses of the extended result, we don't want to extend the; // liveness of a PHI input. It breaks all kinds of assumptions down; // stream. A PHI use is expected to be the kill of its source values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:32,Usability,clear,clear,32,"// About to add uses of DstReg, clear DstReg's kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:111,Performance,optimiz,optimize,111,"// If this instruction is a comparison against zero and isn't comparing a; // physical register, we can try to optimize it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:14,Performance,optimiz,optimize,14,// Attempt to optimize the comparison instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize a select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:15,Usability,simpl,simpler,15,/// Check if a simpler conditional branch can be generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:781,Availability,avail,available,781,"/// Try to find the next source that share the same register file; /// for the value defined by \p Reg and \p SubReg.; /// When true is returned, the \p RewriteMap can be used by the client to; /// retrieve all Def -> Use along the way up to the next source. Any found; /// Use that is not itself a key for another entry, is the next source to; /// use. During the search for the next source, multiple sources can be found; /// given multiple incoming sources of a PHI instruction. In this case, we; /// look in each PHI source for the next source; all found next sources must; /// share the same register file as \p Reg and \p SubReg. The client should; /// then be capable to rewrite all intermediate PHIs to get the next source.; /// \return False if no alternative sources are available. True otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:153,Modifiability,Rewrite,RewriteMap,153,"/// Try to find the next source that share the same register file; /// for the value defined by \p Reg and \p SubReg.; /// When true is returned, the \p RewriteMap can be used by the client to; /// retrieve all Def -> Use along the way up to the next source. Any found; /// Use that is not itself a key for another entry, is the next source to; /// use. During the search for the next source, multiple sources can be found; /// given multiple incoming sources of a PHI instruction. In this case, we; /// look in each PHI source for the next source; all found next sources must; /// share the same register file as \p Reg and \p SubReg. The client should; /// then be capable to rewrite all intermediate PHIs to get the next source.; /// \return False if no alternative sources are available. True otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:678,Modifiability,rewrite,rewrite,678,"/// Try to find the next source that share the same register file; /// for the value defined by \p Reg and \p SubReg.; /// When true is returned, the \p RewriteMap can be used by the client to; /// retrieve all Def -> Use along the way up to the next source. Any found; /// Use that is not itself a key for another entry, is the next source to; /// use. During the search for the next source, multiple sources can be found; /// given multiple incoming sources of a PHI instruction. In this case, we; /// look in each PHI source for the next source; all found next sources must; /// share the same register file as \p Reg and \p SubReg. The client should; /// then be capable to rewrite all intermediate PHIs to get the next source.; /// \return False if no alternative sources are available. True otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:89,Safety,abort,abort,89,"// Follow the chain of copies until we find a more suitable source, a phi; // or have to abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Safety,Abort,Abort,3,// Abort at the end of a chain (without finding a suitable source).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:66,Safety,avoid,avoid,66,// An existent entry with multiple sources is a PHI cycle we must avoid.; // Otherwise it's an entry with a valid next source we already found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:10,Modifiability,extend,extend,10,"// Do not extend the live-ranges of physical registers as they add; // constraints to the register allocator. Moreover, if we want to extend; // the live-range of a physical register, unlike SSA virtual register,; // we will have to check that they aren't redefine before the related use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:134,Modifiability,extend,extend,134,"// Do not extend the live-ranges of physical registers as they add; // constraints to the register allocator. Moreover, if we want to extend; // the live-range of a physical register, unlike SSA virtual register,; // we will have to check that they aren't redefine before the related use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:66,Performance,optimiz,optimize,66,"// If we did not find a more suitable source, there is nothing to optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:15,Modifiability,extend,extended,15,"// Since we're extended the lifetime of RegPair.Reg, clear the; // kill flags to account for that and make RegPair.Reg reaches; // the new PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:53,Usability,clear,clear,53,"// Since we're extended the lifetime of RegPair.Reg, clear the; // kill flags to account for that and make RegPair.Reg reaches; // the new PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Integrability,Interface,Interface,4,/// Interface to query instructions amenable to copy rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:606,Modifiability,rewrite,rewrite,606,"/// Get the next rewritable source (SrcReg, SrcSubReg) and; /// the related value that it affects (DstReg, DstSubReg).; /// A source is considered rewritable if its register class and the; /// register class of the related DstReg may not be register; /// coalescer friendly. In other words, given a copy-like instruction; /// not all the arguments may be returned at rewritable source, since; /// some arguments are none to be register coalescer friendly.; ///; /// Each call of this method moves the current source to the next; /// rewritable source.; /// For instance, let CopyLike be the instruction to rewrite.; /// CopyLike has one definition and one source:; /// dst.dstSubIdx = CopyLike src.srcSubIdx.; ///; /// The first call will give the first rewritable source, i.e.,; /// the only source this instruction has:; /// (SrcReg, SrcSubReg) = (src, srcSubIdx).; /// This source defines the whole definition, i.e.,; /// (DstReg, DstSubReg) = (dst, dstSubIdx).; ///; /// The second and subsequent calls will return false, as there is only one; /// rewritable source.; ///; /// \return True if a rewritable source has been found, false otherwise.; /// The output arguments are valid if and only if true is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the current source with \p NewReg and \p NewSubReg if possible.; /// \return True if the rewriting was possible, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Modifiability,Rewrite,Rewriter,4,/// Rewriter for COPY instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:20,Modifiability,rewrite,rewrite,20,/// Helper class to rewrite uncoalescable copy like instructions; /// into new COPY (coalescable friendly) instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:13,Modifiability,Rewrite,Rewriter,13,/// \see See Rewriter::getNextRewritableSource(); /// All such sources need to be considered rewritable in order to; /// rewrite a uncoalescable copy-like instruction. This method return; /// each definition that must be checked if rewritable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:121,Modifiability,rewrite,rewrite,121,/// \see See Rewriter::getNextRewritableSource(); /// All such sources need to be considered rewritable in order to; /// rewrite a uncoalescable copy-like instruction. This method return; /// each definition that must be checked if rewritable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:16,Modifiability,rewrite,rewriter,16,/// Specialized rewriter for INSERT_SUBREG instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:13,Modifiability,Rewrite,Rewriter,13,"/// \see See Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst = INSERT_SUBREG Src1, Src2.src2SubIdx, subIdx.; /// Src1 has the same register class has dst, hence, there is; /// nothing to rewrite.; /// Src2.src2SubIdx, may not be register coalescer friendly.; /// Therefore, the first call to this method returns:; /// (SrcReg, SrcSubReg) = (Src2, src2SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx).; ///; /// Subsequence calls will return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:227,Modifiability,rewrite,rewrite,227,"/// \see See Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst = INSERT_SUBREG Src1, Src2.src2SubIdx, subIdx.; /// Src1 has the same register class has dst, hence, there is; /// nothing to rewrite.; /// Src2.src2SubIdx, may not be register coalescer friendly.; /// Therefore, the first call to this method returns:; /// (SrcReg, SrcSubReg) = (Src2, src2SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx).; ///; /// Subsequence calls will return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:44,Modifiability,rewrite,rewrite,44,"// If we already get the only source we can rewrite, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:16,Modifiability,rewrite,rewriter,16,/// Specialized rewriter for EXTRACT_SUBREG instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:9,Modifiability,Rewrite,Rewriter,9,"/// \see Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst.dstSubIdx = EXTRACT_SUBREG Src, subIdx.; /// There is only one rewritable source: Src.subIdx,; /// which defines dst.dstSubIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:44,Modifiability,rewrite,rewrite,44,"// If we already get the only source we can rewrite, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:26,Modifiability,rewrite,rewrite,26,// The only source we can rewrite is the input register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:71,Modifiability,rewrite,rewrite,71,"// If we find a source that does not require to extract something,; // rewrite the operation with a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the operation as a COPY.; // Get rid of the sub-register index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:16,Modifiability,rewrite,rewriter,16,/// Specialized rewriter for REG_SEQUENCE instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:227,Availability,avail,available,227,"/// \see Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst = REG_SEQUENCE Src1.src1SubIdx, subIdx1, Src2.src2SubIdx, subIdx2.; /// Each call will return a different source, walking all the available; /// source.; ///; /// The first call returns:; /// (SrcReg, SrcSubReg) = (Src1, src1SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx1).; ///; /// The second call returns:; /// (SrcReg, SrcSubReg) = (Src2, src2SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx2).; ///; /// And so on, until all the sources have been traversed, then; /// it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:9,Modifiability,Rewrite,Rewriter,9,"/// \see Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst = REG_SEQUENCE Src1.src1SubIdx, subIdx1, Src2.src2SubIdx, subIdx2.; /// Each call will return a different source, walking all the available; /// source.; ///; /// The first call returns:; /// (SrcReg, SrcSubReg) = (Src1, src1SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx1).; ///; /// The second call returns:; /// (SrcReg, SrcSubReg) = (Src2, src2SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx2).; ///; /// And so on, until all the sources have been traversed, then; /// it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:13,Modifiability,rewrite,rewrite,13,"// We cannot rewrite out of bound operands.; // Moreover, rewritable sources are at odd positions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:113,Energy Efficiency,allocate,allocated,113,// end anonymous namespace; /// Get the appropriated Rewriter for \p MI.; /// \return A pointer to a dynamically allocated Rewriter or nullptr if no; /// rewriter works for \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:53,Modifiability,Rewrite,Rewriter,53,// end anonymous namespace; /// Get the appropriated Rewriter for \p MI.; /// \return A pointer to a dynamically allocated Rewriter or nullptr if no; /// rewriter works for \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:123,Modifiability,Rewrite,Rewriter,123,// end anonymous namespace; /// Get the appropriated Rewriter for \p MI.; /// \return A pointer to a dynamically allocated Rewriter or nullptr if no; /// rewriter works for \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:154,Modifiability,rewrite,rewriter,154,// end anonymous namespace; /// Get the appropriated Rewriter for \p MI.; /// \return A pointer to a dynamically allocated Rewriter or nullptr if no; /// rewriter works for \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:51,Modifiability,Rewrite,RewriteMap,51,"/// Given a \p Def.Reg and Def.SubReg pair, use \p RewriteMap to find; /// the new source to use for rewrite. If \p HandleMultipleSources is true and; /// multiple sources for a given \p Def are found along the way, we found a; /// PHI instructions that needs to be rewritten.; /// TODO: HandleMultipleSources should be removed once we test PHI handling; /// with coalescable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:101,Modifiability,rewrite,rewrite,101,"/// Given a \p Def.Reg and Def.SubReg pair, use \p RewriteMap to find; /// the new source to use for rewrite. If \p HandleMultipleSources is true and; /// multiple sources for a given \p Def are found along the way, we found a; /// PHI instructions that needs to be rewritten.; /// TODO: HandleMultipleSources should be removed once we test PHI handling; /// with coalescable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:336,Testability,test,test,336,"/// Given a \p Def.Reg and Def.SubReg pair, use \p RewriteMap to find; /// the new source to use for rewrite. If \p HandleMultipleSources is true and; /// multiple sources for a given \p Def are found along the way, we found a; /// PHI instructions that needs to be rewritten.; /// TODO: HandleMultipleSources should be removed once we test PHI handling; /// with coalescable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:85,Modifiability,rewrite,rewrite,85,"// Multiple sources, recurse into each source to find a new source; // for it. Then, rewrite the PHI accordingly to its new edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:83,Performance,optimiz,optimization,83,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:330,Performance,optimiz,optimization,330,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:386,Performance,optimiz,optimization,386,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:42,Safety,avoid,avoid,42,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:10,Modifiability,rewrite,rewrite,10,// Do not rewrite physical definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:17,Modifiability,rewrite,rewriter,17,// Get the right rewriter for the current copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each rewritable source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:25,Modifiability,rewrite,rewrite,25,// Get the new source to rewrite. TODO: Only enable handling of multiple; // sources (PHIs) once we have a motivating example and testcases for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:130,Testability,test,testcases,130,// Get the new source to rewrite. TODO: Only enable handling of multiple; // sources (PHIs) once we have a motivating example and testcases for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:15,Modifiability,extend,extended,15,"// We may have extended the live-range of NewSrc, account for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:210,Safety,avoid,avoid,210,"// TODO: We could have a clean-up method to tidy the instruction.; // E.g., v0 = INSERT_SUBREG v1, v1.sub0, sub0; // => v0 = COPY v1; // Currently we haven't seen motivating example for that and we; // want to avoid untested code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the source found through \p Def, by using the \p RewriteMap; /// and create a new COPY instruction. More info about RewriteMap in; /// PeepholeOptimizer::findNextSource. Right now this is only used to handle; /// Uncoalescable copies, since they are copy like instructions that aren't; /// recognized by the register allocator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:61,Modifiability,Rewrite,RewriteMap,61,"/// Rewrite the source found through \p Def, by using the \p RewriteMap; /// and create a new COPY instruction. More info about RewriteMap in; /// PeepholeOptimizer::findNextSource. Right now this is only used to handle; /// Uncoalescable copies, since they are copy like instructions that aren't; /// recognized by the register allocator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:128,Modifiability,Rewrite,RewriteMap,128,"/// Rewrite the source found through \p Def, by using the \p RewriteMap; /// and create a new COPY instruction. More info about RewriteMap in; /// PeepholeOptimizer::findNextSource. Right now this is only used to handle; /// Uncoalescable copies, since they are copy like instructions that aren't; /// recognized by the register allocator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:42,Modifiability,rewrite,rewrite,42,// Find the new source to use in the COPY rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:6,Modifiability,extend,extended,6,"// We extended the lifetime of NewSrc.Reg, clear the kill flags to; // account for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:43,Usability,clear,clear,43,"// We extended the lifetime of NewSrc.Reg, clear the kill flags to; // account for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize copy-like instructions to create; /// register coalescer friendly instruction.; /// The optimization tries to kill-off the \p MI by looking; /// through a chain of copies to find a source that has a compatible; /// register class.; /// If such a source is found, it replace \p MI by a generic COPY; /// operation.; /// \pre isUncoalescableCopy(*MI) is true.; /// \return True, when \p MI has been optimized. In that case, \p MI has; /// been removed from its parent.; /// All COPY instructions created, are inserted in \p LocalMIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:101,Performance,optimiz,optimization,101,"/// Optimize copy-like instructions to create; /// register coalescer friendly instruction.; /// The optimization tries to kill-off the \p MI by looking; /// through a chain of copies to find a source that has a compatible; /// register class.; /// If such a source is found, it replace \p MI by a generic COPY; /// operation.; /// \pre isUncoalescableCopy(*MI) is true.; /// \return True, when \p MI has been optimized. In that case, \p MI has; /// been removed from its parent.; /// All COPY instructions created, are inserted in \p LocalMIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:410,Performance,optimiz,optimized,410,"/// Optimize copy-like instructions to create; /// register coalescer friendly instruction.; /// The optimization tries to kill-off the \p MI by looking; /// through a chain of copies to find a source that has a compatible; /// register class.; /// If such a source is found, it replace \p MI by a generic COPY; /// operation.; /// \pre isUncoalescableCopy(*MI) is true.; /// \return True, when \p MI has been optimized. In that case, \p MI has; /// been removed from its parent.; /// All COPY instructions created, are inserted in \p LocalMIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each rewritable source by generating new COPYs. This works; // differently from optimizeCoalescableCopy since it first makes sure that all; // definitions can be rewritten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:91,Performance,optimiz,optimizeCoalescableCopy,91,// Rewrite each rewritable source by generating new COPYs. This works; // differently from optimizeCoalescableCopy since it first makes sure that all; // definitions can be rewritten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:82,Modifiability,rewrite,rewrite,82,"// If a physical register is here, this is probably for a good reason.; // Do not rewrite that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:28,Modifiability,rewrite,rewrite,28,"// If we do not know how to rewrite this definition, there is no point; // in trying to kill this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the ""copy"" in a way the register coalescer understands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:92,Performance,load,loads,92,/// Check whether MI is a candidate for folding into a later instruction.; /// We only fold loads to virtual registers and the virtual register defined; /// has a single user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:6,Energy Efficiency,reduce,reduce,6,"// To reduce compilation time, we check MRI->hasOneNonDBGUser when inserting; // loads. It should be checked when processing uses of the load, since; // uses can be removed during peephole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:81,Performance,load,loads,81,"// To reduce compilation time, we check MRI->hasOneNonDBGUser when inserting; // loads. It should be checked when processing uses of the load, since; // uses can be removed during peephole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:137,Performance,load,load,137,"// To reduce compilation time, we check MRI->hasOneNonDBGUser when inserting; // loads. It should be checked when processing uses of the load, since; // uses can be removed during peephole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:120,Performance,optimiz,optimization,120,"/// Try folding register operands that are defined by move immediate; /// instructions, i.e. a trivial constant folding optimization, if; /// and only if the def and use are in the same BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:143,Testability,log,logic,143,// FIXME: This is very simple and misses some cases which should be handled when; // motivating examples are found.; //; // The copy rewriting logic should look at uses as well as defs and be able to; // eliminate copies across blocks.; //; // Later copies that are subregister extracts will also not be eliminated since; // only the first copy is considered.; //; // e.g.; // %1 = COPY %0; // %2 = COPY %0:sub1; //; // Should replace %2 uses with %1:sub1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:23,Usability,simpl,simple,23,// FIXME: This is very simple and misses some cases which should be handled when; // motivating examples are found.; //; // The copy rewriting logic should look at uses as well as defs and be able to; // eliminate copies across blocks.; //; // Later copies that are subregister extracts will also not be eliminated since; // only the first copy is considered.; //; // e.g.; // %1 = COPY %0; // %2 = COPY %0:sub1; //; // Should replace %2 uses with %1:sub1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:42,Modifiability,extend,extended,42,// Lifetime of the previous copy has been extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:29,Safety,Avoid,Avoid,29,// %vreg = COPY $physreg; // Avoid using a datastructure which can track multiple live non-allocatable; // phys->virt copies since LLVM doesn't seem to do this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:20,Performance,optimiz,optimization,20,"// Potential missed optimization opportunity: we saw a different virtual; // register get a copy of the non-allocatable physical register, and we only; // track one such copy. Avoid getting confused by this new non-allocatable; // physical register definition, and remove it from the tracked copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:176,Safety,Avoid,Avoid,176,"// Potential missed optimization opportunity: we saw a different virtual; // register get a copy of the non-allocatable physical register, and we only; // track one such copy. Avoid getting confused by this new non-allocatable; // physical register definition, and remove it from the tracked copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:856,Availability,redundant,redundant,856,"/// Phi instructions will eventually be lowered to copy instructions.; /// If phi is in a loop header, a recurrence may formulated around the source; /// and destination of the phi. For such case commuting operands of the; /// instructions in the recurrence may enable coalescing of the copy instruction; /// generated from the phi. For example, if there is a recurrence of; ///; /// LoopHeader:; /// %1 = phi(%0, %100); /// LoopLatch:; /// %0<def, tied1> = ADD %2<def, tied0>, %1; ///; /// , the fact that %0 and %2 are in the same tied operands set makes; /// the coalescing of copy instruction generated from the phi in; /// LoopHeader(i.e. %1 = COPY %0) impossible, because %1 and; /// %2 have overlapping live range. This introduces additional move; /// instruction to the final assembly. However, if we commute %2 and; /// %1 of ADD instruction, the redundant move instruction can be; /// avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:856,Safety,redund,redundant,856,"/// Phi instructions will eventually be lowered to copy instructions.; /// If phi is in a loop header, a recurrence may formulated around the source; /// and destination of the phi. For such case commuting operands of the; /// instructions in the recurrence may enable coalescing of the copy instruction; /// generated from the phi. For example, if there is a recurrence of; ///; /// LoopHeader:; /// %1 = phi(%0, %100); /// LoopLatch:; /// %0<def, tied1> = ADD %2<def, tied0>, %1; ///; /// , the fact that %0 and %2 are in the same tied operands set makes; /// the coalescing of copy instruction generated from the phi in; /// LoopHeader(i.e. %1 = COPY %0) impossible, because %1 and; /// %2 have overlapping live range. This introduces additional move; /// instruction to the final assembly. However, if we commute %2 and; /// %1 of ADD instruction, the redundant move instruction can be; /// avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:895,Safety,avoid,avoided,895,"/// Phi instructions will eventually be lowered to copy instructions.; /// If phi is in a loop header, a recurrence may formulated around the source; /// and destination of the phi. For such case commuting operands of the; /// instructions in the recurrence may enable coalescing of the copy instruction; /// generated from the phi. For example, if there is a recurrence of; ///; /// LoopHeader:; /// %1 = phi(%0, %100); /// LoopLatch:; /// %0<def, tied1> = ADD %2<def, tied0>, %1; ///; /// , the fact that %0 and %2 are in the same tied operands set makes; /// the coalescing of copy instruction generated from the phi in; /// LoopHeader(i.e. %1 = COPY %0) impossible, because %1 and; /// %2 have overlapping live range. This introduces additional move; /// instruction to the final assembly. However, if we commute %2 and; /// %1 of ADD instruction, the redundant move instruction can be; /// avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:191,Performance,perform,perform,191,"// During this forward scan, at some point it needs to answer the question; // ""given a pointer to an MI in the current BB, is it located before or; // after the current instruction"".; // To perform this, the following set keeps track of the MIs already seen; // during the scan, if a MI is not in the set, it is assumed to be located; // after. Newly created MIs have to be inserted in the set as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:69,Performance,optimiz,optimization,69,// Skip debug instructions. They should not affect this peephole; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Performance,optimiz,optimizeExtInstr,3,// optimizeExtInstr might have created new instructions after MI; // and before the already incremented MII. Adjust MII so that the; // next iteration sees the new instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:25,Performance,load,load,25,"// Check whether MI is a load candidate for folding into a later; // instruction. If MI is not a candidate, check whether we can fold an; // earlier load into MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:149,Performance,load,load,149,"// Check whether MI is a load candidate for folding into a later; // instruction. If MI is not a candidate, check whether we can fold an; // earlier load into MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:109,Performance,load,loads,109,"// We visit each operand even after successfully folding a previous; // one. This allows us to fold multiple loads into a single; // instruction. We do assume that optimizeLoadInstr doesn't insert; // foldable uses earlier in the argument list. Since we don't restart; // iteration, we'd miss such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:164,Performance,optimiz,optimizeLoadInstr,164,"// We visit each operand even after successfully folding a previous; // one. This allows us to fold multiple loads into a single; // instruction. We do assume that optimizeLoadInstr doesn't insert; // foldable uses earlier in the argument list. Since we don't restart; // iteration, we'd miss such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:19,Performance,load,load,19,"// We need to fold load after optimizeCmpInstr, since; // optimizeCmpInstr can enable folding by converting SUB to CMP.; // Save FoldAsLoadDefReg because optimizeLoadInstr() resets it and; // we need it for markUsesInDebugValueAsUndef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:30,Performance,optimiz,optimizeCmpInstr,30,"// We need to fold load after optimizeCmpInstr, since; // optimizeCmpInstr can enable folding by converting SUB to CMP.; // Save FoldAsLoadDefReg because optimizeLoadInstr() resets it and; // we need it for markUsesInDebugValueAsUndef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:58,Performance,optimiz,optimizeCmpInstr,58,"// We need to fold load after optimizeCmpInstr, since; // optimizeCmpInstr can enable folding by converting SUB to CMP.; // Save FoldAsLoadDefReg because optimizeLoadInstr() resets it and; // we need it for markUsesInDebugValueAsUndef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:154,Performance,optimiz,optimizeLoadInstr,154,"// We need to fold load after optimizeCmpInstr, since; // optimizeCmpInstr can enable folding by converting SUB to CMP.; // Save FoldAsLoadDefReg because optimizeLoadInstr() resets it and; // we need it for markUsesInDebugValueAsUndef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Deployability,Update,Update,3,// Update LocalMIs since we replaced MI with FoldMI and deleted; // DefMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Deployability,Update,Update,3,// Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:71,Performance,load,load,71,"// If we run into an instruction we can't fold across, discard; // the load candidates. Note: We might be able to fold *into* this; // instruction, so this needs to be after the folding logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:186,Testability,log,logic,186,"// If we run into an instruction we can't fold across, discard; // the load candidates. Note: We might be able to fold *into* this; // instruction, so this needs to be after the folding logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:56,Security,expose,expose,56,// Bail if there are effects that a plain copy will not expose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:621,Testability,assert,assertion,621,"// If we are composing subregs, bail out.; // The case we are checking is Def.<subreg> = REG_SEQUENCE.; // This should almost never happen as the SSA property is tracked at; // the register level (as opposed to the subreg level).; // I.e.,; // Def.sub0 =; // Def.sub1 =; // is a valid SSA representation for Def.sub0 and Def.sub1, but not for; // Def. Thus, it must not be generated.; // However, some code could theoretically generates a single; // Def.sub0 (i.e, not defining the other subregs) and we would; // have this case.; // If we can ascertain (or force) that this never happens, we could; // turn that into an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:127,Testability,assert,assert,127,"// If we are composing subreg, bail out.; // Same remark as getNextSourceFromRegSequence.; // I.e., this may be turned into an assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:161,Availability,avail,available,161,"// We are looking at:; // Def = INSERT_SUBREG v0, v1, sub1; // There are two cases:; // 1. DefSubReg == sub1, get v1.; // 2. DefSubReg != sub1, the value may be available through v0.; // #1 Check if the inserted register matches the required sub index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:31,Availability,avail,available,31,"// At this point, the value is available in v0 via the same subreg; // we used for Def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:27,Availability,avail,available,27,"// Otherwise, the value is available in the v0.sub0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Deployability,Update,Update,3,"// Update definition, definition index, and subregister for the; // next call of getNextSource.; // Update the current register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:100,Deployability,Update,Update,100,"// Update definition, definition index, and subregister for the; // next call of getNextSource.; // Update the current register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Deployability,Update,Update,3,// Update the result before moving up in the use-def chain; // with the instruction containing the last found sources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:60,Performance,perform,performance,60,/// Split critical edges where necessary for good coalescer performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:55,Deployability,update,update,55,// A set of live-in regs for each MBB which is used to update LV; // efficiently also with large functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:69,Energy Efficiency,efficient,efficiently,69,// A set of live-in regs for each MBB which is used to update LV; // efficiently also with large functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:47,Deployability,update,updater,47,// TODO: we should use the incremental DomTree updater here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:3,Deployability,Update,Update,3,// Update live variable information if there is any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:15,Modifiability,variab,variable,15,// Update live variable information if there is any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:26,Deployability,update,update,26,"// If the result is dead, update LV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals for the new copy or implicit def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:3,Deployability,Update,Update,3,// Update LiveVariables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:10,Safety,safe,safe,10,"// Find a safe location to insert the copy, this may be the first terminator; // in the block (or end()).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:19,Deployability,update,update,19,// We only need to update the LiveVariables kill of SrcReg if this was the; // last PHI use of SrcReg to be lowered on this CFG edge and it is not live; // out of the predecessor. We can also ignore undef sources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:150,Modifiability,variab,variable,150,"// We want to be able to insert a kill of the register if this PHI (aka,; // the copy we just inserted) is the last use of the source value. Live; // variable analysis conservatively handles this by saying that the value; // is live until the end of the block the PHI entry lives in. If the value; // really is dead at the PHI copy, there will be no successor blocks which; // have the value live-in.; // Okay, if we now know that the value is not live out of the block, we; // can add a kill marker in this block saying that it kills the incoming; // value!; // In our final twist, we have to decide which instruction kills the; // register. In most cases this is the copy, however, terminator; // instructions at the end of the block may also use the value. In this; // case, we should mark the last such terminator as being the killing; // block, not the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:3,Safety,Avoid,Avoid,3,// Avoid splitting backedges of loops. It would introduce small; // out-of-line blocks into the loop which is very bad for code placement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:238,Safety,risk,risk,238,"// LV doesn't consider a phi use live-out, so isLiveOut only returns true; // when the source register is live-out for some other reason than a phi; // use. That means the copy we will insert in PreMBB won't be a kill, and; // there is a risk it may not be coalesced away.; //; // If the copy would be a kill, there is no need to split the edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:108,Safety,avoid,avoid,108,"// If Reg is not live-in to MBB, it means it must be live-in to some; // other PreMBB successor, and we can avoid the interference by splitting; // the edge.; //; // If Reg *is* live-in to MBB, the interference is inevitable and a copy; // is likely to be left after coalescing. If we are looking at a loop; // exiting edge, split it so we won't insert code in the loop, otherwise; // don't bother.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.cpp:32,Safety,safe,safe,32,"// findCopyInsertPoint - Find a safe place in MBB to insert a copy from SrcReg; // when following the CFG edge to SuccMBB. This needs to be after any def of; // SrcReg, but before any subsequent point where control flow might jump out of; // the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.h:36,Safety,safe,safe,36,"/// findPHICopyInsertPoint - Find a safe place in MBB to insert a copy from; /// SrcReg when following the CFG edge to SuccMBB. This needs to be after; /// any def of SrcReg, but before any subsequent point where control flow; /// might jump out of the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:828,Availability,down,down,828,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1166,Availability,down,down,1166,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:550,Energy Efficiency,schedul,schedulers,550,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:750,Energy Efficiency,schedul,scheduling,750,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:804,Energy Efficiency,schedul,scheduler,804,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:833,Energy Efficiency,schedul,scheduler,833,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:872,Energy Efficiency,schedul,scheduling,872,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:994,Energy Efficiency,schedul,scheduler,994,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1075,Energy Efficiency,schedul,scheduling,1075,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1214,Energy Efficiency,schedul,scheduling,1214,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:40,Safety,hazard,hazard,40,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:409,Safety,hazard,hazard,409,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:500,Safety,hazard,hazard,500,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:638,Safety,hazard,hazard,638,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:717,Safety,hazard,hazards,717,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1047,Safety,hazard,hazards,1047,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1265,Safety,hazard,hazard,1265,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1323,Safety,hazard,hazards,1323,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:46,Safety,hazard,hazard,46,// Return if the target has not implemented a hazard recognizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:18,Safety,Hazard,HazardRec,18,// We do not call HazardRec->reset() here to make sure we are handling noop; // hazards at the start of basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:80,Safety,hazard,hazards,80,// We do not call HazardRec->reset() here to make sure we are handling noop; // hazards at the start of basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:405,Availability,down,down,405,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:501,Availability,avail,available,501,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:761,Deployability,pipeline,pipeline,761,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:11,Energy Efficiency,Schedul,SchedulePostRAList,11,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:41,Energy Efficiency,schedul,scheduler,41,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:415,Energy Efficiency,schedul,scheduler,415,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:520,Energy Efficiency,schedul,schedule,520,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:643,Energy Efficiency,schedul,schedule,643,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:709,Energy Efficiency,schedul,schedule,709,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:492,Performance,queue,queue,492,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:583,Performance,queue,queue,583,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:743,Safety,hazard,hazards,743,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:11,Energy Efficiency,schedul,scheduling,11,// Post-RA scheduling is enabled with; // TargetSubtargetInfo.enablePostRAScheduler(). This flag can be used to; // override the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:29,Energy Efficiency,schedul,schedule,29,// If DebugDiv > 0 then only schedule MBB with (ID % DebugDiv) == DebugMod,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Availability,Avail,AvailableQueue,4,/// AvailableQueue - The priority queue to use for the available SUnits.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:55,Availability,avail,available,55,/// AvailableQueue - The priority queue to use for the available SUnits.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:34,Performance,queue,queue,34,/// AvailableQueue - The priority queue to use for the available SUnits.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:201,Availability,avail,available,201,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands becomes available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:249,Availability,Avail,AvailableQueue,249,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands becomes available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:143,Performance,latency,latency,143,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands becomes available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Safety,Hazard,HazardRec,4,/// HazardRec - The hazard recognizer to use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:20,Safety,hazard,hazard,20,/// HazardRec - The hazard recognizer to use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:24,Integrability,depend,dependence,24,"/// AntiDepBreak - Anti-dependence breaking object, or NULL if none",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:8,Energy Efficiency,schedul,schedule,8,/// The schedule. Null SUnit*'s represent noop instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:58,Energy Efficiency,schedul,scheduling,58,/// startBlock - Initialize register live-range state for scheduling in; /// this block.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:19,Energy Efficiency,schedul,scheduler,19,/// Initialize the scheduler state for the next scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:48,Energy Efficiency,schedul,scheduling,48,/// Initialize the scheduler state for the next scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:20,Energy Efficiency,schedul,scheduler,20,/// Notify that the scheduler has finished scheduling the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:43,Energy Efficiency,schedul,scheduling,43,/// Notify that the scheduler has finished scheduling the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Energy Efficiency,Schedul,Schedule,4,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:15,Energy Efficiency,Schedul,Schedule,15,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:57,Energy Efficiency,schedul,scheduling,57,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:14,Deployability,Update,Update,14,"/// Observe - Update liveness information to account for the current; /// instruction, which will not be scheduled.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:105,Energy Efficiency,schedul,scheduled,105,"/// Observe - Update liveness information to account for the current; /// instruction, which will not be scheduled.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:15,Energy Efficiency,Schedul,ScheduleDAGMutation,15,/// Apply each ScheduleDAGMutation step in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:46,Energy Efficiency,schedul,scheduling,46,/// Initialize state associated with the next scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:14,Energy Efficiency,schedul,schedule,14,/// Print the schedule before exiting the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:28,Energy Efficiency,schedul,scheduled,28,/// dumpSchedule - dump the scheduled Sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:48,Energy Efficiency,schedul,scheduling,48,// Check for explicit enable/disable of post-ra scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:74,Deployability,upgrade,upgrade,74,// Check that post-RA scheduling is enabled for this target.; // This may upgrade the AntiDepMode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:22,Energy Efficiency,schedul,scheduling,22,// Check that post-RA scheduling is enabled for this target.; // This may upgrade the AntiDepMode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:29,Energy Efficiency,schedul,schedule,29,// If DebugDiv > 0 then only schedule MBB with (ID % DebugDiv) == DebugMod,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:44,Energy Efficiency,schedul,scheduling,44,// Initialize register live-range state for scheduling in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:121,Availability,down,down,121,// Schedule each sequence of instructions not interrupted by a label; // or anything else that effectively needs to shut down scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:3,Energy Efficiency,Schedul,Schedule,3,// Schedule each sequence of instructions not interrupted by a label; // or anything else that effectively needs to shut down scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:126,Energy Efficiency,schedul,scheduling,126,// Schedule each sequence of instructions not interrupted by a label; // or anything else that effectively needs to shut down scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:17,Energy Efficiency,schedul,scheduling,17,"// Calls are not scheduling boundaries before register allocation, but; // post-ra we don't gain anything by scheduling across calls since we; // don't need to worry about register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:109,Energy Efficiency,schedul,scheduling,109,"// Calls are not scheduling boundaries before register allocation, but; // post-ra we don't gain anything by scheduling across calls since we; // don't need to worry about register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:3,Deployability,Update,Update,3,// Update register kills,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:58,Energy Efficiency,schedul,scheduling,58,/// StartBlock - Initialize register live-range state for scheduling in; /// this block.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:13,Safety,hazard,hazard,13,// Reset the hazard recognizer and anti-dep breaker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Energy Efficiency,Schedul,Schedule,4,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:15,Energy Efficiency,Schedul,Schedule,15,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:57,Energy Efficiency,schedul,scheduling,57,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:13,Energy Efficiency,schedul,scheduling,13,// Build the scheduling graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:20,Deployability,Update,Update,20,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:76,Deployability,update,update,76,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:31,Integrability,depend,dependency,31,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:191,Integrability,depend,dependence,191,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:215,Integrability,depend,dependence,215,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:275,Integrability,depend,dependence,275,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:297,Integrability,depend,dependence,297,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:14,Deployability,Update,Update,14,"/// Observe - Update liveness information to account for the current; /// instruction, which will not be scheduled.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:105,Energy Efficiency,schedul,scheduled,105,"/// Observe - Update liveness information to account for the current; /// instruction, which will not be scheduled.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:15,Energy Efficiency,Schedul,ScheduleDAGMutation,15,/// Apply each ScheduleDAGMutation step in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:89,Availability,Down,Down,89,//===----------------------------------------------------------------------===//; // Top-Down Scheduling; //===----------------------------------------------------------------------===//; /// ReleaseSucc - Decrement the NumPredsLeft count of a successor. Add it to; /// the PendingQueue if the count reaches zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:192,Deployability,Release,ReleaseSucc,192,//===----------------------------------------------------------------------===//; // Top-Down Scheduling; //===----------------------------------------------------------------------===//; /// ReleaseSucc - Decrement the NumPredsLeft count of a successor. Add it to; /// the PendingQueue if the count reaches zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:94,Energy Efficiency,Schedul,Scheduling,94,//===----------------------------------------------------------------------===//; // Top-Down Scheduling; //===----------------------------------------------------------------------===//; /// ReleaseSucc - Decrement the NumPredsLeft count of a successor. Add it to; /// the PendingQueue if the count reaches zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:521,Availability,redundant,redundant,521,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:266,Deployability,update,updated,266,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:12,Energy Efficiency,schedul,scheduler,12,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:234,Energy Efficiency,Schedul,ScheduleNodeTopDown,234,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:655,Energy Efficiency,schedul,scheduled,655,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:695,Energy Efficiency,schedul,scheduled,695,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:521,Safety,redund,redundant,521,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Deployability,Release,ReleaseSuccessors,4,/// ReleaseSuccessors - Call ReleaseSucc on each of SU's successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:29,Deployability,Release,ReleaseSucc,29,/// ReleaseSuccessors - Call ReleaseSucc on each of SU's successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:165,Availability,Avail,Available,165,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Energy Efficiency,Schedul,ScheduleNodeTopDown,4,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:46,Energy Efficiency,schedul,schedule,46,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:175,Performance,queue,queue,175,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:67,Availability,down,down,67,/// ListScheduleTopDown - The main loop of list scheduling for top-down; /// schedulers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:48,Energy Efficiency,schedul,scheduling,48,/// ListScheduleTopDown - The main loop of list scheduling for top-down; /// schedulers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:77,Energy Efficiency,schedul,schedulers,77,/// ListScheduleTopDown - The main loop of list scheduling for top-down; /// schedulers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:24,Availability,down,down,24,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:9,Energy Efficiency,schedul,scheduling,9,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:105,Safety,hazard,hazards,105,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:156,Safety,hazard,hazards,156,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:3,Deployability,Release,Release,3,// Release any successors of the special Entry node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:21,Availability,Avail,Available,21,// Add all leaves to Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:31,Performance,queue,queue,31,// Add all leaves to Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:9,Availability,avail,available,9,// It is available if it has no predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:31,Energy Efficiency,schedul,schedule,31,"// In any cycle where we can't schedule any instructions, we must; // stall or emit a noop, depending on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:92,Integrability,depend,depending,92,"// In any cycle where we can't schedule any instructions, we must; // stall or emit a noop, depending on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:9,Availability,Avail,Available,9,"// While Available queue is not empty, grab the node with the highest; // priority. If it is not ready put it back. Schedule the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:116,Energy Efficiency,Schedul,Schedule,116,"// While Available queue is not empty, grab the node with the highest; // priority. If it is not ready put it back. Schedule the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:19,Performance,queue,queue,19,"// While Available queue is not empty, grab the node with the highest; // priority. If it is not ready put it back. Schedule the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:98,Availability,avail,available,98,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:108,Performance,queue,queue,108,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:217,Safety,hazard,hazard,217,"// If this is the first non-preferred node for this cycle, then; // record it and continue searching for a preferred node. If this; // is not the first non-preferred node, then treat it as though; // there had been a hazard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:30,Safety,hazard,hazard,30,// Remember if this is a noop hazard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:58,Availability,avail,available,58,"// If we have a non-preferred node, push it back onto the available list.; // If we did not find a preferred node, then schedule this first; // non-preferred node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:120,Energy Efficiency,schedul,schedule,120,"// If we have a non-preferred node, push it back onto the available list.; // If we did not find a preferred node, then schedule this first; // non-preferred node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:49,Availability,avail,available,49,// Add the nodes that aren't ready back onto the available list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:25,Energy Efficiency,schedul,schedule,25,// If we found a node to schedule...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:7,Energy Efficiency,schedul,schedule,7,// ... schedule the node...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:24,Deployability,pipeline,pipeline,24,"// Otherwise, we have a pipeline stall, but no other problem,; // just advance the current cycle and try again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:86,Availability,fault,fault,86,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:163,Deployability,pipeline,pipeline,163,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:172,Safety,interlock,interlocks,172,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:172,Security,interlock,interlocks,172,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:43,Energy Efficiency,schedul,scheduled,43,// EmitSchedule - Emit the machine code in scheduled order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:46,Energy Efficiency,schedul,schedule,46,// Then re-insert them according to the given schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:3,Deployability,Update,Update,3,"// Update the Begin iterator, as the first instruction in the block; // may have been scheduled later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:86,Energy Efficiency,schedul,scheduled,86,"// Update the Begin iterator, as the first instruction in the block; // may have been scheduled later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:473,Performance,load,load,473,"//===- PreISelIntrinsicLowering.cpp - Pre-ISel intrinsic lowering pass ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR lowering for the llvm.memcpy, llvm.memmove,; // llvm.memset, llvm.load.relative and llvm.objc.* intrinsics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:174,Availability,avail,availability,174,"/// If this is true, assume it's preferably to leave memory intrinsic calls; /// for replacement with a library call later. Otherwise this depends on; /// TargetLoweringInfo availability of the corresponding function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:139,Integrability,depend,depends,139,"/// If this is true, assume it's preferably to leave memory intrinsic calls; /// for replacement with a library call later. Otherwise this depends on; /// TargetLoweringInfo availability of the corresponding function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:75,Performance,perform,performance,75,"// If we have Native ARC, set nonlazybind attribute for these APIs for; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:232,Deployability,upgrade,upgraded,232,"// Transfer the 'returned' attribute from the intrinsic to the call site.; // By applying this only to intrinsic call sites, we avoid applying it to; // non-ARC explicit calls to things like objc_retain which have not been; // auto-upgraded to use the intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:128,Safety,avoid,avoid,128,"// Transfer the 'returned' attribute from the intrinsic to the call site.; // By applying this only to intrinsic call sites, we avoid applying it to; // non-ARC explicit calls to things like objc_retain which have not been; // auto-upgraded to use the intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:52,Security,access,accesses,52,// TODO: Should refine based on estimated number of accesses (e.g. does it; // require splitting based on alignment),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ProcessImplicitDefs.cpp:3,Energy Efficiency,Drain,Drain,3,// Drain the WorkList to recursively process any new implicit defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ProcessImplicitDefs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ProcessImplicitDefs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:82,Usability,simpl,simply,82,// Frame indices in debug values are encoded in a target independent; // way with simply the frame index and offset rather than any; // target-specific addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:51,Modifiability,variab,variables,51,// Calculate the MaxCallFrameSize and AdjustsStack variables for the; // function's frame information. Also eliminates call frame pseudo; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:129,Modifiability,variab,variables,129,"// Add prolog and epilog code to the function. This function is required; // to align the stack frame as necessary for any stack variables or; // called functions. Because of this, calculateCalleeSavedRegisters(); // must be called before this function in order to set the AdjustsStack; // and MaxCallFrameSize variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:311,Modifiability,variab,variables,311,"// Add prolog and epilog code to the function. This function is required; // to align the stack frame as necessary for any stack variables or; // called functions. Because of this, calculateCalleeSavedRegisters(); // must be called before this function in order to set the AdjustsStack; // and MaxCallFrameSize variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:57,Modifiability,variab,variables,57,/// Calculate the MaxCallFrameSize and AdjustsStack; /// variables for the function's frame information and eliminate call frame; /// pseudo instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:47,Availability,down,down,47,// Get the function call frame set-up and tear-down instruction opcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:183,Integrability,wrap,wrapping,183,"// Even when we do not change any CSR, we still want to insert the; // prologue and epilogue of the function.; // So set the save points for those.; // Use the points found by shrink-wrapping, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:67,Energy Efficiency,allocate,allocate,67,"// Now that we know which registers need to be saved and restored, allocate; // stack slots for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:85,Energy Efficiency,allocate,allocate,85,"// If the target has spilled this register to another register, we don't; // need to allocate a stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:23,Deployability,update,update,23,/// Helper function to update the liveness information for the callee-saved; /// registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:109,Availability,alive,alive,109,"// Visited will contain all the basic blocks that are in the region; // where the callee saved registers are alive:; // - Anything that is not Save or Restore -> LiveThrough.; // - Save -> LiveIn.; // - Restore -> LiveOut.; // The live-out is not attached to the block, so no need to keep; // Restore in this set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:28,Performance,load,loadRegFromStackSlot,28,// Insert in reverse order. loadRegFromStackSlot can insert; // multiple instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:154,Deployability,pipeline,pipeline,154,"// We can't list this requirement in getRequiredProperties because some; // targets (WebAssembly) use virtual registers past this point, and the pass; // pipeline is set up without giving the passes a chance to look at the; // TargetMachine.; // FIXME: Find a way to express this in getRequiredProperties.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Deployability,Update,Update,3,// Update the live-in information of all the blocks up to the save point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:22,Availability,down,down,22,"// If the stack grows down, add the object size to find the lowest address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Safety,Avoid,Avoid,3,// Avoid undefined int64_t -> int conversion below in extreme case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Usability,clear,clear,3,// clear it to speed up later scavengeStackSlot calls to; // StackBytesFree.none(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:108,Energy Efficiency,allocate,allocated,108,"// If there are fixed sized objects that are preallocated in the local area,; // non-fixed objects can't be allocated right at the start of local area.; // Adjust 'Offset' to point to the end of last fixed sized preallocated; // object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:8,Energy Efficiency,allocate,allocate,8,// Only allocate objects on the default stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:118,Availability,down,down,118,"// The maximum distance from the stack pointer is at lower address of; // the object -- which is given by offset. For down growing stack; // the offset is negative, so we negate the offset to get the distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:8,Energy Efficiency,allocate,allocate,8,// Only allocate objects on the default stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:208,Performance,optimiz,optimization,208,"// FIXME: Once this is working, then enable flag will change to a target; // check for whether the frame is large enough to want to use virtual; // frame index registers. Functions which don't want/need this optimization; // will continue to use the existing code path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the local block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:61,Modifiability,variab,variables,61,// Make sure that the stack protector comes before the local variables on the; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:97,Energy Efficiency,allocate,allocate,97,"// If we need a stack protector, we need to make sure that; // LocalStackSlotPass didn't already allocate a slot for it.; // If we are told to use the LocalStackAllocationBlock, the stack protector; // is expected to be already pre-allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:232,Energy Efficiency,allocate,allocated,232,"// If we need a stack protector, we need to make sure that; // LocalStackSlotPass didn't already allocate a slot for it.; // If we are told to use the LocalStackAllocationBlock, the stack protector; // is expected to be already pre-allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:8,Energy Efficiency,allocate,allocate,8,// Only allocate objects on the default stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:59,Energy Efficiency,allocate,allocated,59,"// We expect **all** the protected stack objects to be pre-allocated by; // LocalStackSlotPass. If it turns out that PEI still has to allocate some; // of them, we may end up messing up the expected order of the objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:134,Energy Efficiency,allocate,allocate,134,"// We expect **all** the protected stack objects to be pre-allocated by; // LocalStackSlotPass. If it turns out that PEI still has to allocate some; // of them, we may end up messing up the expected order of the objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:8,Energy Efficiency,allocate,allocate,8,// Only allocate objects on the default stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:35,Energy Efficiency,allocate,allocate,35,// Add the objects that we need to allocate to our working set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the EH registration node first if one is present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:232,Performance,optimiz,optimizing,232,// Keep track of which bytes in the fixed and callee-save range are used so we; // can use the holes when allocating later stack objects. Only do this if; // stack protector isn't being used and the target requests it and we're; // optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Deployability,Update,Update,3,// Update frame info to pretend that this is part of the stack...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:113,Performance,load,loaded,113,"// Emit additional code that is required to explicitly handle the stack in; // HiPE native code (if needed) when loaded in the Erlang/OTP runtime. The; // approach is rather similar to that of Segmented Stacks, but it uses a; // different conditional check and another BIF for allocating more stack; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:9,Usability,clear,clear,9,// Don't clear registers that are live when leaving the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:17,Usability,clear,clear,17,// Don't need to clear registers that are used/clobbered by terminating; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:9,Usability,clear,clear,9,// Don't clear registers that must be preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:236,Modifiability,variab,variable,236,"// If we have a direct DBG_VALUE, and its location expression isn't; // currently complex, then adding an offset will morph it into a; // complex location that is interpreted as being a memory address.; // This changes a pointer-valued variable to dereference that pointer,; // which is incorrect. Fix by adding DW_OP_stack_value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:60,Deployability,PATCH,PATCHPOINT,60,// TODO: This code should be commoned with the code for; // PATCHPOINT. There's no good reason for the difference in; // implementation other than historical accident. The only; // remaining difference is the unconditional use of the stack; // pointer as the base register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:256,Deployability,update,update,256,// Some instructions (e.g. inline asm instructions) can have; // multiple frame indices and/or cause eliminateFrameIndex; // to insert more than one instruction. We need the register; // scavenger to go through all of these instructions so that; // it can update its register information. We keep the; // iterator at the point before insertion so that we can; // revisit them in full.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PseudoProbeInserter.cpp:340,Testability,log,logically,340,"// Walk the block backwards, move PSEUDO_PROBE before the first real; // instruction to fix out-of-order probes. There is a problem with probes; // as the terminator of the block. During the offline counts processing,; // the samples collected on the first physical instruction following a; // probe will be counted towards the probe. This logically equals to; // treating the instruction next to a probe as if it is from the same; // block of the probe. This is accurate most of the time unless the; // instruction can be reached from multiple flows, which means it actually; // starts a new block. Samples collected on such probes may cause; // imprecision with the counts inference algorithm. Fortunately, if; // there are still other native instructions preceding the probe we can; // use them as a place holder to collect samples for the probe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PseudoProbeInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PseudoProbeInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:89,Energy Efficiency,allocate,allocates,89,"// Node allocation functions.; //; // Node allocator is like a slab memory allocator: it allocates blocks of; // memory in sizes that are multiples of the size of a node. Each block has; // the same size. Nodes are allocated from the currently active block, and; // when it becomes full, a new one is created.; // There is a mapping scheme between node id and its location in a block,; // and within that block is described in the header file.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:215,Energy Efficiency,allocate,allocated,215,"// Node allocation functions.; //; // Node allocator is like a slab memory allocator: it allocates blocks of; // memory in sizes that are multiples of the size of a node. Each block has; // the same size. Nodes are allocated from the currently active block, and; // when it becomes full, a new one is created.; // There is a mapping scheme between node id and its location in a block,; // and within that block is described in the header file.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:55,Deployability,update,update,55,"// If the member to remove happens to be the last one, update the; // LastM indicator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:27,Availability,down,down,27,// Move the stack iterator down by one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new node and set the attributes to Attrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:14,Integrability,rout,routines,14,// Allocation routines for specific node types/kinds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:16,Modifiability,Config,Config,16,// Track set in Config overrides everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Testability,Assert,Assert,3,// Assert if the register is defined in two or more unrelated defs.; // This could happen if there are two or more def operands defining it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Usability,Clear,Clear,3,// Clear all information in the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:187,Security,access,access,187,"// Return the next reference node in the instruction node IA that is related; // to RA. Conceptually, two reference nodes are related if they refer to the; // same instance of a register access, but differ in flags or other minor; // characteristics. Specific examples of related nodes are shadow reference; // nodes.; // Return the equivalent of nullptr if there are no more related references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Safety,Avoid,Avoid,3,"// Avoid duplicate implicit defs. This will not detect cases of implicit; // defs that define registers that overlap, but it is not clear how to; // interpret that in the absence of explicit defs. Overlapping explicit; // defs are likely illegal already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:48,Safety,detect,detect,48,"// Avoid duplicate implicit defs. This will not detect cases of implicit; // defs that define registers that overlap, but it is not clear how to; // interpret that in the absence of explicit defs. Overlapping explicit; // defs are likely illegal already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:132,Usability,clear,clear,132,"// Avoid duplicate implicit defs. This will not detect cases of implicit; // defs that define registers that overlap, but it is not clear how to; // interpret that in the absence of explicit defs. Overlapping explicit; // defs are likely illegal already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:15,Availability,mask,masks,15,// Process reg-masks (as clobbers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:115,Safety,detect,detect,115,"// This will remove unused phis, i.e. phis where each def does not reach; // any uses or other defs. This will not detect or remove circular phi; // chains that are otherwise dead. Unused/dead phis are created during; // the build process and this function is intended to remove these cases; // that are easily determinable to be unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:163,Performance,queue,queue,163,"// Any phi, if it is removed, may affect other phis (make them dead).; // For each removed phi, collect the potentially affected phis and add; // them back to the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Deployability,Update,Update,3,// Update the reaching def node and remove DA from the sibling list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:40,Deployability,update,update,40,"// If DA is the first reached def, just update the RD's reached def; // to the DA's sibling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:808,Energy Efficiency,Efficient,Efficient,808,"//===- RDFLiveness.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Computation of the liveness information from the data-flow graph.; //; // The main functionality of this code is to compute block live-in; // information. With the live-in information in place, the placement; // of kill flags can also be recalculated.; //; // The block live-in calculation is based on the ideas from the following; // publication:; //; // Dibyendu Das, Ramakrishna Upadrasta, Benoit Dupont de Dinechin.; // ""Efficient Liveness Computation Using Merge Sets and DJ-Graphs.""; // ACM Transactions on Architecture and Code Optimization, Association for; // Computing Machinery, 2012, ACM TACO Special Issue on ""High-Performance; // and Embedded Architectures and Compilers"", 8 (4),; // <10.1145/2086696.2086706>. <hal-00647369>; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:918,Performance,Optimiz,Optimization,918,"//===- RDFLiveness.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Computation of the liveness information from the data-flow graph.; //; // The main functionality of this code is to compute block live-in; // information. With the live-in information in place, the placement; // of kill flags can also be recalculated.; //; // The block live-in calculation is based on the ideas from the following; // publication:; //; // Dibyendu Das, Ramakrishna Upadrasta, Benoit Dupont de Dinechin.; // ""Efficient Liveness Computation Using Merge Sets and DJ-Graphs.""; // ACM Transactions on Architecture and Code Optimization, Association for; // Computing Machinery, 2012, ACM TACO Special Issue on ""High-Performance; // and Embedded Architectures and Compilers"", 8 (4),; // <10.1145/2086696.2086706>. <hal-00647369>; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:1011,Performance,Perform,Performance,1011,"//===- RDFLiveness.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Computation of the liveness information from the data-flow graph.; //; // The main functionality of this code is to compute block live-in; // information. With the live-in information in place, the placement; // of kill flags can also be recalculated.; //; // The block live-in calculation is based on the ideas from the following; // publication:; //; // Dibyendu Das, Ramakrishna Upadrasta, Benoit Dupont de Dinechin.; // ""Efficient Liveness Computation Using Merge Sets and DJ-Graphs.""; // ACM Transactions on Architecture and Code Optimization, Association for; // Computing Machinery, 2012, ACM TACO Special Issue on ""High-Performance; // and Embedded Architectures and Compilers"", 8 (4),; // <10.1145/2086696.2086706>. <hal-00647369>; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:15,Performance,queue,queue,15,// The initial queue should not have reaching defs for shadows. The; // whole point of a shadow is that it will have a reaching def that; // is not aliased to the reaching defs of the related shadows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:188,Security,expose,expose,188,"// Add phi defs even if they are covered by subsequent defs. This is; // for cases where the reached use is not covered by any of the defs; // encountered so far: the phi def is needed to expose the liveness; // of that use to the entry of the block.; // Example:; // phi d1<R3>(,d2,), ... Phi def d1 is covered by d2.; // d2<R3>(d1,,u3), ...; // ..., u3<D1>(d2) This use needs to be live on entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:37,Deployability,update,update,37,"// If it is a preserving def, do not update the set of intervening defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:15,Performance,queue,queue,15,"// Have a work queue of defs whose reached uses need to be found.; // For each def, add to the queue all reached (non-phi) defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:95,Performance,queue,queue,95,"// Have a work queue of defs whose reached uses need to be found.; // For each def, add to the queue all reached (non-phi) defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:47,Performance,queue,queue,47,"// Visit all reached defs, and add them to the queue. These defs may; // override some of the uses collected here, but that will be handled; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:17,Security,expose,exposed,17,// Calculate the exposed part of the reached use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:55,Performance,queue,queue,55,"// If this phi reaches some ""real"" uses, add it to the queue for upward; // propagation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:923,Performance,cache,cache,923,"// Propagate the reached registers up in the phi chain.; //; // The following type of situation needs careful handling:; //; // phi d1<R1:0> (1); // |; // ... d2<R1>; // |; // phi u3<R1:0> (2); // |; // ... u4<R1>; //; // The phi node (2) defines a register pair R1:0, and reaches a ""real""; // use u4 of just R1. The same phi node is also known to reach (upwards); // the phi node (1). However, the use u4 is not reached by phi (1),; // because of the intervening definition d2 of R1. The data flow between; // phis (1) and (2) is restricted to R1:0 minus R1, i.e. R0.; //; // When propagating uses up the phi chains, get the all reaching defs; // for a given phi use, and traverse the list until the propagated ref; // is covered, or until reaching the final phi. Only assume that the; // reference reaches the phi in the latter case.; // The operation ""clearIn"" can be expensive. For a given set of intervening; // defs, cache the result of subtracting these defs from a given register; // ref.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:855,Usability,clear,clearIn,855,"// Propagate the reached registers up in the phi chain.; //; // The following type of situation needs careful handling:; //; // phi d1<R1:0> (1); // |; // ... d2<R1>; // |; // phi u3<R1:0> (2); // |; // ... u4<R1>; //; // The phi node (2) defines a register pair R1:0, and reaches a ""real""; // use u4 of just R1. The same phi node is also known to reach (upwards); // the phi node (1). However, the use u4 is not reached by phi (1),; // because of the intervening definition d2 of R1. The data flow between; // phis (1) and (2) is restricted to R1:0 minus R1, i.e. R0.; //; // When propagating uses up the phi chains, get the all reaching defs; // for a given phi use, and traverse the list until the propagated ref; // is covered, or until reaching the final phi. Only assume that the; // reference reaches the phi in the latter case.; // The operation ""clearIn"" can be expensive. For a given set of intervening; // defs, cache the result of subtracting these defs from a given register; // ref.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:17,Availability,mask,mask,17,// Calculate the mask corresponding to the visited def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:238,Security,expose,exposed,238,"// The LiveIn map at this point has all defs that are live-on-exit from B,; // as if they were live-on-entry to B. First, we need to filter out all; // defs that are present in this block. Then we will add reaching defs of; // all upward-exposed uses.; // To filter out the defs, first make a copy of LiveIn, and then re-populate; // LiveIn with the defs that should remain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:207,Security,expose,exposed,207,"// DA is a non-phi def that is live-on-exit from this block, and; // that is also located in this block. LRef is a register ref; // whose use this def reaches. If DA covers LRef, then no part; // of LRef is exposed upwards.A",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:29,Security,expose,exposed,29,// Scan the block for upward-exposed uses and add them to the tracking set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFRegisters.cpp:92,Availability,mask,masks,92,"// If there is at least one register remaining, pick the first one,; // and consolidate the masks of all of its units contained in this; // aggregate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFRegisters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFRegisters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:17,Usability,clear,clearances,17,// Save register clearances at end of MBB - used by enterBasicBlock().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:178,Usability,clear,clearance,178,"// While processing the basic block, we kept `Def` relative to the start; // of the basic block for convenience. However, future use of this information; // only cares about the clearance from the end of the block, so adjust; // everything to be relative to the end of the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:3,Deployability,Update,Update,3,// Update existing reaching def from predecessor to a more recent one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:3,Deployability,Update,Update,3,// Update reaching def at end of BB. Keep in mind that these are; // adjusted relative to the end of the basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:3,Usability,Clear,Clear,3,// Clear the internal vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:10,Safety,safe,safely,10,"// Can we safely move 'From' to just before 'To'? To satisfy this, 'From' must; // not define a register that is used by any instructions, after and including,; // 'To'. These instructions also must not redefine any of Froms operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:183,Performance,queue,queue,183,"// Visit all the live registers. If they are already assigned to a physical; // register, unify them with the corresponding LiveIntervalUnion, otherwise push; // them on the priority queue for later assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:34,Performance,queue,queue,34,// Top-level driver to manage the queue of unassigned VirtRegs and call the; // selectOrSplit implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:45,Availability,avail,available,45,// Continue assigning vregs one at a time to available physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:53,Availability,avail,available,53,// selectOrSplit requests the allocator to return an available physical; // register if possible and populate a list of new live intervals that; // result from splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:34,Availability,error,error,34,// Keep going after reporting the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:39,Integrability,interface,interface,39,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:496,Integrability,interface,interface,496,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:510,Modifiability,extend,extending,510,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:834,Performance,cache,cached,834,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:914,Performance,perform,performance,914,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:616,Testability,test,test,616,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:61,Integrability,interface,interface,61,/// RegAllocBase provides the register allocation driver and interface that can; /// be extended to add interesting heuristics.; ///; /// Register allocators must override the selectOrSplit() method to implement; /// live range splitting. They must also override enqueue/dequeue to provide an; /// assignment order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:88,Modifiability,extend,extended,88,/// RegAllocBase provides the register allocation driver and interface that can; /// be extended to add interesting heuristics.; ///; /// Register allocators must override the selectOrSplit() method to implement; /// live range splitting. They must also override enqueue/dequeue to provide an; /// assignment order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:232,Availability,avail,available,232,"/// Inst which is a def of an original reg and whose defs are already all; /// dead after remat is saved in DeadRemats. The deletion of such inst is; /// postponed till all the allocations are done, so its remat expr is; /// always available for the remat of all the siblings of the original reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:43,Energy Efficiency,allocate,allocatePhysRegs,43,// A RegAlloc pass should call this before allocatePhysRegs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:60,Deployability,update,updated,60,// The top-level driver. The output is a VirtRegMap that us updated with; // physical register assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:24,Performance,optimiz,optimization,24,// Include spiller post optimization and removing dead defs left because of; // rematerialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:42,Performance,queue,queue,42,/// enqueue - Add VirtReg to the priority queue of unassigned registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:42,Performance,queue,queue,42,/// enqueue - Add VirtReg to the priority queue of unassigned registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:139,Availability,avail,available,139,// A RegAlloc pass should override this to provide the allocation heuristics.; // Each call must guarantee forward progess by returning an available PhysReg; // or new set of split live virtual registers. It is up to the splitter to; // converge quickly toward fully spilled live ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:18,Energy Efficiency,Allocate,Allocated,18,// Scratch space. Allocated here to avoid repeated malloc calls in; // selectOrSplit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:36,Safety,avoid,avoid,36,// Scratch space. Allocated here to avoid repeated malloc calls in; // selectOrSplit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:4,Performance,Perform,Perform,4,/// Perform register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:50,Performance,queue,queue,50,"// Unassigned virtreg is probably in the priority queue.; // RegAllocBase will erase it after dequeueing.; // Nonetheless, clear the live-range so that the debug; // dump will show the right state for that VirtReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:123,Usability,clear,clear,123,"// Unassigned virtreg is probably in the priority queue.; // RegAllocBase will erase it after dequeueing.; // Nonetheless, clear the live-range so that the debug; // dump will show the right state for that VirtReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:44,Performance,queue,queue,44,"// Register is assigned, put it back on the queue for reassignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:31,Energy Efficiency,allocate,allocated,31,// Spill each interfering vreg allocated to PhysReg or an alias.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:415,Availability,avail,available,415,"// Driver for the register assignment and splitting heuristics.; // Manages iteration over the LiveIntervalUnions.; //; // This is a minimal implementation of register assignment and splitting that; // spills whenever we run out of registers.; //; // selectOrSplit can only be called once per live virtual register. We then do a; // single interference test for each register the correct class until we find an; // available register. So, the number of interference tests in the worst case is; // |vregs| * |machineregs|. And since the number of interference tests is; // minimal, there is no value in caching them outside the scope of; // selectOrSplit().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:353,Testability,test,test,353,"// Driver for the register assignment and splitting heuristics.; // Manages iteration over the LiveIntervalUnions.; //; // This is a minimal implementation of register assignment and splitting that; // spills whenever we run out of registers.; //; // selectOrSplit can only be called once per live virtual register. We then do a; // single interference test for each register the correct class until we find an; // available register. So, the number of interference tests in the worst case is; // |vregs| * |machineregs|. And since the number of interference tests is; // minimal, there is no value in caching them outside the scope of; // selectOrSplit().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:466,Testability,test,tests,466,"// Driver for the register assignment and splitting heuristics.; // Manages iteration over the LiveIntervalUnions.; //; // This is a minimal implementation of register assignment and splitting that; // spills whenever we run out of registers.; //; // selectOrSplit can only be called once per live virtual register. We then do a; // single interference test for each register the correct class until we find an; // available register. So, the number of interference tests in the worst case is; // |vregs| * |machineregs|. And since the number of interference tests is; // minimal, there is no value in caching them outside the scope of; // selectOrSplit().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:559,Testability,test,tests,559,"// Driver for the register assignment and splitting heuristics.; // Manages iteration over the LiveIntervalUnions.; //; // This is a minimal implementation of register assignment and splitting that; // spills whenever we run out of registers.; //; // selectOrSplit can only be called once per live virtual register. We then do a; // single interference test for each register the correct class until we find an; // available register. So, the number of interference tests in the worst case is; // |vregs| * |machineregs|. And since the number of interference tests is; // minimal, there is no value in caching them outside the scope of; // selectOrSplit().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:16,Availability,avail,available,16,// Check for an available register in this class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:14,Availability,avail,available,14,"// PhysReg is available, allocate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:25,Energy Efficiency,allocate,allocate,25,"// PhysReg is available, allocate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:22,Energy Efficiency,allocate,allocate,22,// Tell the caller to allocate to this newly freed physical register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:94,Energy Efficiency,allocate,allocate,94,"// The live virtual register requesting allocation was spilled, so tell; // the caller not to allocate anything during this round.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:366,Deployability,update,update,366,/// canEvictInterferenceBasedOnCost - Return true if all interferences between; /// VirtReg and PhysReg can be evicted.; ///; /// @param VirtReg Live range that is about to be assigned.; /// @param PhysReg Desired register for assignment.; /// @param IsHint True when PhysReg is VirtReg's preferred register.; /// @param MaxCost Only look for cheaper candidates and update with new cost; /// when returning true.; /// @returns True when interference can be evicted cheaper than MaxCost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:3,Deployability,Update,Update,3,// Update eviction cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:3,Safety,Abort,Abort,3,// Abort if this would be too expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:34,Energy Efficiency,reduce,reduced,34,"// When we are just looking for a reduced cost per use, don't break any; // hints, and only evict smaller spill weights.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:60,Energy Efficiency,allocate,allocate,60,"// Live ranges pass through a number of stages as we try to allocate them.; // Some of the stages may also create new live ranges:; //; // - Region splitting.; // - Per-block splitting.; // - Local splitting.; // - Spilling.; //; // Ranges produced by one of the stages skip the previous stages when they are; // dequeued. This improves performance because we can skip interference checks; // that are unlikely to give any results. It also guarantees that the live; // range splitting algorithm terminates, something that is otherwise hard to; // ensure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:337,Performance,perform,performance,337,"// Live ranges pass through a number of stages as we try to allocate them.; // Some of the stages may also create new live ranges:; //; // - Region splitting.; // - Per-block splitting.; // - Local splitting.; // - Spilling.; //; // Ranges produced by one of the stages skip the previous stages when they are; // dequeued. This improves performance because we can skip interference checks; // that are unlikely to give any results. It also guarantees that the live; // range splitting algorithm terminates, something that is otherwise hard to; // ensure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:49,Performance,queue,queued,49,/// Newly created live range that has never been queued.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:56,Safety,Abort,Abort,56,/// There is nothing more we can do to this live range. Abort compilation; /// if it can't be assigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:243,Modifiability,refactor,refactored,243,"/// Cost of evicting interference - used by default advisor, and the eviction; /// chain heuristic in RegAllocGreedy.; // FIXME: this can be probably made an implementation detail of the default; // advisor, if the eviction chain logic can be refactored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:230,Testability,log,logic,230,"/// Cost of evicting interference - used by default advisor, and the eviction; /// chain heuristic in RegAllocGreedy.; // FIXME: this can be probably made an implementation detail of the default; // advisor, if the eviction chain logic can be refactored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:4,Integrability,Interface,Interface,4,"/// Interface to the eviction advisor, which is responsible for making a; /// decision as to which live ranges should be evicted (if any).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:121,Usability,learn,learning,121,"// Get the upper limit of elements in the given Order we need to analize.; // TODO: is this heuristic, we could consider learning it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:37,Energy Efficiency,allocate,allocate,37,"// Determine if it's worth trying to allocate this reg, given the; // CostPerUseLimit; // TODO: this is a heuristic component we could consider learning, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:144,Usability,learn,learning,144,"// Determine if it's worth trying to allocate this reg, given the; // CostPerUseLimit; // TODO: this is a heuristic component we could consider learning, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:162,Integrability,depend,dependencies,162,"/// ImmutableAnalysis abstraction for fetching the Eviction Advisor. We model it; /// as an analysis to decouple the user from the implementation insofar as; /// dependencies on other analyses goes. The motivation for it being an; /// immutable pass is twofold:; /// - in the ML implementation case, the evaluator is stateless but (especially; /// in the development mode) expensive to set up. With an immutable pass, we set; /// it up once.; /// - in the 'development' mode ML case, we want to capture the training log; /// during allocation (this is a log of features encountered and decisions; /// made), and then measure a score, potentially a few steps after allocation; /// completes. So we need the properties of an immutable pass to keep the logger; /// state around until we can make that measurement.; ///; /// Because we need to offer additional services in 'development' mode, the; /// implementations of this analysis need to implement RTTI support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:516,Testability,log,log,516,"/// ImmutableAnalysis abstraction for fetching the Eviction Advisor. We model it; /// as an analysis to decouple the user from the implementation insofar as; /// dependencies on other analyses goes. The motivation for it being an; /// immutable pass is twofold:; /// - in the ML implementation case, the evaluator is stateless but (especially; /// in the development mode) expensive to set up. With an immutable pass, we set; /// it up once.; /// - in the 'development' mode ML case, we want to capture the training log; /// during allocation (this is a log of features encountered and decisions; /// made), and then measure a score, potentially a few steps after allocation; /// completes. So we need the properties of an immutable pass to keep the logger; /// state around until we can make that measurement.; ///; /// Because we need to offer additional services in 'development' mode, the; /// implementations of this analysis need to implement RTTI support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:554,Testability,log,log,554,"/// ImmutableAnalysis abstraction for fetching the Eviction Advisor. We model it; /// as an analysis to decouple the user from the implementation insofar as; /// dependencies on other analyses goes. The motivation for it being an; /// immutable pass is twofold:; /// - in the ML implementation case, the evaluator is stateless but (especially; /// in the development mode) expensive to set up. With an immutable pass, we set; /// it up once.; /// - in the 'development' mode ML case, we want to capture the training log; /// during allocation (this is a log of features encountered and decisions; /// made), and then measure a score, potentially a few steps after allocation; /// completes. So we need the properties of an immutable pass to keep the logger; /// state around until we can make that measurement.; ///; /// Because we need to offer additional services in 'development' mode, the; /// implementations of this analysis need to implement RTTI support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:750,Testability,log,logger,750,"/// ImmutableAnalysis abstraction for fetching the Eviction Advisor. We model it; /// as an analysis to decouple the user from the implementation insofar as; /// dependencies on other analyses goes. The motivation for it being an; /// immutable pass is twofold:; /// - in the ML implementation case, the evaluator is stateless but (especially; /// in the development mode) expensive to set up. With an immutable pass, we set; /// it up once.; /// - in the 'development' mode ML case, we want to capture the training log; /// during allocation (this is a log of features encountered and decisions; /// made), and then measure a score, potentially a few steps after allocation; /// completes. So we need the properties of an immutable pass to keep the logger; /// state around until we can make that measurement.; ///; /// Because we need to offer additional services in 'development' mode, the; /// implementations of this analysis need to implement RTTI support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:414,Energy Efficiency,allocate,allocates,414,"//===- RegAllocFast.cpp - A fast register allocator for debug code --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This register allocator allocates registers to a basic block at a; /// time, attempting to keep values in registers and reusing registers as; /// appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:38,Testability,test,testcases,38,// FIXME: Remove this switch when all testcases are fixed!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:87,Availability,avail,available,87,"// We want index gap between two adjacent MI is as same as possible. Given; // total A available indexes, D is number of consecutive unassigned; // instructions, S is the step.; // |<- S-1 -> MI <- S-1 -> MI <- A-S*D ->|; // There're S-1 available indexes between unassigned instruction and its; // predecessor. There're A-S*D available indexes between the last; // unassigned instruction and its successor.; // Ideally, we want; // S-1 = A-S*D; // then; // S = (A+1)/(D+1); // An valid S must be integer greater than zero, so; // S <= (A+1)/(D+1); // =>; // A-S*D >= 0; // That means we can safely use (A+1)/(D+1) as step.; // In previous example, Step is 204, Index of B, C, MI, D is 1228, 1432,; // 1636, 1840.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:238,Availability,avail,available,238,"// We want index gap between two adjacent MI is as same as possible. Given; // total A available indexes, D is number of consecutive unassigned; // instructions, S is the step.; // |<- S-1 -> MI <- S-1 -> MI <- A-S*D ->|; // There're S-1 available indexes between unassigned instruction and its; // predecessor. There're A-S*D available indexes between the last; // unassigned instruction and its successor.; // Ideally, we want; // S-1 = A-S*D; // then; // S = (A+1)/(D+1); // An valid S must be integer greater than zero, so; // S <= (A+1)/(D+1); // =>; // A-S*D >= 0; // That means we can safely use (A+1)/(D+1) as step.; // In previous example, Step is 204, Index of B, C, MI, D is 1228, 1432,; // 1636, 1840.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:327,Availability,avail,available,327,"// We want index gap between two adjacent MI is as same as possible. Given; // total A available indexes, D is number of consecutive unassigned; // instructions, S is the step.; // |<- S-1 -> MI <- S-1 -> MI <- A-S*D ->|; // There're S-1 available indexes between unassigned instruction and its; // predecessor. There're A-S*D available indexes between the last; // unassigned instruction and its successor.; // Ideally, we want; // S-1 = A-S*D; // then; // S = (A+1)/(D+1); // An valid S must be integer greater than zero, so; // S <= (A+1)/(D+1); // =>; // A-S*D >= 0; // That means we can safely use (A+1)/(D+1) as step.; // In previous example, Step is 204, Index of B, C, MI, D is 1228, 1432,; // 1636, 1840.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:592,Safety,safe,safely,592,"// We want index gap between two adjacent MI is as same as possible. Given; // total A available indexes, D is number of consecutive unassigned; // instructions, S is the step.; // |<- S-1 -> MI <- S-1 -> MI <- A-S*D ->|; // There're S-1 available indexes between unassigned instruction and its; // predecessor. There're A-S*D available indexes between the last; // unassigned instruction and its successor.; // Ideally, we want; // S-1 = A-S*D; // then; // S = (A+1)/(D+1); // An valid S must be integer greater than zero, so; // S <= (A+1)/(D+1); // =>; // A-S*D >= 0; // That means we can safely use (A+1)/(D+1) as step.; // In previous example, Step is 204, Index of B, C, MI, D is 1228, 1432,; // 1636, 1840.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:32,Energy Efficiency,allocate,allocated,32,/// Basic block currently being allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:15,Energy Efficiency,allocate,allocate,15,///< Could not allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:79,Availability,avail,available,79,/// This map contains entries for each virtual register that is currently; /// available in a physical register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:89,Availability,alive,alive,89,/// Has a bit set for every virtual register for which it was determined; /// that it is alive across blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:55,Energy Efficiency,allocate,allocated,55,/// A free register is not currently in use and can be allocated; /// immediately without checking aliases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:116,Energy Efficiency,allocate,allocated,116,"/// A register state may also be a virtual register number, indication; /// that the physical register is currently allocated to a virtual; /// register. In that case, LiveVirtRegs contains the inverse mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:90,Energy Efficiency,allocate,allocated,90,"/// Set of register units that are used in the current instruction, and so; /// cannot be allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:12,Availability,mask,masks,12,// Register masks attached to the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:9,Energy Efficiency,allocate,allocates,9,/// This allocates space for the specified virtual register to be held on the; /// stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:21,Energy Efficiency,allocate,allocated,21,// Already has space allocated?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new stack object for this spill location...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:38,Safety,avoid,avoid,38,// Try to handle some simple cases to avoid spilling and reloading every; // value inside a self looping block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:22,Usability,simpl,simple,22,// Try to handle some simple cases to avoid spilling and reloading every; // value inside a self looping block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:66,Deployability,Update,Update,66,/// Insert spill instruction for \p AssignedReg before \p Before. Update; /// DBG_VALUEs with \p VirtReg operands with the stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite unassigned dbg_values to use the stack slot.; // TODO We can potentially do this for list debug values as well if we know; // how the dbg_values are getting unassigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:156,Energy Efficiency,allocate,allocated,156,/// Mark PhysReg as reserved or free after spilling any virtregs. This is very; /// similar to defineVirtReg except the physreg is reserved instead of; /// allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:186,Energy Efficiency,allocate,allocated,186,/// Return the cost of spilling clearing out PhysReg and aliases so it is free; /// for allocation. Returns 0 when PhysReg is free or disabled with all aliases; /// disabled - it can be allocated directly.; /// \returns spillImpossible when PhysReg or an alias can't be spilled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:32,Usability,clear,clearing,32,/// Return the cost of spilling clearing out PhysReg and aliases so it is free; /// for allocation. Returns 0 when PhysReg is free or disabled with all aliases; /// disabled - it can be allocated directly.; /// \returns spillImpossible when PhysReg or an alias can't be spilled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Testability,Test,Test,3,// Test whether the physreg survives from the definition to the DBG_VALUE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:16,Deployability,update,updates,16,/// This method updates local state so that we know that PhysReg is the; /// proper container for VirtReg now. The physical register must not be used; /// for anything else when this is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a physical register for VirtReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:32,Availability,error,error,32,// Nothing we can do: Report an error and keep going with an invalid; // allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:4,Energy Efficiency,Allocate,Allocates,4,"/// Allocates a register for VirtReg definition. Typically the register is; /// already assigned from a use of the virtreg, however we still need to; /// perform an allocation if:; /// - It is a dead definition without any uses.; /// - The value is live out and all uses are in different basic blocks.; ///; /// \return true if MI's MachineOperands were re-arranged/invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:154,Performance,perform,perform,154,"/// Allocates a register for VirtReg definition. Typically the register is; /// already assigned from a use of the virtreg, however we still need to; /// perform an allocation if:; /// - It is a dead definition without any uses.; /// - The value is live out and all uses are in different basic blocks.; ///; /// \return true if MI's MachineOperands were re-arranged/invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:30,Availability,avail,available,30,"// If no physical register is available for LRI, we assign one at random; // and bail out of this function immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a register for a VirtReg use.; /// \return true if MI's MachineOperands were re-arranged/invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:16,Energy Efficiency,allocate,allocate,16,// If necessary allocate a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:126,Energy Efficiency,allocate,allocateInstruction,126,// Note: We leave the subreg number around a little longer in case of defs.; // This is so that the register freeing logic in allocateInstruction can still; // recognize this as subregister defs. The code there will clear the number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:117,Testability,log,logic,117,// Note: We leave the subreg number around a little longer in case of defs.; // This is so that the register freeing logic in allocateInstruction can still; // recognize this as subregister defs. The code there will clear the number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:216,Usability,clear,clear,216,// Note: We leave the subreg number around a little longer in case of defs.; // This is so that the register freeing logic in allocateInstruction can still; // recognize this as subregister defs. The code there will clear the number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:100,Energy Efficiency,allocate,allocated,100,"/// Compute \ref DefOperandIndexes so it contains the indices of ""def"" operands; /// that are to be allocated. Those are ordered in a way that small classes,; /// early clobbers and livethroughs are allocated first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:199,Energy Efficiency,allocate,allocated,199,"/// Compute \ref DefOperandIndexes so it contains the indices of ""def"" operands; /// that are to be allocated. Those are ordered in a way that small classes,; /// early clobbers and livethroughs are allocated first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate early clobbers and livethrough operands first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:85,Energy Efficiency,Allocate,Allocate,85,"// The basic algorithm here is:; // 1. Mark registers of def operands as free; // 2. Allocate registers to use operands and place reload instructions for; // registers displaced by the allocation.; //; // However we need to handle some corner cases:; // - pre-assigned defs and uses need to be handled before the other def/use; // operands are processed to avoid the allocation heuristics clashing with; // the pre-assignment.; // - The ""free def operands"" step has to come last instead of first for tied; // operands and early-clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:357,Safety,avoid,avoid,357,"// The basic algorithm here is:; // 1. Mark registers of def operands as free; // 2. Allocate registers to use operands and place reload instructions for; // registers displaced by the allocation.; //; // However we need to handle some corner cases:; // - pre-assigned defs and uses need to be handled before the other def/use; // operands are processed to avoid the allocation heuristics clashing with; // the pre-assignment.; // - The ""free def operands"" step has to come last instead of first for tied; // operands and early-clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate virtreg defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate virtreg uses and insert reloads as necessary.; // Implicit MOs can get moved/removed by useVirtReg(), so loop multiple; // times to ensure no operand is missed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:57,Energy Efficiency,allocate,allocated,57,// Populate MayLiveAcrossBlocks in case the use block is allocated before; // the def block (removing the vreg uses).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate undef operands. This is a separate step because in a situation; // like ` = OP undef %X, %X` both operands need the same register assign; // so we should perform the normal assignment first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:166,Performance,perform,perform,166,"// Allocate undef operands. This is a separate step because in a situation; // like ` = OP undef %X, %X` both operands need the same register assign; // so we should perform the normal assignment first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:49,Energy Efficiency,allocate,allocated,49,// See if this virtual register has already been allocated to a physical; // register or spilled to a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Deployability,Update,Update,3,// Update every use of Reg within MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:459,Performance,optimiz,optimized,459,"//===- RegAllocGreedy.cpp - greedy register allocator ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RAGreedy function pass for register allocation in; // optimized builds.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:50,Performance,queue,queue,50,"// Unassigned virtreg is probably in the priority queue.; // RegAllocBase will erase it after dequeueing.; // Nonetheless, clear the live-range so that the debug; // dump will show the right state for that VirtReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:123,Usability,clear,clear,123,"// Unassigned virtreg is probably in the priority queue.; // RegAllocBase will erase it after dequeueing.; // Nonetheless, clear the live-range so that the debug; // dump will show the right state for that VirtReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:44,Performance,queue,queue,44,"// Register is assigned, put it back on the queue for reassignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:74,Performance,queue,queue,74,"// Prioritize live ranges by size, assigning larger ranges first.; // The queue holds (size, reg) pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:35,Energy Efficiency,allocate,allocated,35,// Unsplit ranges that couldn't be allocated immediately are deferred until; // everything else has been allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:105,Energy Efficiency,allocate,allocated,105,// Unsplit ranges that couldn't be allocated immediately are deferred until; // everything else has been allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:180,Modifiability,variab,variable,180,// Memory operand should be considered last.; // Change the priority such that Memory operand are assigned in; // the reverse order that they came in.; // TODO: Make this a member variable and probably do something about hints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate original local ranges in linear instruction order. Since they; // are singly defined, this produces optimal coloring in the absence of; // global interference and other constraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate global and split ranges in long->short order. Long ranges that; // don't fit should be spilled (or split) ASAP so they don't create; // interference. Mark a bit to prioritize global above local ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:284,Availability,mask,masking,284,// Priority bit layout:; // 31 RS_Assign priority; // 30 Preference priority; // if (RegClassPriorityTrumpsGlobalness); // 29-25 AllocPriority; // 24 GlobalBit; // else; // 29 Global bit; // 28-24 AllocPriority; // 0-23 Size/Instr distance; // Clamp the size to fit with the priority masking scheme,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:230,Availability,avail,available,230,//===----------------------------------------------------------------------===//; // Direct Assignment; //===----------------------------------------------------------------------===//; /// tryAssign - Try to assign VirtReg to an available register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:14,Availability,avail,available,14,"// PhysReg is available, but there may be a better choice.; // If we missed a simple hint, try to cheaply evict interference from the; // preferred register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:78,Usability,simpl,simple,78,"// PhysReg is available, but there may be a better choice.; // If we missed a simple hint, try to cheaply evict interference from the; // preferred register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:45,Availability,recover,recover,45,"// Record the missed hint, we may be able to recover; // at the end if the surrounding allocation changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:45,Safety,recover,recover,45,"// Record the missed hint, we may be able to recover; // at the end if the surrounding allocation changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:41,Performance,cache,cached,41,"// We usually have the interfering VRegs cached so collectInterferingVRegs(); // should be fast, we may need to recalculate if when different physregs; // overlap the same register unit so we had different SubRanges queried; // against it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:22,Integrability,depend,dependent,22,// Reset interference dependent info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Safety,Abort,Abort,3,// Abort if the spill cannot be inserted at the MBB' start,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:116,Availability,down,downhill,116,"// Add constraints for use-blocks. Note that these are the only constraints; // that may add a positive bias, it is downhill from here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Safety,Abort,Abort,3,// Abort if the spill cannot be inserted at the MBB' start,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:22,Modifiability,variab,variable,22,"// Providing that the variable being spilled does not look like a loop; // induction variable, which is expensive to spill around and better; // pushed into a condition inside the loop if possible, provide a strong; // negative bias on through blocks to prevent unwanted liveness on loop; // backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:85,Modifiability,variab,variable,85,"// Providing that the variable being spilled does not look like a loop; // induction variable, which is expensive to spill around and better; // pushed into a condition inside the loop if possible, provide a strong; // negative bias on through blocks to prevent unwanted liveness on loop; // backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:181,Modifiability,variab,variable,181,"// Check that the current bundle is adding a Header + start+end of; // loop-internal blocks. If the block is indeed a header, don't make; // the NewBlocks as PrefSpill to allow the variable to be live in; // Header<->Latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:51,Performance,load,load,51,// We normally only need one spill instruction - a load or a store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:286,Performance,queue,queue,286,// Sort out the new intervals created by splitting. We get four kinds:; // - Remainder intervals should not be split again.; // - Candidate intervals can be assigned to Cand.PhysReg.; // - Block-local splits are candidates for local splitting.; // - DCE leftovers should go back on the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:74,Energy Efficiency,allocate,allocate,74,"// Remainder interval. Don't try splitting again, spill if it doesn't; // allocate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:39,Safety,safe,safe,39,// Don't allow repeated splitting as a safe guard against looping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:60,Performance,cache,cache,60,// Discard bad candidates before we run out of interference cache cursors.; // This will only affect register classes with a lot of registers (>32).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:151,Performance,optimiz,optimized,151,"// Split the VirtReg may generate COPY instructions in multiple cold basic; // blocks, and increase code size. So we avoid it when the function is; // optimized for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:117,Safety,avoid,avoid,117,"// Split the VirtReg may generate COPY instructions in multiple cold basic; // blocks, and increase code size. So we avoid it when the function is; // optimized for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:39,Safety,safe,safe,39,// Don't allow repeated splitting as a safe guard against looping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:365,Energy Efficiency,allocate,allocate,365,"//===----------------------------------------------------------------------===//; // Per-Block Splitting; //===----------------------------------------------------------------------===//; /// tryBlockSplit - Split a global live range around every block with uses. This; /// creates a lot of local live ranges, that will be split by tryLocalSplit if; /// they don't allocate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:29,Deployability,continuous,continuous,29,"// We know that VirtReg is a continuous interval from FirstInstr to; // LastInstr, so we don't need InterferenceQuery.; //; // Interference that overlaps an instruction is counted in both gaps; // surrounding the instruction. The exception is interference before; // StartIdx and after StopIdx.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Deployability,Update,Update,3,// Update the gaps covered by IntI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:318,Deployability,continuous,continuous,318,"// Note that it is possible to have an interval that is live-in or live-out; // while only covering a single block - A phi-def can use undef values from; // predecessors, and the block could be a single-block loop.; // We don't bother doing anything clever about such a case, we simply assume; // that the interval is continuous from FirstInstr to LastInstr. We should; // make sure that we don't do anything illegal to such an interval, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:279,Usability,simpl,simply,279,"// Note that it is possible to have an interval that is live-in or live-out; // while only covering a single block - A phi-def can use undef values from; // predecessors, and the block could be a single-block loop.; // We don't bother doing anything clever about such a case, we simply assume; // that the interval is continuous from FirstInstr to LastInstr. We should; // make sure that we don't do anything illegal to such an interval, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:42,Availability,mask,mask,42,"// If VirtReg is live across any register mask operands, compute a list of; // gaps with register masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:98,Availability,mask,masks,98,"// If VirtReg is live across any register mask operands, compute a list of; // gaps with register masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:68,Safety,risk,risk,68,"// Since we allow local split results to be split again, there is a risk of; // creating infinite loops. It is tempting to require that the new live; // ranges have less instructions than the original. That would guarantee; // convergence, but it is too strict. A live range with 3 instructions can be; // split 2+3 (including the COPY), and we want to allow that.; //; // Instead we use these rules:; //; // 1. Allow any split for ranges with getStage() < RS_Split2. (Except for the; // noop split, of course).; // 2. Require progress be made for ranges with getStage() == RS_Split2. All; // the new ranges must have fewer instructions than before the split.; // 3. New ranges with the same number of instructions are marked RS_Split2,; // smaller ranges are marked RS_New.; //; // These rules allow a 3 -> 2+3 split once, which we need. They also prevent; // excessive splitting and infinite loops.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:26,Modifiability,extend,extended,26,// Should the interval be extended or shrunk?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:35,Energy Efficiency,allocate,allocate,35,"// Would this split be possible to allocate?; // Never allocate all gaps, we wouldn't be making progress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:55,Energy Efficiency,allocate,allocate,55,"// Would this split be possible to allocate?; // Never allocate all gaps, we wouldn't be making progress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:10,Modifiability,extend,extend,10,// Try to extend the interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:1004,Availability,avail,available,1004,"/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring; /// its interferences.; /// Last chance recoloring chooses a color for \p VirtReg and recolors every; /// virtual register that was using it. The recoloring process may recursively; /// use the last chance recoloring. Therefore, when a virtual register has been; /// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot; /// be last-chance-recolored again during this recoloring ""session"".; /// E.g.,; /// Let; /// vA can use {R1, R2 }; /// vB can use { R2, R3}; /// vC can use {R1 }; /// Where vA, vB, and vC cannot be split anymore (they are reloads for; /// instance) and they all interfere.; ///; /// vA is assigned R1; /// vB is assigned R2; /// vC tries to evict vA but vA is already done.; /// Regular register allocation fails.; ///; /// Last chance recoloring kicks in:; /// vC does as if vA was evicted => vC uses R1.; /// vC is marked as fixed.; /// vA needs to find a color.; /// None are available.; /// vA cannot evict vC: vC is a fixed virtual register now.; /// vA does as if vB was evicted => vA uses R2.; /// vB needs to find a color.; /// R3 is available.; /// Recoloring => vC = R1, vA = R2, vB = R3; ///; /// \p Order defines the preferred allocation order for \p VirtReg.; /// \p NewRegs will contain any new virtual register that have been created; /// (split, spill) during the process and that must be assigned.; /// \p FixedRegisters contains all the virtual registers that cannot be; /// recolored.; ///; /// \p RecolorStack tracks the original assignments of successfully recolored; /// registers.; ///; /// \p Depth gives the current depth of the last chance recoloring.; /// \return a physical register that can be used for VirtReg or ~0u if none; /// exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:1167,Availability,avail,available,1167,"/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring; /// its interferences.; /// Last chance recoloring chooses a color for \p VirtReg and recolors every; /// virtual register that was using it. The recoloring process may recursively; /// use the last chance recoloring. Therefore, when a virtual register has been; /// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot; /// be last-chance-recolored again during this recoloring ""session"".; /// E.g.,; /// Let; /// vA can use {R1, R2 }; /// vB can use { R2, R3}; /// vC can use {R1 }; /// Where vA, vB, and vC cannot be split anymore (they are reloads for; /// instance) and they all interfere.; ///; /// vA is assigned R1; /// vB is assigned R2; /// vC tries to evict vA but vA is already done.; /// Regular register allocation fails.; ///; /// Last chance recoloring kicks in:; /// vC does as if vA was evicted => vC uses R1.; /// vC is marked as fixed.; /// vA needs to find a color.; /// None are available.; /// vA cannot evict vC: vC is a fixed virtual register now.; /// vA does as if vB was evicted => vA uses R2.; /// vB needs to find a color.; /// R3 is available.; /// Recoloring => vC = R1, vA = R2, vB = R3; ///; /// \p Order defines the preferred allocation order for \p VirtReg.; /// \p NewRegs will contain any new virtual register that have been created; /// (split, spill) during the process and that must be assigned.; /// \p FixedRegisters contains all the virtual registers that cannot be; /// recolored.; ///; /// \p RecolorStack tracks the original assignments of successfully recolored; /// registers.; ///; /// \p Depth gives the current depth of the last chance recoloring.; /// \return a physical register that can be used for VirtReg or ~0u if none; /// exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:163,Performance,perform,perform,163,// RecoloringCandidates contains all the virtual registers that interfere; // with VirtReg on PhysReg (or one of its aliases). Enqueue them for; // recoloring and perform the actual recoloring.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:137,Availability,avail,available,137,// Do as if VirtReg was assigned to PhysReg so that the underlying; // recoloring has the right information about the interferes and; // available colors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:12,Performance,queue,queued,12,// Push the queued vregs into the main queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:39,Performance,queue,queue,39,// Push the queued vregs into the main queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:34,Usability,undo,undo,34,"// The recoloring attempt failed, undo the changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:251,Performance,Perform,Perform,251,"// Roll back our unsuccessful recoloring. Also roll back any successful; // recolorings in any recursive recoloring attempts, since it's possible; // they would have introduced conflicts with assignments we will be; // restoring further up the stack. Perform all unassignments prior to; // reassigning, since sub-recolorings may have conflicted with the registers; // we are going to restore to their original assignments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Performance,Perform,Perform,3,// Perform the actual pre-splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:98,Usability,clear,cleared,98,/// Collect the hint info for \p Reg.; /// The results are stored into \p Out.; /// \p Out is not cleared before being populated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:173,Availability,avail,available,173,"// We have a broken hint, check if it is possible to fix it by; // reusing PhysReg for the copy-related live-ranges. Indeed, we evicted; // some register and PhysReg may be available for the other live-ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:121,Security,expose,expose,121,"// At this point, the cost is either cheaper or equal. If it is; // equal, we consider this is profitable because it may expose; // more recoloring opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:58,Availability,repair,repaired,58,"/// Try to recolor broken hints.; /// Broken hints may be repaired by recoloring when an evicted variable; /// freed up a register for a larger live-range.; /// Consider the following example:; /// BB1:; /// a =; /// b =; /// BB2:; /// ...; /// = b; /// = a; /// Let us assume b gets split:; /// BB1:; /// a =; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// = a; /// Because of how the allocation work, b, c, and d may be assigned different; /// colors. Now, if a gets evicted later:; /// BB1:; /// a =; /// st a, SpillSlot; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// e = ld SpillSlot; /// = e; /// This is likely that we can assign the same register for b, c, and d,; /// getting rid of 2 copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:97,Modifiability,variab,variable,97,"/// Try to recolor broken hints.; /// Broken hints may be repaired by recoloring when an evicted variable; /// freed up a register for a larger live-range.; /// Consider the following example:; /// BB1:; /// a =; /// b =; /// BB2:; /// ...; /// = b; /// = a; /// Let us assume b gets split:; /// BB1:; /// a =; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// = a; /// Because of how the allocation work, b, c, and d may be assigned different; /// colors. Now, if a gets evicted later:; /// BB1:; /// a =; /// st a, SpillSlot; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// e = ld SpillSlot; /// = e; /// This is likely that we can assign the same register for b, c, and d,; /// getting rid of 2 copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:83,Performance,queue,queue,83,"// Try to evict a less worthy live range, but only for ranges from the primary; // queue. The RS_Split ranges already failed to do this, and they should not; // get a second chance until they have been split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:156,Modifiability,variab,variable,156,"// If VirtReg has a hint and that hint is broken record this; // virtual register as a recoloring candidate for broken hint.; // Indeed, since we evicted a variable in its neighborhood it is; // likely we can at least partially recolor some of the; // copy-related live-ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:134,Energy Efficiency,allocate,allocated,134,"// The first time we see a live range, don't try to split or spill.; // Wait until the second time, when all smaller ranges have been allocated.; // This gives a better picture of the interference to split around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:18,Energy Efficiency,allocate,allocate,18,"// If we couldn't allocate a register from spilling, there is probably some; // invalid inline assembly. The base class will report it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:147,Deployability,integrat,integration,147,"// TODO: This is experimental and in particular, we do not model; // the live range splitting done by spilling correctly.; // We would need a deep integration with the spiller to do the; // right thing here. Anyway, that is still good for early testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:147,Integrability,integrat,integration,147,"// TODO: This is experimental and in particular, we do not model; // the live range splitting done by spilling correctly.; // We would need a deep integration with the spiller to do the; // right thing here. Anyway, that is still good for early testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:245,Testability,test,testing,245,"// TODO: This is experimental and in particular, we do not model; // the live range splitting done by spilling correctly.; // We would need a deep integration with the spiller to do the; // right thing here. Anyway, that is still good for early testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:160,Modifiability,rewrite,rewrite,160,"// Tell LiveDebugVariables about the new ranges. Ranges not being covered by; // the new regs are kept in LDV (still mapping to the old register), until; // we rewrite spilled locations in LDV at a later stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:94,Energy Efficiency,allocate,allocate,94,"// The live virtual register requesting allocation was spilled, so tell; // the caller not to allocate anything during this round.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:54,Energy Efficiency,allocate,allocated,54,// Early return if there is no virtual register to be allocated to a; // physical register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:454,Performance,optimiz,optimized,454,"//==- RegAllocGreedy.h ------- greedy register allocator ----------*-C++-*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines the RAGreedy function pass for register allocation in; // optimized builds.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:3,Integrability,Interface,Interface,3,// Interface to eviction advisers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:8,Integrability,interface,interface,8,// end (interface to eviction advisers); // Interface to priority advisers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:44,Integrability,Interface,Interface,44,// end (interface to eviction advisers); // Interface to priority advisers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:8,Integrability,interface,interface,8,// end (interface to priority advisers),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:28,Integrability,interface,interface,28,// Shortcuts to some useful interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:201,Energy Efficiency,power,power,201,// Enum CutOffStage to keep a track whether the register allocation failed; // because of the cutoffs encountered in last chance recoloring.; // Note: This is used as bitmask. New value should be next power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:4,Performance,Cache,Cached,4,/// Cached per-block interference maps,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:4,Performance,Perform,Perform,4,/// Perform register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:4,Performance,Perform,Perform,4,/// Perform region splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:719,Modifiability,variab,variables,719,"//===- RegAllocPBQP.cpp ---- PBQP Register Allocator ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a Partitioned Boolean Quadratic Programming (PBQP) based; // register allocator for LLVM. This allocator works by constructing a PBQP; // problem representing the register allocation problem under consideration,; // solving this using a PBQP solver, and mapping the solution back to a; // register assignment. If any variables are selected for spilling then spill; // code is inserted and the process repeated.; //; // The PBQP solver (pbqp.c) provided for this allocator uses a heuristic tuned; // for register allocation. For more information on PBQP for register; // allocation, see the following papers:; //; // (1) Hames, L. and Scholz, B. 2006. Nearly optimal register allocation with; // PBQP. In Proceedings of the 7th Joint Modular Languages Conference; // (JMLC'06). LNCS, vol. 4228. Springer, New York, NY, USA. 346-361.; //; // (2) Scholz, B., Eckstein, E. 2002. Register allocation for irregular; // architectures. In Proceedings of the Joint Conference on Languages,; // Compilers and Tools for Embedded Systems (LCTES'02), ACM Press, New York,; // NY, USA, 139-148.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:891,Performance,tune,tuned,891,"//===- RegAllocPBQP.cpp ---- PBQP Register Allocator ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a Partitioned Boolean Quadratic Programming (PBQP) based; // register allocator for LLVM. This allocator works by constructing a PBQP; // problem representing the register allocation problem under consideration,; // solving this using a PBQP solver, and mapping the solution back to a; // register assignment. If any variables are selected for spilling then spill; // code is inserted and the process repeated.; //; // The PBQP solver (pbqp.c) provided for this allocator uses a heuristic tuned; // for register allocation. For more information on PBQP for register; // allocation, see the following papers:; //; // (1) Hames, L. and Scholz, B. 2006. Nearly optimal register allocation with; // PBQP. In Proceedings of the 7th Joint Modular Languages Conference; // (JMLC'06). LNCS, vol. 4228. Springer, New York, NY, USA. 346-361.; //; // (2) Scholz, B., Eckstein, E. 2002. Register allocation for irregular; // architectures. In Proceedings of the Joint Conference on Languages,; // Compilers and Tools for Embedded Systems (LCTES'02), ACM Press, New York,; // NY, USA, 139-148.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:4,Performance,Perform,Perform,4,/// Perform register allocation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:232,Availability,avail,available,232,"/// Inst which is a def of an original reg and whose defs are already all; /// dead after remat is saved in DeadRemats. The deletion of such inst is; /// postponed till all the allocations are done, so its remat expr is; /// always available for the remat of all the siblings of the original reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:47,Energy Efficiency,allocate,allocate,47,/// Finds the initial set of vreg intervals to allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:74,Modifiability,variab,variables,74,"/// Postprocessing before final spilling. Sets basic block ""live in""; /// variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:39,Performance,queue,queue,39,"// Condition reversed because priority queue has the *highest* element at; // the front, rather than the lowest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:104,Performance,cache,cache,104,"// Interferenc matrices are incredibly regular - they're only a function of; // the allowed sets, so we cache them to avoid the overhead of constructing; // and uniquing them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:118,Safety,avoid,avoid,118,"// Interferenc matrices are incredibly regular - they're only a function of; // the allowed sets, so we cache them to avoid the overhead of constructing; // and uniquing them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:77,Performance,cache,cache,77,// Finding an edge is expensive in the worst case (O(max_clique(G))). So; // cache locally edges we have already seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:3,Performance,Cache,Cache,3,// Cache known disjoint allowed registers pairs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:11,Usability,usab,usable,11,// preg is usable for this virtual register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:71,Energy Efficiency,allocate,allocate,71,// Copy any newly inserted live intervals into the list of regs to; // allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:3,Usability,Clear,Clear,3,// Clear the existing allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:9,Energy Efficiency,allocate,allocate,9,// First allocate registers for the empty intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:36,Energy Efficiency,allocate,allocate,36,// If there are non-empty intervals allocate them using pbqp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:24,Energy Efficiency,allocate,allocate,24,"// Finalise allocation, allocate empty ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPriorityAdvisor.h:4,Integrability,Interface,Interface,4,"/// Interface to the priority advisor, which is responsible for prioritizing; /// live ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPriorityAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPriorityAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.cpp:633,Performance,load,loads,633,"//===- RegAllocScore.cpp - evaluate regalloc policy quality ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// Calculate a measure of the register allocation policy quality. This is used; /// to construct a reward for the training of the ML-driven allocation policy.; /// Currently, the score is the sum of the machine basic block frequency-weighed; /// number of loads, stores, copies, and remat instructions, each factored with; /// a relative weight.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.h:632,Performance,load,loads,632,"//==- RegAllocScore.h - evaluate regalloc policy quality ----------*-C++-*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// Calculate a measure of the register allocation policy quality. This is used; /// to construct a reward for the training of the ML-driven allocation policy.; /// Currently, the score is the sum of the machine basic block frequency-weighed; /// number of loads, stores, copies, and remat instructions, each factored with; /// a relative weight.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBank.cpp:60,Availability,alive,alive,60,// There must be only one instance of a given register bank alive; // for the whole compilation.; // The RegisterBankInfo is supposed to enforce that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBank.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBank.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:39,Availability,avail,available,39,// The mapping of the registers may be available via the; // register class constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:38,Usability,simpl,simply,38,"// If nothing was set or the class is simply compatible, set it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:78,Availability,avail,available,78,// Before doing anything complicated check if the mapping is not; // directly available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:4,Security,Hash,Hashing,4,/// Hashing function for PartialMapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:93,Security,hash,hash,93,"// The addresses of the value mapping are unique.; // Therefore, we can use them directly to hash the operand mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:67,Security,hash,hash,67,"// Create the array of ValueMapping.; // Note: this array will not hash to this instance of operands; // mapping, because we use the pointer of the ValueMapping; // to hash and we expect them to uniquely identify an instance; // of value mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:168,Security,hash,hash,168,"// Create the array of ValueMapping.; // Note: this array will not hash to this instance of operands; // mapping, because we use the pointer of the ValueMapping; // to hash and we expect them to uniquely identify an instance; // of value mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:28,Availability,avail,available,28,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.; // Because this is expensive, we'll cache the register class by calling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:210,Performance,cache,cache,210,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.; // Because this is expensive, we'll cache the register class by calling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:86,Security,access,access,86,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.; // Because this is expensive, we'll cache the register class by calling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:72,Security,access,accessed,72,// The original value should completely be mapped.; // Thus the maximum accessed index + 1 is the size of the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:36,Security,access,access,36,// This is the first time we try to access OpIdx.; // Create the cells that will hold all the partial values at the; // end of the list of NewVReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:559,Integrability,depend,depend,559,"//===- RegisterClassInfo.cpp - Dynamic Register Class Info ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RegisterClassInfo class which provides dynamic; // information about target register classes. Callee-saved vs. caller-saved and; // reserved registers depend on calling conventions and other dynamic; // information, so some things cannot be determined statically.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new array the first time we see a new target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:3,Testability,Test,Test,3,// Test if CSRs have changed from the previous function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:14,Performance,cache,cached,14,// Invalidate cached information from previous function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:104,Usability,simpl,simply,104,"// FIXME: Once targets reserve registers instead of removing them from the; // allocation order, we can simply use begin/end here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:29,Testability,test,test,29,// Register allocator stress test. Clip register class to N registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:96,Energy Efficiency,Power,PowerPC,96,"// If all the regs are reserved, return raw RegPressureSetLimit.; // One example is VRSAVERC in PowerPC.; // Avoid returning zero, getRegPressureSetLimit(Idx) assumes computePSetLimit; // return non-zero value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:109,Safety,Avoid,Avoid,109,"// If all the regs are reserved, return raw RegPressureSetLimit.; // One example is VRSAVERC in PowerPC.; // Avoid returning zero, getRegPressureSetLimit(Idx) assumes computePSetLimit; // return non-zero value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:59,Integrability,Interface,Interface,59,"//===- RegisterCoalescer.cpp - Generic Register Coalescing Interface ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic RegisterCoalescer interface which; // is used as the common interface used by all clients and; // implementations of register coalescing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:434,Integrability,interface,interface,434,"//===- RegisterCoalescer.cpp - Generic Register Coalescing Interface ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic RegisterCoalescer interface which; // is used as the common interface used by all clients and; // implementations of register coalescing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:476,Integrability,interface,interface,476,"//===- RegisterCoalescer.cpp - Generic Register Coalescing Interface ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic RegisterCoalescer interface which; // is used as the common interface used by all clients and; // implementations of register coalescing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:22,Testability,test,test,22,/// Temporary flag to test critical edge unsplitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:39,Performance,optimiz,optimization,39,/// Temporary flag to test global copy optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:22,Testability,test,test,22,/// Temporary flag to test global copy optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:10,Modifiability,variab,variable,10,"/// Debug variable location tracking -- for each VReg, maintain an; /// ordered-by-slot-index set of DBG_VALUEs, to help quick; /// identification of whether coalescing may change location validity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:60,Deployability,update,updated,60,/// The collection of live intervals which should have been updated; /// immediately after rematerialiation but delayed until; /// lateLiveIntervalUpdate is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:107,Deployability,update,update,107,"/// If one def has many copy like uses, and those copy uses are all; /// rematerialized, the live interval update needed for those; /// rematerializations will be delayed and done all at once instead; /// of being done multiple times. This is to save compile cost because; /// live interval update is costly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:291,Deployability,update,update,291,"/// If one def has many copy like uses, and those copy uses are all; /// rematerialized, the live interval update needed for those; /// rematerializations will be delayed and done all at once instead; /// of being done multiple times. This is to save compile cost because; /// live interval update is costly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:44,Availability,failure,failure,44,"/// Attempt to join these two intervals. On failure, this; /// returns false. The output ""SrcInt"" will not have been modified, so we; /// can use this information below to update aliases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:172,Deployability,update,update,172,"/// Attempt to join these two intervals. On failure, this; /// returns false. The output ""SrcInt"" will not have been modified, so we; /// can use this information below to update aliases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:54,Deployability,update,update,54,"/// Replace all defs and uses of SrcReg to DstReg and update the subregister; /// number if it is not zero. If DstReg is a physical register and the; /// existing subregister number of the def / use being updated is not zero,; /// make sure to set it to the correct physical subregister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:205,Deployability,update,updated,205,"/// Replace all defs and uses of SrcReg to DstReg and update the subregister; /// number if it is not zero. If DstReg is a physical register and the; /// existing subregister number of the def / use being updated is not zero,; /// make sure to set it to the correct physical subregister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:562,Security,expose,exposes,562,"/// Check whether or not we should apply the terminal rule on the; /// destination (Dst) of \p Copy.; /// When the terminal rule applies, Copy is not profitable to; /// coalesce.; /// Dst is terminal if it has exactly one affinity (Dst, Src) and; /// at least one interference (Dst, Dst2). If Dst is terminal, the; /// terminal rule consists in checking that at least one of; /// interfering node, say Dst2, has an affinity of equal or greater; /// weight with Src.; /// In that case, Dst2 and Dst will not be able to be both coalesced; /// with Src. Since Dst2 exposes more coalescing opportunities than; /// Dst, we can drop \p Copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:4,Integrability,Wrap,Wrapper,4,/// Wrapper method for \see LiveIntervals::shrinkToUses.; /// This method does the proper fixing of the live-ranges when the afore; /// mentioned method returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:4,Integrability,Wrap,Wrapper,4,/// Wrapper Method to do all the necessary work when an Instruction is; /// deleted.; /// Optimizations should use this to make sure that deleted instructions; /// are always accounted for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:90,Performance,Optimiz,Optimizations,90,/// Wrapper Method to do all the necessary work when an Instruction is; /// deleted.; /// Optimizations should use this to make sure that deleted instructions; /// are always accounted for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:4,Testability,Test,Test,4,"/// Test whether, after merging, any DBG_VALUEs would refer to a; /// different value number than before merging, and whether this can; /// be resolved. If not, mark the DBG_VALUE as being undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:220,Usability,Simpl,Simple,220,"/// Return true if this block should be vacated by the coalescer to eliminate; /// branches. The important cases to handle in the coalescer are critical edges; /// split during phi elimination which contain only copies. Simple blocks that; /// contain non-branches should also be vacated, but this can be handled by an; /// earlier pass similar to early if-conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:404,Modifiability,extend,extended,404,"// We have a non-trivially-coalescable copy with IntA being the source and; // IntB being the dest, thus this defines a value number in IntB. If the; // source value number (in IntA) is defined by a copy from B, see if we can; // merge these two pieces of B into a single value number, eliminating a copy.; // For example:; //; // A3 = B0; // ...; // B1 = A3 <- this copy; //; // In this case, B0 can be extended to where the B1 copy lives, allowing the; // B1 value number to be replaced with B0 (which simplifies the B; // liveinterval).; // BValNo is a value number in B that is defined by a copy from A. 'B1' in; // the example above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:504,Usability,simpl,simplifies,504,"// We have a non-trivially-coalescable copy with IntA being the source and; // IntB being the dest, thus this defines a value number in IntB. If the; // source value number (in IntA) is defined by a copy from B, see if we can; // merge these two pieces of B into a single value number, eliminating a copy.; // For example:; //; // A3 = B0; // ...; // B1 = A3 <- this copy; //; // In this case, B0 can be extended to where the B1 copy lives, allowing the; // B1 value number to be replaced with B0 (which simplifies the B; // liveinterval).; // BValNo is a value number in B that is defined by a copy from A. 'B1' in; // the example above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:107,Deployability,Update,Update,107,"// We are about to delete CopyMI, so need to remove it as the 'instruction; // that defines this value #'. Update the valnum with the new defining; // instruction #.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:58,Modifiability,extend,extend,58,"// The subrange may have ended before FillerStart. If so, extend it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:137,Modifiability,extend,extended,137,"// If the source instruction was killing the source register before the; // merge, unset the isKill marker given the live range has been extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:132,Performance,perform,perform,132,"// If some of the uses of IntA.reg is already coalesced away, return false.; // It's not possible to determine whether it's safe to perform the coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:124,Safety,safe,safe,124,"// If some of the uses of IntA.reg is already coalesced away, return false.; // It's not possible to determine whether it's safe to perform the coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:42,Modifiability,rewrite,rewrite,42,"// If this use is tied to a def, we can't rewrite the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:153,Deployability,Update,Update,153,"// If ALR and BLR overlaps and end of BLR extends beyond end of ALR, e.g.; // A = or A, B; // ...; // B = A; // ...; // C = killed A; // ...; // = B; // Update uses of IntA of the specific Val# with IntB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:42,Modifiability,extend,extends,42,"// If ALR and BLR overlaps and end of BLR extends beyond end of ALR, e.g.; // A = or A, B; // ...; // B = A; // ...; // C = killed A; // ...; // = B; // Update uses of IntA of the specific Val# with IntB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:52,Usability,clear,clear,52,// FIXME These don't have an instruction index. Not clear we have enough; // info to decide whether to do this replacement or not. For now do it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:84,Deployability,update,updated,84,// Extend BValNo by merging in IntA live segments of AValNo. Val# definition; // is updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Extend,Extend,3,// Extend BValNo by merging in IntA live segments of AValNo. Val# definition; // is updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:198,Availability,redundant,redundant,198,"/// For copy B = A in BB2, if A is defined by A = B in BB0 which is a; /// predecessor of BB2, and if B is not redefined on the way from A = B; /// in BB0 to B = A in BB2, B = A in BB2 is partially redundant if the; /// execution goes through the path from BB0 to BB2. We may move B = A; /// to the predecessor without such reversed copy.; /// So we will transform the program from:; /// BB0:; /// A = B; BB1:; /// ... ...; /// / \ /; /// BB2:; /// ...; /// B = A;; ///; /// to:; ///; /// BB0: BB1:; /// A = B; ...; /// ... B = A;; /// / \ /; /// BB2:; /// ...; ///; /// A special case is when BB0 and BB2 are the same BB which is the only; /// BB in a loop:; /// BB1:; /// ...; /// BB0/BB2: ----; /// B = A; |; /// ... |; /// A = B; |; /// |-------; /// |; /// We may hoist B = A from BB0/BB2 to BB1.; ///; /// The major preconditions for correctness to remove such partial; /// redundancy include:; /// 1. A in B = A in BB2 is defined by a PHI in BB2, and one operand of; /// the PHI is defined by the reversed copy A = B in BB0.; /// 2. No B is referenced from the start of BB2 to B = A.; /// 3. No B is defined from A = B to the end of BB0.; /// 4. BB1 has only one successor.; ///; /// 2 and 4 implicitly ensure B is not live at the end of BB1.; /// 4 guarantees BB2 is hotter than BB1, so we can only move a copy to a; /// colder place, which not only prevent endless loop, but also make sure; /// the movement of copy is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:198,Safety,redund,redundant,198,"/// For copy B = A in BB2, if A is defined by A = B in BB0 which is a; /// predecessor of BB2, and if B is not redefined on the way from A = B; /// in BB0 to B = A in BB2, B = A in BB2 is partially redundant if the; /// execution goes through the path from BB0 to BB2. We may move B = A; /// to the predecessor without such reversed copy.; /// So we will transform the program from:; /// BB0:; /// A = B; BB1:; /// ... ...; /// / \ /; /// BB2:; /// ...; /// B = A;; ///; /// to:; ///; /// BB0: BB1:; /// A = B; ...; /// ... B = A;; /// / \ /; /// BB2:; /// ...; ///; /// A special case is when BB0 and BB2 are the same BB which is the only; /// BB in a loop:; /// BB1:; /// ...; /// BB0/BB2: ----; /// B = A; |; /// ... |; /// A = B; |; /// |-------; /// |; /// We may hoist B = A from BB0/BB2 to BB1.; ///; /// The major preconditions for correctness to remove such partial; /// redundancy include:; /// 1. A in B = A in BB2 is defined by a PHI in BB2, and one operand of; /// the PHI is defined by the reversed copy A = B in BB0.; /// 2. No B is referenced from the start of BB2 to B = A.; /// 3. No B is defined from A = B to the end of BB0.; /// 4. BB1 has only one successor.; ///; /// 2 and 4 implicitly ensure B is not live at the end of BB1.; /// 4 guarantees BB2 is hotter than BB1, so we can only move a copy to a; /// colder place, which not only prevent endless loop, but also make sure; /// the movement of copy is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:880,Safety,redund,redundancy,880,"/// For copy B = A in BB2, if A is defined by A = B in BB0 which is a; /// predecessor of BB2, and if B is not redefined on the way from A = B; /// in BB0 to B = A in BB2, B = A in BB2 is partially redundant if the; /// execution goes through the path from BB0 to BB2. We may move B = A; /// to the predecessor without such reversed copy.; /// So we will transform the program from:; /// BB0:; /// A = B; BB1:; /// ... ...; /// / \ /; /// BB2:; /// ...; /// B = A;; ///; /// to:; ///; /// BB0: BB1:; /// A = B; ...; /// ... B = A;; /// / \ /; /// BB2:; /// ...; ///; /// A special case is when BB0 and BB2 are the same BB which is the only; /// BB in a loop:; /// BB1:; /// ...; /// BB0/BB2: ----; /// B = A; |; /// ... |; /// A = B; |; /// |-------; /// |; /// We may hoist B = A from BB0/BB2 to BB1.; ///; /// The major preconditions for correctness to remove such partial; /// redundancy include:; /// 1. A in B = A in BB2 is defined by a PHI in BB2, and one operand of; /// the PHI is defined by the reversed copy A = B in BB0.; /// 2. No B is referenced from the start of BB2 to B = A.; /// 3. No B is defined from A = B to the end of BB0.; /// 4. BB1 has only one successor.; ///; /// 2 and 4 implicitly ensure B is not live at the end of BB1.; /// 4 guarantees BB2 is hotter than BB1, so we can only move a copy to a; /// colder place, which not only prevent endless loop, but also make sure; /// the movement of copy is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:143,Deployability,update,updated,143,"// If CopyLeftBB is nullptr, it means every predecessor of MBB contains; // reverse copy, CopyMI can be removed trivially if only IntA/IntB is updated.; // If CopyLeftBB is not nullptr, move CopyMI from MBB to CopyLeftBB and; // update IntA/IntB.; //; // If CopyLeftBB is not nullptr, ensure CopyLeftBB has a single succ so; // MBB is hotter than CopyLeftBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:229,Deployability,update,update,229,"// If CopyLeftBB is nullptr, it means every predecessor of MBB contains; // reverse copy, CopyMI can be removed trivially if only IntA/IntB is updated.; // If CopyLeftBB is not nullptr, move CopyMI from MBB to CopyLeftBB and; // update IntA/IntB.; //; // If CopyLeftBB is not nullptr, ensure CopyLeftBB has a single succ so; // MBB is hotter than CopyLeftBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,Update,Update,3,// Update the liveness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:127,Modifiability,extend,extending,127,"// We're introducing an undef phi def, and need to set undef on any users of; // the previously local def to avoid artifically extending the lifetime; // through the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:109,Safety,avoid,avoid,109,"// We're introducing an undef phi def, and need to set undef on any users of; // the previously local def to avoid artifically extending the lifetime; // through the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Extend,Extend,3,// Extend IntB to the EndPoints of its original live interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:25,Modifiability,extend,extended,25,"// If any dead defs were extended, truncate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:12,Deployability,update,update,12,"// Finally, update the live-range of IntA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:163,Performance,perform,performance,163,"// If both SrcIdx and DstIdx are set, correct rematerialization would widen; // the register substantially (beyond both source and dest size). This is bad; // for performance since it can cascade through a function, introducing many; // extra spills and fills (e.g. ARM can easily end up copying QQQQPR registers; // around after a few subreg copies).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:185,Usability,simpl,simply,185,"// In a situation like the following:; // %0:subreg = instr ; DefMI, subreg = DstIdx; // %1 = copy %0:subreg ; CopyMI, SrcIdx = 0; // instead of widening %1 to the register class of %0 simply do:; // %1 = instr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:487,Energy Efficiency,reduce,reduced,487,"// NewMI may have dead implicit defs (E.g. EFLAGS for MOV<bits>r0 on X86).; // We need to remember these so we can add intervals once we insert; // NewMI into SlotIndexes.; //; // We also expect to have tied implicit-defs of super registers originating; // from SUBREG_TO_REG, such as:; // $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi; // undef %0.sub_32bit = MOV32r0 implicit-def dead $eflags, implicit-def %0; //; // The implicit-def of the super register may have been reduced to; // subregisters depending on the uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:515,Integrability,depend,depending,515,"// NewMI may have dead implicit defs (E.g. EFLAGS for MOV<bits>r0 on X86).; // We need to remember these so we can add intervals once we insert; // NewMI into SlotIndexes.; //; // We also expect to have tied implicit-defs of super registers originating; // from SUBREG_TO_REG, such as:; // $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi; // undef %0.sub_32bit = MOV32r0 implicit-def dead $eflags, implicit-def %0; //; // The implicit-def of the super register may have been reduced to; // subregisters depending on the uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:84,Deployability,update,updated,84,"// We're only expecting another def of the main output, so the range; // should get updated with the regular output range.; //; // FIXME: The range updating below probably needs updating to look at; // the super register if subranges are tracked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,Update,Update,3,// Update machine operands and add flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,update,updateRegDefUses,3,"// updateRegDefUses can add an ""undef"" flag to the definition, since; // it will replace DstReg with DstReg.DstIdx. If NewIdx is 0, make; // sure that ""undef"" is not set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:267,Performance,LOAD,LOAD,267,"// Add dead subregister definitions if we are defining the whole register; // but only part of it is live.; // This could happen if the rematerialization instruction is rematerializing; // more than actually is used in the register.; // An example would be:; // %1 = LOAD CONSTANTS 5, 8 ; Loading both 5 and 8 in different subregs; // ; Copying only part of the register here, but the rest is undef.; // %2:sub_16bit<def, read-undef> = COPY %1:sub_16bit; // ==>; // ; Materialize all the constants but only using one; // %2 = LOAD_CONSTANTS 5, 8; //; // at this point for the part that wasn't defined before we could have; // subranges missing the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:289,Performance,Load,Loading,289,"// Add dead subregister definitions if we are defining the whole register; // but only part of it is live.; // This could happen if the rematerialization instruction is rematerializing; // more than actually is used in the register.; // An example would be:; // %1 = LOAD CONSTANTS 5, 8 ; Loading both 5 and 8 in different subregs; // ; Copying only part of the register here, but the rest is undef.; // %2:sub_16bit<def, read-undef> = COPY %1:sub_16bit; // ==>; // ; Materialize all the constants but only using one; // %2 = LOAD_CONSTANTS 5, 8; //; // at this point for the part that wasn't defined before we could have; // subranges missing the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:109,Performance,LOAD,LOAD,109,"// Make sure that the subrange for resultant undef is removed; // For example:; // %1:sub1<def,read-undef> = LOAD CONSTANT 1; // %2 = COPY %1; // ==>; // %2:sub1<def, read-undef> = LOAD CONSTANT 1; // ; Correct but need to remove the subrange for %2:sub0; // ; as it is now undef",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:181,Performance,LOAD,LOAD,181,"// Make sure that the subrange for resultant undef is removed; // For example:; // %1:sub1<def,read-undef> = LOAD CONSTANT 1; // %2 = COPY %1; // ==>; // %2:sub1<def, read-undef> = LOAD CONSTANT 1; // ; Correct but need to remove the subrange for %2:sub0; // ; as it is now undef",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:129,Deployability,update,updateRegDefUses,129,"// We may not have a defined value at this point, but still need to; // clear out any empty subranges tentatively created by; // updateRegDefUses. The original subrange def may have only undefed; // some lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:72,Usability,clear,clear,72,"// We may not have a defined value at this point, but still need to; // clear out any empty subranges tentatively created by; // updateRegDefUses. The original subrange def may have only undefed; // some lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:154,Deployability,update,updateRegDefUses,154,"// We know that this lane is defined by this instruction,; // but at this point it may be empty because it is not used by; // anything. This happens when updateRegDefUses adds the missing; // lanes. Assign that lane a dead def so that the interferences; // are properly modeled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:110,Modifiability,variab,variables,110,"// Record small dead def live-ranges for all the subregisters; // of the destination register.; // Otherwise, variables that live through may miss some; // interferences, thus creating invalid allocation.; // E.g., i386 code:; // %1 = somedef ; %1 GR8; // %2 = remat ; %2 GR32; // CL = COPY %2.sub_8bit; // = somedef %1 ; %1 GR8; // =>; // %1 = somedef ; %1 GR8; // dead ECX = remat ; implicit-def CL; // = somedef %1 ; %1 GR8; // %1 will see the interferences with CL but not with CH since; // no live-ranges would have been created for ECX.; // Fix that!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:51,Deployability,update,update,51,"// If the virtual SrcReg is completely eliminated, update all DBG_VALUEs; // to describe DstReg instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:90,Modifiability,variab,variables,90,"// ProcessImplicitDefs may leave some copies of <undef> values, it only; // removes local variables. When we have a copy like:; //; // %1 = COPY undef %2; //; // We delete the copy and remove the corresponding value number from %1.; // Any uses of that value number are marked as <undef>.; // Note that we do not query CoalescerPair here but redo isMoveInstr as the; // CoalescerPair may have a new register class with adjusted subreg indices; // at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:15,Usability,simpl,simple,15,"// Always join simple intervals that are defined by a single copy from a; // reserved register. This doesn't increase register pressure, so it is; // always beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:49,Availability,failure,failure,49,"// Okay, attempt to join these two intervals. On failure, this returns false.; // Otherwise, if one of the intervals being joined is a physreg, this method; // always canonicalizes DstInt to be it. The output ""SrcInt"" will not have; // been modified, so we can use this information below to update aliases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:291,Deployability,update,update,291,"// Okay, attempt to join these two intervals. On failure, this returns false.; // Otherwise, if one of the intervals being joined is a physreg, this method; // always canonicalizes DstInt to be it. The output ""SrcInt"" will not have; // been modified, so we can use this information below to update aliases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:51,Deployability,update,update,51,// Rewrite all SrcReg operands to DstReg.; // Also update DstReg operands to include DstIdx if it is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all SrcReg operands to DstReg.; // Also update DstReg operands to include DstIdx if it is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:185,Deployability,update,update,185,"// CP.getSrcReg()'s live interval has been merged into CP.getDstReg's live; // interval. Since CP.getSrcReg() is in ToBeUpdated set and its live interval; // is not up-to-date, need to update the merged live interval here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,Update,Update,3,// Update regalloc hint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:334,Integrability,depend,depends,334,// Optimization for reserved registers like ESP. We can only merge with a; // reserved physreg if RHS has a single value that is a copy of DstReg.; // The live range of the reserved register will look like a set of dead defs; // - we don't properly track the live range of reserved registers.; // Deny any overlapping intervals. This depends on all the reserved; // register live ranges to look like dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Performance,Optimiz,Optimization,3,// Optimization for reserved registers like ESP. We can only merge with a; // reserved physreg if RHS has a single value that is a copy of DstReg.; // The live range of the reserved register will look like a set of dead defs; // - we don't properly track the live range of reserved registers.; // Deny any overlapping intervals. This depends on all the reserved; // register live ranges to look like dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Safety,Abort,Abort,3,// Abort if not all the regunits are reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:2900,Safety,abort,aborted,2900,"uld become an; // identity copy after joining SrcReg and DstReg. The copy instruction will; // be removed, and the value will be merged with the source value.; //; // There can be several copies back and forth, causing many values to be; // merged into one. We compute a list of ultimate values in the joined live; // range as well as a mappings from the old value numbers.; //; // 2. IMPLICIT_DEF. This instruction is only inserted to ensure all PHI; // predecessors have a live out value. It doesn't cause real interference,; // and can be merged into the value it overlaps. Like a coalescable copy, it; // can be erased after joining.; //; // 3. Copy of external value. The overlapping def may be a copy of a value that; // is already in the other register. This is like a coalescable copy, but; // the live range of the source register must be trimmed after erasing the; // copy instruction:; //; // %src = COPY %ext; // %dst = COPY %ext <-- Remove this COPY, trim the live range of %ext.; //; // 4. Clobbering undefined lanes. Vector registers are sometimes built by; // defining one lane at a time:; //; // %dst:ssub0<def,read-undef> = FOO; // %src = BAR; // %dst:ssub1 = COPY %src; //; // The live range of %src overlaps the %dst value defined by FOO, but; // merging %src into %dst:ssub1 is only going to clobber the ssub1 lane; // which was undef anyway.; //; // The value mapping is more complicated in this case. The final live range; // will have different value numbers for both FOO and BAR, but there is no; // simple mapping from old to new values. It may even be necessary to add; // new PHI values.; //; // 5. Clobbering dead lanes. A def may clobber a lane of a vector register that; // is live, but never read. This can happen because we don't compute; // individual live ranges per lane.; //; // %dst = FOO; // %src = BAR; // %dst:ssub1 = COPY %src; //; // This kind of interference is only resolved locally. If the clobbered; // lane value escapes the block, the join is aborted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:2433,Usability,simpl,simple,2433,"uld become an; // identity copy after joining SrcReg and DstReg. The copy instruction will; // be removed, and the value will be merged with the source value.; //; // There can be several copies back and forth, causing many values to be; // merged into one. We compute a list of ultimate values in the joined live; // range as well as a mappings from the old value numbers.; //; // 2. IMPLICIT_DEF. This instruction is only inserted to ensure all PHI; // predecessors have a live out value. It doesn't cause real interference,; // and can be merged into the value it overlaps. Like a coalescable copy, it; // can be erased after joining.; //; // 3. Copy of external value. The overlapping def may be a copy of a value that; // is already in the other register. This is like a coalescable copy, but; // the live range of the source register must be trimmed after erasing the; // copy instruction:; //; // %src = COPY %ext; // %dst = COPY %ext <-- Remove this COPY, trim the live range of %ext.; //; // 4. Clobbering undefined lanes. Vector registers are sometimes built by; // defining one lane at a time:; //; // %dst:ssub0<def,read-undef> = FOO; // %src = BAR; // %dst:ssub1 = COPY %src; //; // The live range of %src overlaps the %dst value defined by FOO, but; // merging %src into %dst:ssub1 is only going to clobber the ssub1 lane; // which was undef anyway.; //; // The value mapping is more complicated in this case. The final live range; // will have different value numbers for both FOO and BAR, but there is no; // simple mapping from old to new values. It may even be necessary to add; // new PHI values.; //; // 5. Clobbering dead lanes. A def may clobber a lane of a vector register that; // is live, but never read. This can happen because we don't compute; // individual live ranges per lane.; //; // %dst = FOO; // %src = BAR; // %dst:ssub1 = COPY %src; //; // This kind of interference is only resolved locally. If the clobbered; // lane value escapes the block, the join is aborted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:16,Usability,simpl,simply,16,"/// No overlap, simply keep this value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:27,Safety,Abort,Abort,27,/// Unresolvable conflict. Abort the join.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:40,Availability,mask,masks,40,"/// Per-value info for LI. The lane bit masks are all relative to the final; /// joined register, so they can be compared directly between SrcReg and; /// DstReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:79,Safety,safe,safe,79,/// Lanes with defined values in this register. Other lanes are undef and; /// safe to clobber.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:217,Safety,safe,safely,217,/// Is this value an IMPLICIT_DEF that can be erased?; ///; /// IMPLICIT_DEF values should only exist at the end of a basic block that; /// is a predecessor to a phi-value. These IMPLICIT_DEF instructions can be; /// safely erased if they are overlapping a live value in the other live; /// interval.; ///; /// Weird control flow graphs and incomplete PHI handling in; /// ProcessImplicitDefs can very rarely create IMPLICIT_DEF values with; /// longer live ranges. Such IMPLICIT_DEF values should be treated like; /// normal values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:149,Availability,redundant,redundant,149,"/// True if this value is determined to be identical to OtherVNI; /// (in valuesIdentical). This is used with CR_Erase where the erased; /// copy is redundant, i.e. the source value is already the same as; /// the destination. In such cases the subranges need to be updated; /// properly. See comment at pruneSubRegValues for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:266,Deployability,update,updated,266,"/// True if this value is determined to be identical to OtherVNI; /// (in valuesIdentical). This is used with CR_Erase where the erased; /// copy is redundant, i.e. the source value is already the same as; /// the destination. In such cases the subranges need to be updated; /// properly. See comment at pruneSubRegValues for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:149,Safety,redund,redundant,149,"/// True if this value is determined to be identical to OtherVNI; /// (in valuesIdentical). This is used with CR_Erase where the erased; /// copy is redundant, i.e. the source value is already the same as; /// the destination. In such cases the subranges need to be updated; /// properly. See comment at pruneSubRegValues for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:126,Integrability,depend,depend,126,/// Compute the bitmask of lanes actually written by DefMI.; /// Set Redef if there are any partial register definitions that depend on the; /// previous value of the register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:663,Modifiability,extend,extend,663,"/// Assuming ValNo is going to clobber some valid lanes in Other.LR, compute; /// the extent of the tainted lanes in the block.; ///; /// Multiple values in Other.LR can be affected since partial redefinitions; /// can preserve previously tainted lanes.; ///; /// 1 %dst = VLOAD <-- Define all lanes in %dst; /// 2 %src = FOO <-- ValNo to be joined with %dst:ssub0; /// 3 %dst:ssub1 = BAR <-- Partial redef doesn't clear taint in ssub0; /// 4 %dst:ssub0 = COPY %src <-- Conflict resolved, ssub0 wasn't read; ///; /// For each ValNo in Other that is affected, add an (EndIndex, TaintedLanes); /// entry to TaintedVals.; ///; /// Returns false if the tainted lanes extend beyond the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:415,Usability,clear,clear,415,"/// Assuming ValNo is going to clobber some valid lanes in Other.LR, compute; /// the extent of the tainted lanes in the block.; ///; /// Multiple values in Other.LR can be affected since partial redefinitions; /// can preserve previously tainted lanes.; ///; /// 1 %dst = VLOAD <-- Define all lanes in %dst; /// 2 %src = FOO <-- ValNo to be joined with %dst:ssub0; /// 3 %dst:ssub1 = BAR <-- Partial redef doesn't clear taint in ssub0; /// 4 %dst:ssub0 = COPY %src <-- Conflict resolved, ssub0 wasn't read; ///; /// For each ValNo in Other that is affected, add an (EndIndex, TaintedLanes); /// entry to TaintedVals.; ///; /// Returns false if the tainted lanes extend beyond the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:27,Availability,mask,mask,27,// Transform lanemask to a mask in the joined live interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:178,Usability,clear,cleared,178,"// We normally expect IMPLICIT_DEF values to be live only until the end; // of their block. If the value is really live longer and gets pruned in; // another block, this flag is cleared again.; //; // Clearing the valid lanes is deferred until it is sure this can be; // erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:201,Usability,Clear,Clearing,201,"// We normally expect IMPLICIT_DEF values to be live only until the end; // of their block. If the value is really live longer and gets pruned in; // another block, this flag is cleared again.; //; // Clearing the valid lanes is deferred until it is sure this can be; // erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:65,Safety,Avoid,Avoid,65,"// Keep this value, check for conflicts when analyzing OtherVNI. Avoid; // revisiting OtherVNI->id in JoinVals::computeAssignment() below before it; // is assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:43,Modifiability,extend,extends,43,"// Check if OtherV is an IMPLICIT_DEF that extends beyond its basic block.; // This shouldn't normally happen, but ProcessImplicitDefs can leave such; // IMPLICIT_DEF instructions behind, and there is nothing wrong with it; // technically.; //; // When it happens, treat that IMPLICIT_DEF as a normal value, and don't try; // to erase the IMPLICIT_DEF instruction.; //; // Additionally we must keep an IMPLICIT_DEF if we're redefining an incoming; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:15,Usability,clear,clearing,15,// We deferred clearing these lanes in case we needed to save them,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:13,Usability,simpl,simple,13,// Check for simple erasable conflicts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:44,Usability,simpl,simply,44,// This may not be a real conflict if DefMI simply kills Other and defines; // VNI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:88,Safety,safe,safe,88,"// If the lanes written by this instruction were all undef in OtherVNI, it is; // still safe to join the live ranges. This can't be done with a simple value; // mapping, though - OtherVNI will map to multiple values:; //; // 1 %dst:ssub0 = FOO <-- OtherVNI; // 2 %src = BAR <-- VNI; // 3 %dst:ssub1 = COPY killed %src <-- Eliminate this copy.; // 4 BAZ killed %dst; // 5 QUUX killed %src; //; // Here OtherVNI will map to itself in [1;2), but to VNI in [2;5). CR_Replace; // handles this complex value mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:144,Usability,simpl,simple,144,"// If the lanes written by this instruction were all undef in OtherVNI, it is; // still safe to join the live ranges. This can't be done with a simple value; // mapping, though - OtherVNI will map to multiple values:; //; // 1 %dst:ssub0 = FOO <-- OtherVNI; // 2 %src = BAR <-- VNI; // 3 %dst:ssub1 = COPY killed %src <-- Eliminate this copy.; // 4 BAZ killed %dst; // 5 QUUX killed %src; //; // Here OtherVNI will map to itself in [1;2), but to VNI in [2;5). CR_Replace; // handles this complex value mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:42,Safety,Abort,Abort,42,// OtherI is pointing to a tainted value. Abort the join if the tainted; // lanes escape the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:23,Modifiability,extend,extend,23,// Tainted lanes would extend beyond the basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:183,Usability,simpl,simply,183,"// Check if we're replacing an IMPLICIT_DEF value. The IMPLICIT_DEF; // instructions are only inserted to provide a live-out value for PHI; // predecessors, so the instruction should simply go away once its value; // has been replaced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:101,Modifiability,extend,extended,101,"// Check if the segment consists of a copied live-through value (i.e. the copy; // in the block only extended the liveness, of an undef value which we may need; // to handle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:646,Availability,redundant,redundant,646,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:1474,Availability,redundant,redundant,1474,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:1753,Modifiability,extend,extended,1753,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:646,Safety,redund,redundant,646,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:1474,Safety,redund,redundant,1474,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:120,Integrability,message,message,120,"// We should trigger in all cases in which eraseInstrs() does something.; // match what eraseInstrs() is doing, print a message so",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:9,Integrability,message,message,9,// Print message so mismatches with eraseInstrs() can be diagnosed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:83,Usability,simpl,simply,83,"// If V is identical to V.OtherVNI (and S was live at OtherDef),; // then we can't simply prune V from S. V needs to be replaced; // with V.OtherVNI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:123,Modifiability,extend,extending,123,"// Remove value number i from LR.; // For intervals with subranges, removing a segment from the main range; // may require extending the previous segment: for each definition of; // a subregister, there will be a corresponding def in the main range.; // That def may fall in the middle of a segment from another subrange.; // In such cases, removing this def from the main range must be; // complemented by extending the main range to account for the liveness; // of the other subrange.; // The new end point of the main range segment to be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:407,Modifiability,extend,extending,407,"// Remove value number i from LR.; // For intervals with subranges, removing a segment from the main range; // may require extending the previous segment: for each definition of; // a subregister, there will be a corresponding def in the main range.; // That def may fall in the middle of a segment from another subrange.; // In such cases, removing this def from the main range must be; // complemented by extending the main range to account for the liveness; // of the other subrange.; // The new end point of the main range segment to be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:541,Modifiability,extend,extended,541,"// Remove value number i from LR.; // For intervals with subranges, removing a segment from the main range; // may require extending the previous segment: for each definition of; // a subregister, there will be a corresponding def in the main range.; // That def may fall in the middle of a segment from another subrange.; // In such cases, removing this def from the main range must be; // complemented by extending the main range to account for the liveness; // of the other subrange.; // The new end point of the main range segment to be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:10,Modifiability,extend,extend,10,// Do not extend beyond the end of the segment being removed.; // The segment may have been pruned in preparation for joining; // live ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:268,Availability,mask,mask,268,"// Compute NewVNInfo and resolve conflicts (see also joinVirtRegs()); // We should be able to resolve all conflicts here as we could successfully do; // it on the mainrange already. There is however a problem when multiple; // ranges get mapped to the ""overflow"" lane mask bit which creates unexpected; // interferences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:62,Safety,Detect,Detect,62,// First compute NewVNInfo and the simple value mappings.; // Detect impossible conflicts early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:35,Usability,simpl,simple,35,// First compute NewVNInfo and the simple value mappings.; // Detect impossible conflicts early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:7,Usability,clear,clear,7,"// All clear, the live ranges can be merged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:39,Availability,mask,masks,39,// Transform lanemasks from the LHS to masks in the coalesced register and; // create initial subranges if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:85,Deployability,update,update,85,"// If the RHS covers any PHI locations that were tracked for debug-info, we; // must update tracking information to reflect the join.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:366,Testability,Test,Test,366,"// Accept two kinds of subregister movement:; // * When we merge from one register class into a larger register:; // %1:gr16 = some-inst; // ->; // %2:gr32.sub_16bit = some-inst; // * When the PHI is already in a subregister, and the larger class; // is coalesced:; // %2:gr32.sub_16bit = some-inst; // %3:gr32 = COPY %2; // ->; // %3:gr32.sub_16bit = some-inst; // Test for subregister move:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:115,Modifiability,variab,variable,115,"// If we're moving between different subregisters, ignore this join.; // The PHI will not get a location, dropping variable locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,Update,Update,3,// Update our tracking of where the PHI is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:71,Deployability,update,update,71,"// If we merge into a sub-register of a larger class (test above),; // update SubReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:54,Testability,test,test,54,"// If we merge into a sub-register of a larger class (test above),; // update SubReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:99,Usability,simpl,simply,99,"// Kill flags are going to be wrong if the live ranges were overlapping.; // Eventually, we should simply clear all kill flags when computing live; // ranges. They are reinserted after register allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:106,Usability,clear,clear,106,"// Kill flags are going to be wrong if the live ranges were overlapping.; // Eventually, we should simply clear all kill flags when computing live; // ranges. They are reinserted after register allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:20,Deployability,update,updates,20,// Scan for unsound updates of both the source and destination register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:75,Safety,safe,safely,75,"// If the ""Other"" register is live at a slot Idx, test whether Reg can; // safely be merged with it, or should be marked undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:50,Testability,test,test,50,"// If the ""Other"" register is live at a slot Idx, test whether Reg can; // safely be merged with it, or should be marked undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:18,Performance,perform,performance,18,"// Our worst-case performance typically happens with asan, causing very; // many DBG_VALUEs of the same location. Cache a copy of the most recent; // result for this edge-case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:114,Performance,Cache,Cache,114,"// Our worst-case performance typically happens with asan, causing very; // many DBG_VALUEs of the same location. Cache a copy of the most recent; // result for this edge-case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:258,Availability,redundant,redundant,258,"// Both the registers were live: examine the conflict resolution record for; // the value number Reg refers to. CR_Keep meant that this value number; // ""won"" and the merged register definitely refers to that value. CR_Erase; // means the value number was a redundant copy of the other value, which; // was coalesced and Reg deleted. It's safe to refer to the other register; // (which will be the source of the copy).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:258,Safety,redund,redundant,258,"// Both the registers were live: examine the conflict resolution record for; // the value number Reg refers to. CR_Keep meant that this value number; // ""won"" and the merged register definitely refers to that value. CR_Erase; // means the value number was a redundant copy of the other value, which; // was coalesced and Reg deleted. It's safe to refer to the other register; // (which will be the source of the copy).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:339,Safety,safe,safe,339,"// Both the registers were live: examine the conflict resolution record for; // the value number Reg refers to. CR_Keep meant that this value number; // ""won"" and the merged register definitely refers to that value. CR_Erase; // means the value number was a redundant copy of the other value, which; // was coalesced and Reg deleted. It's safe to refer to the other register; // (which will be the source of the copy).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:52,Testability,test,test,52,"// ""Other"" is live and there is a DBG_VALUE of Reg: test if we should; // set it undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:49,Safety,avoid,avoid,49,"// Mark undef, erase record of this DBG_VALUE to avoid revisiting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Usability,Clear,Clear,3,// Clear instructions not recorded in `ErasedInstrs` but erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:110,Deployability,update,update,110,"// Technically we should check if the weight of the new copy is; // interesting compared to the other one and update the weight; // of the copies accordingly. However, this would only work if; // we would gather all the copies first then coalesce, whereas; // right now we interleave both actions.; // For now, just consider the copies that are in the same block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Variab,Variables,3,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:142,Modifiability,variab,variable,142,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:321,Modifiability,variab,variables,321,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:288,Safety,avoid,avoid,288,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:336,Safety,predict,predictable,336,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:170,Performance,optimiz,optimization,170,// The MachineScheduler does not currently require JoinSplitEdges. This will; // either be enabled unconditionally or replaced by a more general live range; // splitting optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:21,Deployability,update,update,21,"// After coalescing, update any PHIs that are being tracked by debug-info; // with their new VReg locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h:49,Integrability,Interface,Interface,49,"//===- RegisterCoalescer.h - Register Coalescing Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the abstract interface for register coalescers,; // allowing them to interact with and query register allocators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h:415,Integrability,interface,interface,415,"//===- RegisterCoalescer.h - Register Coalescing Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the abstract interface for register coalescers,; // allowing them to interact with and query register allocators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:2,Testability,assert,assert,2,"//assert((NewMask & !PrevMask) == 0 && ""Must not add bits"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:4,Usability,Clear,Clear,4,/// Clear the result so it can be used for another round of pressure tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:4,Usability,Clear,Clear,4,/// Clear the result so it can be used for another round of pressure tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:144,Deployability,update,update,144,"/// If the current top is not less than or equal to the next index, open it.; /// We happen to need the SlotIndex for the next top for pressure update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,Availability,redundant,redundant,10,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,Safety,redund,redundant,10,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,Availability,redundant,redundant,10,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,Safety,redund,redundant,10,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:3,Deployability,Update,Update,3,// Update the units for this pressure set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:132,Integrability,interface,interface,132,"/// Record the upward impact of a single instruction on current register; /// pressure. Unlike the advance/recede pressure tracking interface, this does; /// not discover live in/outs.; ///; /// This is intended for speculative queries. It leaves pressure inconsistent; /// with the current position, so must be restored by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:700,Performance,cache,cache,700,"/// Consider the pressure increase caused by traversing this instruction; /// bottom-up. Find the pressure set with the most change beyond its pressure; /// limit based on the tracker's current pressure, and return the change in; /// number of register units of that pressure set introduced by this; /// instruction.; ///; /// This assumes that the current LiveOut set is sufficient.; ///; /// This is expensive for an on-the-fly query because it calls; /// bumpUpwardPressure to recompute the pressure sets based on current; /// liveness. This mainly exists to verify correctness, e.g. with; /// -verify-misched. getUpwardPressureDelta is the fast version of this query; /// that uses the per-SUnit cache of the PressureDiff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:87,Integrability,depend,depend,87,"/// This is the fast version of querying register pressure that does not; /// directly depend on current liveness.; ///; /// @param Delta captures information needed for heuristics.; ///; /// @param CriticalPSets Are the pressure sets that are known to exceed some; /// limit within the region, not necessarily at the current position.; ///; /// @param MaxPressureLimit Is the max pressure within the region, not; /// necessarily at the current position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:15,Availability,down,downward,15,"/// Record the downward impact of a single instruction on current register; /// pressure. Unlike the advance/recede pressure tracking interface, this does; /// not discover live in/outs.; ///; /// This is intended for speculative queries. It leaves pressure inconsistent; /// with the current position, so must be restored by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:134,Integrability,interface,interface,134,"/// Record the downward impact of a single instruction on current register; /// pressure. Unlike the advance/recede pressure tracking interface, this does; /// not discover live in/outs.; ///; /// This is intended for speculative queries. It leaves pressure inconsistent; /// with the current position, so must be restored by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:100,Availability,down,down,100,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:109,Energy Efficiency,schedul,schedule,109,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:280,Energy Efficiency,schedul,scheduled,280,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:293,Safety,avoid,avoid,293,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:82,Availability,down,down,82,"/// Consider the pressure increase caused by traversing this instruction; /// top-down. Find the register class with the most change in its pressure limit; /// based on the tracker's current pressure, and return the number of excess; /// register units of that pressure set introduced by this instruction.; ///; /// This assumes that the current LiveIn set is sufficient.; ///; /// This is expensive for an on-the-fly query because it calls; /// bumpDownwardPressure to recompute the pressure sets based on current; /// liveness. We don't yet have a fast version of downward pressure tracking; /// analogous to getUpwardPressureDelta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:566,Availability,down,downward,566,"/// Consider the pressure increase caused by traversing this instruction; /// top-down. Find the register class with the most change in its pressure limit; /// based on the tracker's current pressure, and return the number of excess; /// register units of that pressure set introduced by this instruction.; ///; /// This assumes that the current LiveIn set is sufficient.; ///; /// This is expensive for an on-the-fly query because it calls; /// bumpDownwardPressure to recompute the pressure sets based on current; /// liveness. We don't yet have a fast version of downward pressure tracking; /// analogous to getUpwardPressureDelta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:72,Availability,down,down,72,/// Get the pressure of each PSet after traversing this instruction top-down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:598,Availability,avail,available,598,"//===- RegisterScavenging.cpp - Machine register scavenging ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements the machine register scavenger. It can provide; /// information, such as unused registers, at any point in a machine basic; /// block. It also provides a mechanism to make registers available by evicting; /// them to spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:27,Availability,Avail,Available,27,/// Given the bitvector \p Available of free register units at position; /// \p From. Search backwards to find a register that is part of \p; /// Candidates and not used/clobbered until the point \p To. If there is; /// multiple candidates continue searching and pick the one that is not used/; /// clobbered for the longest time.; /// Returns the register and the earliest position we know it to be free or; /// the position MBB.end() if no register is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:454,Availability,avail,available,454,/// Given the bitvector \p Available of free register units at position; /// \p From. Search backwards to find a register that is part of \p; /// Candidates and not used/clobbered until the point \p To. If there is; /// multiple candidates continue searching and pick the one that is not used/; /// clobbered for the longest time.; /// Returns the register and the earliest position we know it to be free or; /// the position MBB.end() if no register is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:11,Availability,avail,available,11,// Find an available scavenging slot with size and alignment matching; // the requirements of the class RC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:3,Safety,Avoid,Avoid,3,"// Avoid wasting slots with large size and/or large alignment. Pick one; // that is the best fit for this register class (in street metric).; // Picking a larger slot than necessary could happen if a slot for a; // larger register is reserved before a slot for a smaller one. When; // trying to spill a smaller register, the large slot would be found; // first, thus making it impossible to spill the larger register later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:111,Testability,assert,assert,111,"// We need to scavenge a register but have no spill slot, the target; // must know how to do it (if not, we'll assert below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:3,Safety,Avoid,Avoid,3,// Avoid infinite regress,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:12,Availability,avail,available,12,// Found an available register?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate a register for the virtual register \p VReg. The last use of; /// \p VReg is around the current position of the register scavenger \p RS.; /// \p ReserveAfter controls whether the scavenged register needs to be reserved; /// after the current instruction, otherwise it will only be reserved before the; /// current instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate (scavenge) vregs inside a single basic block.; /// Returns true if the target spill callback created new vregs and a 2nd pass; /// is necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:71,Usability,simpl,simply,71,"// FIXME: Iterating over the instruction stream is unnecessary. We can simply; // iterate over the vreg use list, which at this point only contains machine; // operands for which eliminateFrameIndex need a new scratch reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:103,Testability,test,testing,103,/// This class runs register scavenging independ of the PrologEpilogInserter.; /// This is used in for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp:512,Usability,simpl,simple,512,"//===-- RegUsageInfoCollector.cpp - Register Usage Information Collector --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass is simple MachineFunction pass which collects register usage; /// details by iterating through each physical registers and checking; /// MRI::isPhysRegUsed() then creates a RegMask based on this details.; /// The pass then stores this RegMask in PhysicalRegisterUsageInfo.cpp; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp:115,Performance,optimiz,optimizations,115,"// TODO: Move to hook somwehere?; // Return true if it is useful to track the used registers for IPRA / no CSR; // optimizations. This is not useful for entry points, and computing the; // register usage information is expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp:167,Modifiability,Rewrite,Rewrite,167,// Scan all the physical registers. When a register is defined in the current; // function set it and all the aliasing registers as defined in the regmask.; // FIXME: Rewrite to use regunits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp:739,Availability,avail,available,739,"//=--- RegUsageInfoPropagate.cpp - Register Usage Informartion Propagation --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass iterates through MachineInstrs in a given MachineFunction and at; /// each callsite queries RegisterUsageInfo for RegMask (calculated based on; /// actual register allocation) of the callee function, if the RegMask detail; /// is available then this pass will update the RegMask of the call instruction.; /// This updated RegMask will be used by the register allocator while allocating; /// the current MachineFunction.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp:769,Deployability,update,update,769,"//=--- RegUsageInfoPropagate.cpp - Register Usage Informartion Propagation --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass iterates through MachineInstrs in a given MachineFunction and at; /// each callsite queries RegisterUsageInfo for RegMask (calculated based on; /// actual register allocation) of the callee function, if the RegMask detail; /// is available then this pass will update the RegMask of the call instruction.; /// This updated RegMask will be used by the register allocator while allocating; /// the current MachineFunction.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp:823,Deployability,update,updated,823,"//=--- RegUsageInfoPropagate.cpp - Register Usage Informartion Propagation --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass iterates through MachineInstrs in a given MachineFunction and at; /// each callsite queries RegisterUsageInfo for RegMask (calculated based on; /// actual register allocation) of the callee function, if the RegMask detail; /// is available then this pass will update the RegMask of the call instruction.; /// This updated RegMask will be used by the register allocator while allocating; /// the current MachineFunction.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:47,Availability,Redundant,Redundant,47,"//===- RemoveRedundantDebugValues.cpp - Remove Redundant Debug Value MIs --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:47,Safety,Redund,Redundant,47,"//===- RemoveRedundantDebugValues.cpp - Remove Redundant Debug Value MIs --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:95,Availability,redundant,redundant,95,/// \file RemoveRedundantDebugValues.cpp; ///; /// The RemoveRedundantDebugValues pass removes redundant DBG_VALUEs that; /// appear in MIR after the register allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:95,Safety,redund,redundant,95,/// \file RemoveRedundantDebugValues.cpp; ///; /// The RemoveRedundantDebugValues pass removes redundant DBG_VALUEs that; /// appear in MIR after the register allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:11,Availability,redundant,redundant,11,/// Remove redundant debug value MIs for the given machine function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:11,Safety,redund,redundant,11,/// Remove redundant debug value MIs for the given machine function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,Availability,redundant,redundant,32,"// This analysis aims to remove redundant DBG_VALUEs by going forward; // in the basic block by considering the first DBG_VALUE as a valid; // until its first (location) operand is not clobbered/modified.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) <block of code that does affect $edi>; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (3).; // TODO: Support DBG_VALUE_LIST and other debug instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,Safety,redund,redundant,32,"// This analysis aims to remove redundant DBG_VALUEs by going forward; // in the basic block by considering the first DBG_VALUE as a valid; // until its first (location) operand is not clobbered/modified.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) <block of code that does affect $edi>; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (3).; // TODO: Support DBG_VALUE_LIST and other debug instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:27,Modifiability,variab,variable,27,"// Just stop tracking this variable, until we cover DBG_VALUE_LIST.; // 1 DBG_VALUE $rax, ""x"", DIExpression(); // ...; // 2 DBG_VALUE_LIST ""x"", DIExpression(...), $rax, $rbx; // ...; // 3 DBG_VALUE $rax, ""x"", DIExpression()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:51,Modifiability,variab,variable,51,"// If it's not a register, just stop tracking such variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:35,Modifiability,variab,variable,35,// We have found a new value for a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,Availability,redundant,redundant,32,"// This analysis aims to remove redundant DBG_VALUEs by going backward; // in the basic block and removing all but the last DBG_VALUE for any; // given variable in a set of consecutive DBG_VALUE instructions.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) DBG_VALUE $esi, !""var2"", ...; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:152,Modifiability,variab,variable,152,"// This analysis aims to remove redundant DBG_VALUEs by going backward; // in the basic block and removing all but the last DBG_VALUE for any; // given variable in a set of consecutive DBG_VALUE instructions.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) DBG_VALUE $esi, !""var2"", ...; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,Safety,redund,redundant,32,"// This analysis aims to remove redundant DBG_VALUEs by going backward; // in the basic block and removing all but the last DBG_VALUE for any; // given variable in a set of consecutive DBG_VALUE instructions.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) DBG_VALUE $esi, !""var2"", ...; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:138,Availability,redundant,redundant,138,"// If it is a DBG_VALUE describing a constant as:; // DBG_VALUE 0, ...; // we just don't consider such instructions as candidates; // for redundant removal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:138,Safety,redund,redundant,138,"// If it is a DBG_VALUE describing a constant as:; // DBG_VALUE 0, ...; // we just don't consider such instructions as candidates; // for redundant removal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:39,Modifiability,variab,variable,39,"// If we have already encountered this variable, just stop; // tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:50,Modifiability,variab,variable,50,"// We have already encountered the value for this variable,; // so this one can be deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite Machine Operands to use the new vreg belonging to their class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:108,Performance,perform,perform,108,"// Shortcut: With only 1 subrange, the normal separate component tests are; // enough and we do not need to perform the union-find on the subregister; // segments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:65,Testability,test,tests,65,"// Shortcut: With only 1 subrange, the normal separate component tests are; // enough and we do not need to perform the union-find on the subregister; // segments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:85,Deployability,update,updated,85,"/// Undef use operands are not tracked in the equivalence class,; /// but need to be updated if they are tied; take care to only; /// update the tied operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:134,Deployability,update,update,134,"/// Undef use operands are not tracked in the equivalence class,; /// but need to be updated if they are tied; take care to only; /// update the tied operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:598,Integrability,interface,interface,598,"//=== ReplaceWithVeclib.cpp - Replace vector intrinsics with veclib calls -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Replaces LLVM IR instructions with vector operands (i.e., the frem; // instruction or calls to LLVM intrinsics) with matching calls to functions; // from a vector library (e.g libmvec, SVML) using TargetLibraryInfo interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:91,Integrability,Inject,InjectTLIMappings,91,"// Add the freshly created function to llvm.compiler.used, similar to as it; // is done in InjectTLIMappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:91,Security,Inject,InjectTLIMappings,91,"// Add the freshly created function to llvm.compiler.used, similar to as it; // is done in InjectTLIMappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:113,Availability,avail,available,113,"/// Returns true when successfully replaced \p I with a suitable function taking; /// vector arguments, based on available mappings in the \p TLI. Currently only; /// works when \p I is a call to vectorized intrinsic or the frem instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:174,Availability,mask,masked,174,"// Try to find the mapping for the scalar version of this intrinsic and the; // exact vector width of the call operands in the TargetLibraryInfo. First,; // check with a non-masked variant, and if that fails try with a masked one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:219,Availability,mask,masked,219,"// Try to find the mapping for the scalar version of this intrinsic and the; // exact vector width of the call operands in the TargetLibraryInfo. First,; // check with a non-masked variant, and if that fails try with a masked one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:2,Availability,Mask,Masked,2,/*Masked*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:2,Availability,Mask,Masked,2,/*Masked*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ResetMachineFunctionPass.cpp:22,Safety,abort,abort,22,/// Whether we should abort immediately instead of resetting the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ResetMachineFunctionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ResetMachineFunctionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:497,Energy Efficiency,allocate,allocated,497,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:7,Safety,Safe,SafeStack,7,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:23,Safety,Safe,Safe,23,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:419,Safety,safe,safe,419,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:472,Safety,unsafe,unsafe,472,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:596,Safety,Safe,SafeStack,596,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:108,Safety,safe,safe,108,// namespace llvm; /// Use __safestack_pointer_address even if the platform has a faster way of; /// access safe stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:101,Security,access,access,101,// namespace llvm; /// Use __safestack_pointer_address even if the platform has a faster way of; /// access safe stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:224,Modifiability,variab,variables,224,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:8,Safety,Safe,SafeStack,8,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:66,Safety,safe,safe,66,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:121,Safety,safe,safe,121,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:180,Safety,unsafe,unsafe,180,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:291,Safety,safe,safe,291,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:97,Security,access,accessed,97,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:243,Security,access,accessed,243,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:4,Safety,Unsafe,Unsafe,4,/// Unsafe stack alignment. Each stack frame must ensure that the stack is; /// aligned to this value. We need to re-align the unsafe stack if the; /// alignment of any object on the stack exceeds this value.; ///; /// 16 seems like a reasonable upper bound on the alignment of objects that we; /// might expect to appear on the stack on most common targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:127,Safety,unsafe,unsafe,127,/// Unsafe stack alignment. Each stack frame must ensure that the stack is; /// aligned to this value. We need to re-align the unsafe stack if the; /// alignment of any object on the stack exceeds this value.; ///; /// 16 seems like a reasonable upper bound on the alignment of objects that we; /// might expect to appear on the stack on most common targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:34,Deployability,canary,canary,34,/// Return the value of the stack canary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:4,Performance,Load,Load,4,/// Load stack guard from the frame and check if it has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:222,Energy Efficiency,allocate,allocated,222,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:107,Safety,unsafe,unsafe,107,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:168,Safety,unsafe,unsafe,168,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:191,Safety,unsafe,unsafe,191,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:128,Modifiability,variab,variable,128,/// Generate code to restore the stack after all stack restore points; /// in \p StackRestorePoints.; ///; /// \returns A local variable in which to maintain the dynamic top of the; /// unsafe stack if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:186,Safety,unsafe,unsafe,186,/// Generate code to restore the stack after all stack restore points; /// in \p StackRestorePoints.; ///; /// \returns A local variable in which to maintain the dynamic top of the; /// unsafe stack if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:58,Energy Efficiency,allocate,allocate,58,/// Replace all allocas in \p DynamicAllocas with code to allocate; /// space dynamically on the unsafe stack and store the dynamic unsafe stack; /// top to \p DynamicTop if non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:97,Safety,unsafe,unsafe,97,/// Replace all allocas in \p DynamicAllocas with code to allocate; /// space dynamically on the unsafe stack and store the dynamic unsafe stack; /// top to \p DynamicTop if non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:132,Safety,unsafe,unsafe,132,/// Replace all allocas in \p DynamicAllocas with code to allocate; /// space dynamically on the unsafe stack and store the dynamic unsafe stack; /// top to \p DynamicTop if non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:24,Safety,unsafe,unsafe,24,// Non-constant size => unsafe. FIXME: try SCEV getRange.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:56,Safety,safe,safe,56,/// Check whether a given allocation must be put on the safe; /// stack or not. The function analyzes all uses of AI and checks whether it is; /// only accessed in a memory safe way (as decided statically).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:173,Safety,safe,safe,173,/// Check whether a given allocation must be put on the safe; /// stack or not. The function analyzes all uses of AI and checks whether it is; /// only accessed in a memory safe way (as decided statically).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:152,Security,access,accessed,152,/// Check whether a given allocation must be put on the safe; /// stack or not. The function analyzes all uses of AI and checks whether it is; /// only accessed in a memory safe way (as decided statically).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:80,Energy Efficiency,allocate,allocated,80,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:131,Safety,safe,safe,131,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:184,Safety,safe,safe,184,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:60,Security,access,accesses,60,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:30,Safety,safe,safe,30,"// ""va-arg"" from a pointer is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:56,Safety,unsafe,unsafe,56,// Stored the pointer - conservatively assume it may be unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:234,Safety,safe,safe,234,"// LLVM 'nocapture' attribute is only set for arguments whose address; // is not stored, passed around, or used in any other non-trivial way.; // We assume that passing a pointer to an object as a 'nocapture; // readnone' argument is safe.; // FIXME: a more precise solution would require an interprocedural; // analysis here, which would look at all uses of an argument inside; // the function being called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:30,Safety,safe,safe,30,"// All uses of the alloca are safe, we can place it on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:59,Safety,safe,safe,59,"// All uses of the alloca are safe, we can place it on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:174,Modifiability,variab,variable,174,"/// We explicitly compute and set the unsafe stack layout for all unsafe; /// static alloca instructions. We save the unsafe ""base pointer"" in the; /// prologue into a local variable and restore it in the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:38,Safety,unsafe,unsafe,38,"/// We explicitly compute and set the unsafe stack layout for all unsafe; /// static alloca instructions. We save the unsafe ""base pointer"" in the; /// prologue into a local variable and restore it in the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:66,Safety,unsafe,unsafe,66,"/// We explicitly compute and set the unsafe stack layout for all unsafe; /// static alloca instructions. We save the unsafe ""base pointer"" in the; /// prologue into a local variable and restore it in the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:118,Safety,unsafe,unsafe,118,"/// We explicitly compute and set the unsafe stack layout for all unsafe; /// static alloca instructions. We save the unsafe ""base pointer"" in the; /// prologue into a local variable and restore it in the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:29,Availability,down,down,29,// Unsafe stack always grows down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Safety,Unsafe,Unsafe,3,// Unsafe stack always grows down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for every unsafe static AllocaInst on the unsafe stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:28,Safety,unsafe,unsafe,28,// Allocate space for every unsafe static AllocaInst on the unsafe stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:60,Safety,unsafe,unsafe,60,// Allocate space for every unsafe static AllocaInst on the unsafe stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:88,Deployability,update,updated,88,"// PHI nodes may have multiple incoming edges from the same BB (why??),; // all must be updated at once with the same incoming value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:104,Deployability,update,update,104,// Re-align BasePointer so that our callees would see it aligned as; // expected.; // FIXME: no need to update BasePointer in leaf functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Deployability,Update,Update,3,// Update shadow stack pointer in the function epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:168,Safety,unsafe,unsafe,168,"// Collect all points where stack gets unwound and needs to be restored; // This is only necessary because the runtime (setjmp and unwind code) is; // not aware of the unsafe stack and won't unwind/restore it properly.; // To work around this problem without changing the runtime, we insert; // instrumentation to restore the unsafe stack pointer when necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:326,Safety,unsafe,unsafe,326,"// Collect all points where stack gets unwound and needs to be restored; // This is only necessary because the runtime (setjmp and unwind code) is; // not aware of the unsafe stack and won't unwind/restore it properly.; // To work around this problem without changing the runtime, we insert; // instrumentation to restore the unsafe stack pointer when necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:81,Safety,unsafe,unsafe,81,"// Find all static and dynamic alloca instructions that must be moved to the; // unsafe stack, all return instructions and stack restore points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:25,Safety,unsafe,unsafe,25,// This function has the unsafe stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Performance,Load,Load,3,// Load the current stack pointer (we'll also use it as a base pointer).; // FIXME: use a dedicated register for it ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:71,Energy Efficiency,allocate,allocated,71,// The top of the unsafe stack after all unsafe static allocas are; // allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:18,Safety,unsafe,unsafe,18,// The top of the unsafe stack after all unsafe static allocas are; // allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:41,Safety,unsafe,unsafe,41,// The top of the unsafe stack after all unsafe static allocas are; // allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:69,Deployability,update,updated,69,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:132,Energy Efficiency,allocate,allocated,132,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Safety,Safe,Safe,3,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:45,Safety,unsafe,unsafe,45,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:84,Safety,unsafe,unsafe,84,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:333,Safety,unsafe,unsafe,333,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:15,Safety,unsafe,unsafe,15,// Restore the unsafe stack pointer before each return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:117,Safety,avoid,avoid,117,"// Do we already have a DominatorTree avaliable from the previous pass?; // Note that we should *NOT* require it, to avoid the case where we end up; // not needing it, but the legacy PM would have computed it for us anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:7,Safety,Safe,SafeStackLayout,7,"//===- SafeStackLayout.cpp - SafeStack frame layout -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:29,Safety,Safe,SafeStack,29,"//===- SafeStackLayout.cpp - SafeStack frame layout -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:3,Deployability,Update,Update,3,// Update live ranges for all affected regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:296,Energy Efficiency,reduce,reduce,296,"// Simple greedy algorithm.; // If this is replaced with something smarter, it must preserve the property; // that the first object is always at the offset 0 in the stack frame (for; // StackProtectorSlot), or handle stack protector in some other way.; // Sort objects by size (largest first) to reduce fragmentation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:3,Usability,Simpl,Simple,3,"// Simple greedy algorithm.; // If this is replaced with something smarter, it must preserve the property; // that the first object is always at the offset 0 in the stack frame (for; // StackProtectorSlot), or handle stack protector in some other way.; // Sort objects by size (largest first) to reduce fragmentation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:7,Safety,Safe,SafeStackLayout,7,"//===- SafeStackLayout.h - SafeStack frame layout --------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:27,Safety,Safe,SafeStack,27,"//===- SafeStackLayout.h - SafeStack frame layout --------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:29,Safety,unsafe,unsafe,29,/// Compute the layout of an unsafe stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:17,Safety,safe,safestack,17,// end namespace safestack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp:7,Security,Sanitiz,SanitizerBinaryMetadata,7,"//===- SanitizerBinaryMetadata.cpp; //----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp:415,Security,Sanitiz,SanitizerBinaryMetadata,415,"//===- SanitizerBinaryMetadata.cpp; //----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp:18,Deployability,update,update,18,"// Non-zero size, update metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:7,Energy Efficiency,Schedul,ScheduleDAG,7,"//===- ScheduleDAG.cpp - Implement the ScheduleDAG class ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is a base class used by; /// scheduling implementation classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:39,Energy Efficiency,Schedul,ScheduleDAG,39,"//===- ScheduleDAG.cpp - Implement the ScheduleDAG class ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is a base class used by; /// scheduling implementation classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:405,Energy Efficiency,Schedul,ScheduleDAG,405,"//===- ScheduleDAG.cpp - Implement the ScheduleDAG class ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is a base class used by; /// scheduling implementation classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:459,Energy Efficiency,schedul,scheduling,459,"//===- ScheduleDAG.cpp - Implement the ScheduleDAG class ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is a base class used by; /// scheduling implementation classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:57,Availability,redundant,redundant,57,"// If this node already has this dependence, don't add a redundant one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:33,Integrability,depend,dependence,33,"// If this node already has this dependence, don't add a redundant one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:57,Safety,redund,redundant,57,"// If this node already has this dependence, don't add a redundant one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:8,Performance,latency,latency,8,// Zero-latency weak edges may be added purely for heuristic ordering. Don't; // add them if another kind of edge already exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:3,Modifiability,Extend,Extend,3,// Extend the latency if needed. Equivalent to; // removePred(PredDep) + addPred(D).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:14,Performance,latency,latency,14,// Extend the latency if needed. Equivalent to; // removePred(PredDep) + addPred(D).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:3,Deployability,Update,Update,3,// Update the bookkeeping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:3,Deployability,Update,Update,3,// Update the bookkeeping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:1241,Deployability,update,updates,1241,"// The idea of the algorithm is taken from; // ""Online algorithms for managing the topological order of; // a directed acyclic graph"" by David J. Pearce and Paul H.J. Kelly; // This is the MNR algorithm, which was first introduced by; // A. Marchetti-Spaccamela, U. Nanni and H. Rohnert in; // ""Maintaining a topological order under edge insertions"".; //; // Short description of the algorithm:; //; // Topological ordering, ord, of a DAG maps each node to a topological; // index so that for all edges X->Y it is the case that ord(X) < ord(Y).; //; // This means that if there is a path from the node X to the node Z,; // then ord(X) < ord(Z).; //; // This property can be used to check for reachability of nodes:; // if Z is reachable from X, then an insertion of the edge Z->X would; // create a cycle.; //; // The algorithm first computes a topological ordering for the DAG by; // initializing the Index2Node and Node2Index arrays and then tries to keep; // the ordering up-to-date after edge insertions by reordering the DAG.; //; // On insertion of the edge X->Y, the algorithm first marks by calling DFS; // the nodes reachable from Y, and then shifts them using Shift to lie; // immediately after X in Index2Node.; // Cancel pending updates, mark as valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:24,Integrability,depend,dependencies,24,// Is it a node without dependencies?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:10,Integrability,depend,dependencies,10,"// If all dependencies of the node are processed already,; // then the node can be computed now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:19,Deployability,update,updates,19,// Otherwise apply updates one-by-one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:81,Deployability,update,updates,81,// Recomputing the order from scratch is likely more efficient than applying; // updates one-by-one for too many updates. The current cut-off is arbitrarily; // chosen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:113,Deployability,update,updates,113,// Recomputing the order from scratch is likely more efficient than applying; // updates one-by-one for too many updates. The current cut-off is arbitrarily; // chosen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:53,Energy Efficiency,efficient,efficient,53,// Recomputing the order from scratch is likely more efficient than applying; // updates one-by-one for too many updates. The current cut-off is arbitrarily; // chosen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:3,Deployability,Update,Update,3,// Update the topological order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:10,Energy Efficiency,Schedul,ScheduleDAGInstrs,10,"//===---- ScheduleDAGInstrs.cpp - MachineInstr Rescheduling ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This implements the ScheduleDAGInstrs class, which implements; /// re-scheduling of MachineInstrs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:410,Energy Efficiency,Schedul,ScheduleDAGInstrs,410,"//===---- ScheduleDAGInstrs.cpp - MachineInstr Rescheduling ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This implements the ScheduleDAGInstrs class, which implements; /// re-scheduling of MachineInstrs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:460,Energy Efficiency,schedul,scheduling,460,"//===---- ScheduleDAGInstrs.cpp - MachineInstr Rescheduling ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This implements the ScheduleDAGInstrs class, which implements; /// re-scheduling of MachineInstrs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:209,Performance,Load,Loads,209,"// Note: the two options below might be used in tuning compile time vs; // output quality. Setting HugeRegion so large that it will never be; // reached means best-effort, but may be slow.; // When Stores and Loads maps (or NonAliasStores and NonAliasLoads); // together hold this many SUs, a reduction of maps will be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:10,Energy Efficiency,reduce,reduce,10,"// Always reduce a huge region with half of the elements, except; // when user sets this number explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:7,Integrability,depend,dependencies,7,// Add dependencies on the defs and uses of the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:90,Integrability,depend,dependencies,90,/// MO is an operand of SU's instruction that defines a physical register. Adds; /// data dependencies from SU to any uses of the physical register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:25,Performance,latency,latency,25,"// Only use any non-zero latency for real defs/uses, in contrast to; // ""fake"" operands added by regalloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependence,14,"// Adjust the dependence latency using operand def/use information,; // then allow the target to perform its own adjustments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:25,Performance,latency,latency,25,"// Adjust the dependence latency using operand def/use information,; // then allow the target to perform its own adjustments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:97,Performance,perform,perform,97,"// Adjust the dependence latency using operand def/use information,; // then allow the target to perform its own adjustments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:79,Energy Efficiency,schedul,scheduling,79,// Set the hasPhysRegDefs only for physreg defs that have a use within; // the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:115,Energy Efficiency,schedul,scheduling,115,"/// Adds register dependencies (data, anti, and output) from this SUnit; /// to following instructions in the same scheduling region that depend the; /// physical register referenced at OperIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:18,Integrability,depend,dependencies,18,"/// Adds register dependencies (data, anti, and output) from this SUnit; /// to following instructions in the same scheduling region that depend the; /// physical register referenced at OperIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:138,Integrability,depend,depend,138,"/// Adds register dependencies (data, anti, and output) from this SUnit; /// to following instructions in the same scheduling region that depend the; /// physical register referenced at OperIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:31,Integrability,depend,dependencies,31,// We do not need to track any dependencies for constant registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:34,Integrability,depend,dependencies,34,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:61,Integrability,depend,dependencies,61,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:279,Integrability,depend,dependencies,279,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:83,Performance,latency,latency,83,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:250,Performance,latency,latency,250,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Usability,Clear,Clear,3,// Clear previous uses and defs of this register and its subregisters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:48,Integrability,depend,dependencies,48,"// Calls will not be reordered because of chain dependencies (see; // below). Since call operands are dead, calls may continue to be added; // to the DefList making dependence checking quadratic in the size of; // the block. Instead, we leave only one call at the back of the; // DefList.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:165,Integrability,depend,dependence,165,"// Calls will not be reordered because of chain dependencies (see; // below). Since call operands are dead, calls may continue to be added; // to the DefList making dependence checking quadratic in the size of; // the block. Instead, we leave only one call at the back of the; // DefList.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:113,Energy Efficiency,schedul,scheduling,113,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:312,Energy Efficiency,schedul,scheduling,312,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:34,Integrability,depend,dependencies,34,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:244,Modifiability,variab,variable,244,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Usability,Clear,Clear,3,"// Clear undef flag, we'll re-add it later once we know which subregister; // Def is first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:12,Integrability,depend,dependence,12,// Add data dependence to all uses we found so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:58,Integrability,depend,dependencies,58,// Shortcut: Singly defined vregs do not have output/anti dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:153,Availability,redundant,redundant,153,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:326,Energy Efficiency,schedul,scheduling,326,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependence,14,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:115,Integrability,depend,dependence,115,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:349,Integrability,depend,dependence,349,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:394,Performance,latency,latency,394,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:418,Performance,latency,latency,418,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:153,Safety,redund,redundant,153,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:17,Integrability,depend,dependence,17,// Add an output dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:277,Security,access,access,277,"// Ignore additional defs of the same lanes in one instruction. This can; // happen because lanemasks are shared for targets with too many; // subregisters. We also use some representration tricks/hacks where we; // add super-register defs/uses, to imply that although we only access parts; // of the reg we care about the full one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Deployability,Update,Update,3,// Update current definition. This can get tricky if the def was about a; // bigger lanemask before. We then have to shrink it and create a new; // VReg2SUnit for the non-overlapping part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:234,Energy Efficiency,schedul,scheduling,234,"/// Adds a register data dependency if the instruction that defines the; /// virtual register used at OperIdx is mapped to an SUnit. Add a register; /// antidependency from this SUnit to instructions that occur later in the same; /// scheduling region if they write the virtual register.; ///; /// TODO: Handle ExitSU ""uses"" properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:25,Integrability,depend,dependency,25,"/// Adds a register data dependency if the instruction that defines the; /// virtual register used at OperIdx is mapped to an SUnit. Add a register; /// antidependency from this SUnit to instructions that occur later in the same; /// scheduling region if they write the virtual register.; ///; /// TODO: Handle ExitSU ""uses"" properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:26,Integrability,depend,dependencies,26,// Remember the use. Data dependencies will be added when we find the def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:64,Availability,down,down,64,"/// Creates an SUnit for each real instruction, numbered in top-down; /// topological order. The instruction order A < B, implies that no edge exists; /// from B to A.; ///; /// Map each real instruction to its SUnit.; ///; /// After initSUnits, the SUnits vector cannot be resized and the scheduler may; /// hang onto SUnit pointers. We may relax this in the future by using SUnit IDs; /// instead of pointers.; ///; /// MachineScheduler relies on initSUnits numbering the nodes by their order in; /// the original instruction list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:290,Energy Efficiency,schedul,scheduler,290,"/// Creates an SUnit for each real instruction, numbered in top-down; /// topological order. The instruction order A < B, implies that no edge exists; /// from B to A.; ///; /// Map each real instruction to its SUnit.; ///; /// After initSUnits, the SUnits vector cannot be resized and the scheduler may; /// hang onto SUnit pointers. We may relax this in the future by using SUnit IDs; /// instead of pointers.; ///; /// MachineScheduler relies on initSUnits numbering the nodes by their order in; /// the original instruction list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Performance,Latency,Latency,14,// Assign the Latency field of SU using target-provided information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:160,Deployability,pipeline,pipeline,160,"// If this SUnit uses a reserved or unbuffered resource, mark it as such.; //; // Reserved resources block an instruction from issuing and stall the; // entire pipeline. These are identified by BufferSize=0.; //; // Unbuffered resources prevent execution of subsequent instructions that; // require the same resources. This is used for in-order execution pipelines; // within an out-of-order core. These are identified by BufferSize=1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:355,Deployability,pipeline,pipelines,355,"// If this SUnit uses a reserved or unbuffered resource, mark it as such.; //; // Reserved resources block an instruction from issuing and stall the; // entire pipeline. These are identified by BufferSize=0.; //; // Unbuffered resources prevent execution of subsequent instructions that; // require the same resources. This is used for in-order execution pipelines; // within an out-of-order core. These are identified by BufferSize=1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:10,Performance,load,loads,10,"/// 1 for loads, 0 for stores. (see comment in SUList)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:51,Energy Efficiency,reduce,reduce,51,"/// Adds SU to the SUList of V. If Map grows huge, reduce its size by calling; /// reduce().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:83,Energy Efficiency,reduce,reduce,83,"/// Adds SU to the SUList of V. If Map grows huge, reduce its size by calling; /// reduce().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:4,Usability,Clear,Clears,4,/// Clears the list of SUs mapped to V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:4,Usability,Clear,Clears,4,/// Clears map from all contents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:12,Energy Efficiency,schedul,scheduling,12,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:287,Integrability,depend,depending,287,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:394,Integrability,depend,depend,394,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:319,Performance,load,loads,319,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:74,Performance,Load,Loads,74,"// Certain memory accesses are known to not alias any SU in Stores; // or Loads, and have therefore their own 'NonAlias'; // domain. E.g. spill / reload instructions never alias LLVM I/R; // Values. It would be nice to assume that this type of memory; // accesses always have a proper memory operand modelling, and are; // therefore never unanalyzable, but this is conservatively not; // done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:18,Security,access,accesses,18,"// Certain memory accesses are known to not alias any SU in Stores; // or Loads, and have therefore their own 'NonAlias'; // domain. E.g. spill / reload instructions never alias LLVM I/R; // Values. It would be nice to assume that this type of memory; // accesses always have a proper memory operand modelling, and are; // therefore never unanalyzable, but this is conservatively not; // done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:255,Security,access,accesses,255,"// Certain memory accesses are known to not alias any SU in Stores; // or Loads, and have therefore their own 'NonAlias'; // domain. E.g. spill / reload instructions never alias LLVM I/R; // Values. It would be nice to assume that this type of memory; // accesses always have a proper memory operand modelling, and are; // therefore never unanalyzable, but this is conservatively not; // done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:85,Integrability,depend,depend,85,"// Track all instructions that may raise floating-point exceptions.; // These do not depend on one other (or normal loads or stores), but; // must not be rescheduled across global barriers. Note that we don't; // really need a ""map"" here since we don't track those MIs by value;; // using the same Value2SUsMap data type here is simply a matter of; // convenience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:116,Performance,load,loads,116,"// Track all instructions that may raise floating-point exceptions.; // These do not depend on one other (or normal loads or stores), but; // must not be rescheduled across global barriers. Note that we don't; // really need a ""map"" here since we don't track those MIs by value;; // using the same Value2SUsMap data type here is simply a matter of; // convenience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:329,Usability,simpl,simply,329,"// Track all instructions that may raise floating-point exceptions.; // These do not depend on one other (or normal loads or stores), but; // must not be rescheduled across global barriers. Note that we don't; // really need a ""map"" here since we don't track those MIs by value;; // using the same Value2SUsMap data type here is simply a matter of; // convenience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:54,Energy Efficiency,schedul,scheduled,54,// Model data dependencies between instructions being scheduled and the; // ExitSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependencies,14,// Model data dependencies between instructions being scheduled and the; // ExitSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:22,Integrability,depend,dependencies,22,"// Add register-based dependencies (data, anti, and output).; // For some instructions (calls, returns, inline-asm, etc.) there can; // be explicit uses and implicit defs, in which case the use will appear; // on the operand list before the def. Do two passes over the operand; // list to make sure that defs are processed before any uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:137,Integrability,depend,dependence,137,// Only look at use operands.; // We do not need to check for MO.readsReg() here because subsequent; // subregister defs will get output dependence edges and need no; // additional use dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:185,Integrability,depend,dependencies,185,// Only look at use operands.; // We do not need to check for MO.readsReg() here because subsequent; // subregister defs will get output dependence edges and need no; // additional use dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:39,Energy Efficiency,schedul,scheduling,39,"// If we haven't seen any uses in this scheduling region, create a; // dependence edge to ExitSU to model the live-out latency. This is required; // for vreg defs with no in-region use, and prefetches with no vreg def.; //; // FIXME: NumDataSuccs would be more precise than NumSuccs here. This; // check currently relies on being called before adding chain deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:71,Integrability,depend,dependence,71,"// If we haven't seen any uses in this scheduling region, create a; // dependence edge to ExitSU to model the live-out latency. This is required; // for vreg defs with no in-region use, and prefetches with no vreg def.; //; // FIXME: NumDataSuccs would be more precise than NumSuccs here. This; // check currently relies on being called before adding chain deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:119,Performance,latency,latency,119,"// If we haven't seen any uses in this scheduling region, create a; // dependence edge to ExitSU to model the live-out latency. This is required; // for vreg defs with no in-region use, and prefetches with no vreg def.; //; // FIXME: NumDataSuccs would be more precise than NumSuccs here. This; // check currently relies on being called before adding chain deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependencies,14,// Add memory dependencies (Note: isStoreToStackSlot and; // isLoadFromStackSLot are not usable after stack slots are lowered to; // actual addresses).; // This is a barrier event that acts as a pivotal node in the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:89,Usability,usab,usable,89,// Add memory dependencies (Note: isStoreToStackSlot and; // isLoadFromStackSLot are not usable after stack slots are lowered to; // actual addresses).; // This is a barrier event that acts as a pivotal node in the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:7,Integrability,depend,dependencies,7,// Add dependencies against everything below it and clear maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:52,Usability,clear,clear,52,// Add dependencies against everything below it and clear maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:36,Performance,load,load,36,"// If it's not a store or a variant load, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Integrability,depend,dependecy,14,// Always add dependecy edge to BarrierChain if present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:140,Integrability,depend,depends,140,"// Find the underlying objects for MI. The Objs vector is either; // empty, or filled with the Values of memory locations which this; // SU depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:20,Integrability,depend,depends,20,// An unknown store depends on all stores and loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:46,Performance,load,loads,46,// An unknown store depends on all stores and loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:15,Integrability,depend,dependencies,15,// Add precise dependencies against all previously seen memory; // accesses mapped to the same Value(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:67,Security,access,accesses,67,// Add precise dependencies against all previously seen memory; // accesses mapped to the same Value(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:7,Integrability,depend,dependencies,7,// Add dependencies to previous stores and loads mapped to V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:43,Performance,load,loads,43,// Add dependencies to previous stores and loads mapped to V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Deployability,Update,Update,3,// Update the store map after all chains have been added to avoid adding; // self-loop edge if multiple underlying objects are present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:60,Safety,avoid,avoid,60,// Update the store map after all chains have been added to avoid adding; // self-loop edge if multiple underlying objects are present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:22,Integrability,depend,dependencies,22,// The store may have dependencies to unanalyzable loads and; // stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:51,Performance,load,loads,51,// The store may have dependencies to unanalyzable loads and; // stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:11,Performance,load,load,11,// SU is a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:19,Integrability,depend,depends,19,// An unknown load depends on all stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Performance,load,load,14,// An unknown load depends on all stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:15,Integrability,depend,dependencies,15,// Add precise dependencies against all previously seen stores; // mapping to the same Value(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:12,Performance,load,load,12,// Map this load to V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:21,Integrability,depend,dependencies,21,// The load may have dependencies to unanalyzable stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:7,Performance,load,load,7,// The load may have dependencies to unanalyzable stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce maps if they grow huge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:171,Integrability,depend,dependency,171,"// The N last elements in NodeNums will be removed, and the SU with; // the lowest NodeNum of them will become the new BarrierChain to; // let the not yet seen SUs have a dependency to the removed SUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:38,Energy Efficiency,reduce,reduce,38,"// The aliasing and non-aliasing maps reduce independently of each; // other, but share a common BarrierChain. Check if the; // newBarrierChain is above the former one. If it is not, it may; // introduce a loop to use newBarrierChain, so keep the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:19,Availability,avail,available,19,// Things that are available after the instruction are killed by it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Deployability,Update,Update,3,// Update liveness. Registers that are defed but not used in this; // instruction are now dead. Mark register and all subregs as they; // are completely defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:103,Energy Efficiency,schedul,scheduling,103,/// Return the basic block label. It is not necessarilly unique because a block; /// contains multiple scheduling regions. But it is fine for visualization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:45,Energy Efficiency,schedul,scheduling,45,"// Do not use WillCreateCycle, it assumes SD scheduling.; // If Pred is reachable from Succ, then the edge creates a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:175,Deployability,update,updated,175,"/// Returns true if this node been visited by the DFS traversal.; ///; /// During visitPostorderNode the Node's SubtreeID is assigned to the Node; /// ID. Later, SubtreeID is updated but remains valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:45,Energy Efficiency,schedul,scheduled,45,"/// The root of the given SubtreeID was just scheduled. For all subtrees; /// connected to this tree, record the depth of the connection so that the; /// nearest connected subtrees can be prioritized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp:8,Energy Efficiency,Schedul,ScheduleDAGPrinter,8,"//===-- ScheduleDAGPrinter.cpp - Implement ScheduleDAG::viewGraph() -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements the ScheduleDAG::viewGraph method.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp:43,Energy Efficiency,Schedul,ScheduleDAG,43,"//===-- ScheduleDAGPrinter.cpp - Implement ScheduleDAG::viewGraph() -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements the ScheduleDAG::viewGraph method.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp:403,Energy Efficiency,Schedul,ScheduleDAG,403,"//===-- ScheduleDAGPrinter.cpp - Implement ScheduleDAG::viewGraph() -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements the ScheduleDAG::viewGraph method.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:40,Energy Efficiency,Schedul,Scheduler,40,"//===- ScoreboardHazardRecognizer.cpp - Scheduler Support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScoreboardHazardRecognizer class, which; // encapsultes hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:496,Energy Efficiency,schedul,scheduling,496,"//===- ScoreboardHazardRecognizer.cpp - Scheduler Support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScoreboardHazardRecognizer class, which; // encapsultes hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:525,Energy Efficiency,schedul,scheduling,525,"//===- ScoreboardHazardRecognizer.cpp - Scheduler Support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScoreboardHazardRecognizer class, which; // encapsultes hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:464,Safety,hazard,hazard-avoidance,464,"//===- ScoreboardHazardRecognizer.cpp - Scheduler Support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScoreboardHazardRecognizer class, which; // encapsultes hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:157,Safety,avoid,avoid,157,// Determine the maximum depth of any itinerary. This determines the depth of; // the scoreboard. We always make the scoreboard at least 1 cycle deep to; // avoid dealing with the boundary condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:17,Energy Efficiency,power,power-of-,17,// Find the next power-of-2 >= ItinDepth,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:176,Safety,hazard,hazard,176,"// Don't set MaxLookAhead until we find at least one nonzero stage.; // This way, an itinerary with no stages has MaxLookAhead==0, which; // completely bypasses the scoreboard hazard logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:183,Testability,log,logic,183,"// Don't set MaxLookAhead until we find at least one nonzero stage.; // This way, an itinerary with no stages has MaxLookAhead==0, which; // completely bypasses the scoreboard hazard logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:51,Energy Efficiency,schedul,scheduling,51,// Note that stalls will be negative for bottom-up scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:15,Safety,hazard,hazards,15,// Don't check hazards for non-machineinstr Nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:33,Deployability,pipeline,pipeline,33,"// This stage was stalled beyond pipeline depth, so cannot conflict.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:3,Energy Efficiency,reduce,reduce,3,// reduce to a single unit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:93,Integrability,depend,dependence,93,// Returns true if there are expensive instructions in the cold value; // operand's (if any) dependence slice of any of the selects of the given; // group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:57,Integrability,depend,dependence,57,"// For a given source instruction, collect its backwards dependence slice; // consisting of instructions exclusively computed for producing the operands; // of the source instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:57,Safety,predict,predictable,57,// Returns true if the condition of the select is highly predictable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:15,Performance,latency,latency,15,// Returns the latency cost of a given instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:41,Safety,predict,prediction,41,// Returns the cost of a branch when the prediction is correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:81,Performance,optimiz,optimization,81,// If none of the select types are supported then skip this pass.; // This is an optimization pass. Legality issues will be handled by; // instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:8,Performance,optimiz,optimizing,8,"// When optimizing for size, selects are preferable over branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:81,Performance,optimiz,optimization,81,// If none of the select types are supported then skip this pass.; // This is an optimization pass. Legality issues will be handled by; // instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:8,Performance,optimiz,optimizing,8,"// When optimizing for size, selects are preferable over branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:107,Performance,optimiz,optimizeSelectInst,107,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:306,Performance,optimiz,optimizeSelectInst,306,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:329,Performance,optimiz,optimizing,329,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:1137,Performance,optimiz,optimized,1137,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:221,Safety,redund,redundancy,221,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:235,Testability,log,logic,235,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:41,Integrability,depend,dependence,41,"// For each select, compute the sinkable dependence chains of the true and; // false operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:362,Availability,down,downside,362,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:315,Energy Efficiency,schedul,scheduling,315,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:549,Energy Efficiency,schedul,scheduling,549,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:637,Energy Efficiency,schedul,scheduler,637,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:87,Integrability,depend,dependent,87,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:137,Integrability,depend,dependence,137,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:203,Performance,perform,performance,203,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:428,Usability,simpl,simple,428,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:106,Modifiability,variab,variable,106,"// Iterate over all instructions in between SI and LastSI, not including; // SI itself. These are all the variable assignments that happen ""in the; // middle"" of the select group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:49,Performance,optimiz,optimizing,49,"// If the select type is not supported, no point optimizing it.; // Instruction selection will take care of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:623,Availability,avail,available,623,"// For each select group in an inner-most loop,; // a branch is more preferable than a select/conditional-move if:; // i) conversion to branches for all the select groups of the loop satisfies; // loop-level heuristics including reducing the loop's critical path by; // some threshold (see SelectOptimizeImpl::checkLoopHeuristics); and; // ii) the total cost of the select group is cheaper with a branch compared; // to its predicated version. The cost is in terms of latency and the cost; // of a select group is the cost of its most expensive select instruction; // (assuming infinite resources and thus fully leveraging available ILP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:468,Performance,latency,latency,468,"// For each select group in an inner-most loop,; // a branch is more preferable than a select/conditional-move if:; // i) conversion to branches for all the select groups of the loop satisfies; // loop-level heuristics including reducing the loop's critical path by; // some threshold (see SelectOptimizeImpl::checkLoopHeuristics); and; // ii) the total cost of the select group is cheaper with a branch compared; // to its predicated version. The cost is in terms of latency and the cost; // of a select group is the cost of its most expensive select instruction; // (assuming infinite resources and thus fully leveraging available ILP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:37,Performance,optimiz,optimize,37,// Skip cold basic blocks. Better to optimize for size for cold blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:13,Safety,predict,predictable,13,"// If highly predictable, branch form is more profitable, unless a; // predictable select is inexpensive in the target architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:71,Safety,predict,predictable,71,"// If highly predictable, branch form is more profitable, unless a; // predictable select is inexpensive in the target architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:66,Integrability,depend,dependence,66,// Look for expensive instructions in the cold operand's (if any) dependence; // slice of any of the selects in the group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:28,Integrability,depend,dependence,28,// Check if the cold path's dependence slice is expensive for any of the; // selects of the group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:31,Performance,Load,LoadI,31,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:158,Performance,load,load,158,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:18,Safety,safe,safe,18,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:85,Safety,safe,safe,85,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:10,Performance,load,loads,10,// Assume loads from different basic blocks are unsafe to move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:48,Safety,unsafe,unsafe,48,// Assume loads from different basic blocks are unsafe to move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:57,Integrability,depend,dependence,57,"// For a given source instruction, collect its backwards dependence slice; // consisting of instructions exclusively computed for the purpose of producing; // the operands of the source instruction. As an approximation; // (sufficiently-accurate in practice), we populate this set with the; // instructions of the backwards dependence slice that only have one-use and; // form an one-use chain that leads to the source instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:324,Integrability,depend,dependence,324,"// For a given source instruction, collect its backwards dependence slice; // consisting of instructions exclusively computed for the purpose of producing; // the operands of the source instruction. As an approximation; // (sufficiently-accurate in practice), we populate this set with the; // instructions of the backwards dependence slice that only have one-use and; // form an one-use chain that leads to the source instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:3,Safety,Avoid,Avoid,3,// Avoid cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:110,Safety,Avoid,Avoid,110,// Cannot soundly sink instructions with side-effects.; // Terminator or phi instructions cannot be sunk.; // Avoid sinking other select instructions (should be handled separetely).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:17,Performance,load,loads,17,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:102,Performance,load,loaded,102,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:144,Performance,load,loads,144,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:3,Safety,Avoid,Avoid,3,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:219,Safety,safe,safe,219,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:126,Integrability,depend,dependence,126,"// Avoid considering instructions with less frequency than the source; // instruction (i.e., avoid colder code regions of the dependence slice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:3,Safety,Avoid,Avoid,3,"// Avoid considering instructions with less frequency than the source; // instruction (i.e., avoid colder code regions of the dependence slice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:93,Safety,avoid,avoid,93,"// Avoid considering instructions with less frequency than the source; // instruction (i.e., avoid colder code regions of the dependence slice).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:45,Integrability,depend,dependence,45,// Eligible one-use instruction added to the dependence slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:45,Energy Efficiency,reduce,reduce,45,// Profitably converting to branches need to reduce the loop's critical path; // by at least some threshold (absolute gain of GainCycleThreshold cycles and; // relative gain of 12.5%).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:53,Integrability,depend,dependences,53,"// If the loop's critical path involves loop-carried dependences, the gradient; // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).; // This check ensures that the latency reduction for the loop's critical path; // keeps decreasing with sufficient rate beyond the two analyzed loop; // iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:190,Performance,latency,latency,190,"// If the loop's critical path involves loop-carried dependences, the gradient; // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).; // This check ensures that the latency reduction for the loop's critical path; // keeps decreasing with sufficient rate beyond the two analyzed loop; // iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:61,Availability,avail,available,61,"// Assume infinite resources that allow to fully exploit the available; // instruction-level parallelism.; // InstCost = InstLatency + max(Op1Cost, Op2Cost,  OpNCost)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:126,Safety,Predict,PredictedPathCost,126,"// For a select that can be converted to branch,; // compute its cost as a branch (non-predicated cost).; //; // BranchCost = PredictedPathCost + MispredictCost; // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb; // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:165,Safety,Predict,PredictedPathCost,165,"// For a select that can be converted to branch,; // compute its cost as a branch (non-predicated cost).; //; // BranchCost = PredictedPathCost + MispredictCost; // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb; // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:40,Safety,predict,predictable,40,"// If the select condition is obviously predictable, then the misprediction; // rate is zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:106,Integrability,depend,dependence,106,// CondCost is included to account for cases where the computation of the; // condition is part of a long dependence chain (potentially loop-carried); // that would delay detection of a misprediction and increase its cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:171,Safety,detect,detection,171,// CondCost is included to account for cases where the computation of the; // condition is part of a long dependence chain (potentially loop-carried); // that would delay detection of a misprediction and increase its cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:41,Safety,predict,prediction,41,// Returns the cost of a branch when the prediction is correct.; // TrueCost * TrueProbability + FalseCost * FalseProbability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:574,Deployability,pipeline,pipeline,574,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:129,Safety,safe,safe,129,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:264,Safety,safe,safe,264,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:643,Testability,assert,asserts,643,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:171,Usability,simpl,simple,171,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:23,Modifiability,variab,variable,23,// Specifies length of variable length array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:34,Performance,load,load,34,// Initialize the map pointer and load the current head of the shadow stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:131,Safety,avoid,avoids,131,// Delete the original allocas (which are no longer used) and the intrinsic; // calls (which are no longer valid). Doing this last avoids invalidating; // iterators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:1743,Deployability,update,updated,1743,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:32,Safety,safe,safe,32,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:403,Safety,safe,safe,403,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:475,Safety,safe,safe,475,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:571,Safety,safe,safe,571,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:873,Safety,safe,safe,873,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:1302,Safety,safe,safe,1302,"//===- ShrinkWrap.cpp - Compute safe point for prolog/epilog insertion ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for safe point where the prologue and epilogue can be; // inserted.; // The safe point for the prologue (resp. epilogue) is called Save; // (resp. Restore).; // A point is safe for prologue (resp. epilogue) if and only if; // it 1) dominates (resp. post-dominates) all the frame related operations and; // between 2) two executions of the Save (resp. Restore) point there is an; // execution of the Restore (resp. Save) point.; //; // For instance, the following points are safe:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Restore -> Save -> Restore ...; // And the following points are not:; // for (int i = 0; i < 10; ++i) {; // Save; // ...; // }; // for (int i = 0; i < 10; ++i) {; // ...; // Restore; // }; // Indeed, the execution looks like Save -> Save -> ... -> Restore -> Restore.; //; // This pass also ensures that the safe points are 3) cheaper than the regular; // entry and exits blocks.; //; // Property #1 is ensured via the use of MachineDominatorTree and; // MachinePostDominatorTree.; // Property #2 is ensured via property #1 and MachineLoopInfo, i.e., both; // points must be in the same loop.; // Property #3 is ensured via the MachineBlockFrequencyInfo.; //; // If this pass found points matching all these properties, then; // MachineFrameInfo is updated with this information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:172,Integrability,wrap,wrapping,172,"/// Class to determine where the safe point to insert the; /// prologue and epilogue are.; /// Unlike the paper from Fred C. Chow, PLDI'88, that introduces the; /// shrink-wrapping term for prologue/epilogue placement, this pass; /// does not rely on expensive data-flow analysis. Instead we use the; /// dominance properties and loop information to decide which point; /// are safe for such insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:33,Safety,safe,safe,33,"/// Class to determine where the safe point to insert the; /// prologue and epilogue are.; /// Unlike the paper from Fred C. Chow, PLDI'88, that introduces the; /// shrink-wrapping term for prologue/epilogue placement, this pass; /// does not rely on expensive data-flow analysis. Instead we use the; /// dominance properties and loop information to decide which point; /// are safe for such insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:378,Safety,safe,safe,378,"/// Class to determine where the safe point to insert the; /// prologue and epilogue are.; /// Unlike the paper from Fred C. Chow, PLDI'88, that introduces the; /// shrink-wrapping term for prologue/epilogue placement, this pass; /// does not rely on expensive data-flow analysis. Instead we use the; /// dominance properties and loop information to decide which point; /// are safe for such insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:12,Safety,safe,safe,12,/// Current safe point found for the prologue.; /// The prologue will be inserted before the first instruction; /// in this basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:12,Safety,safe,safe,12,/// Current safe point found for the epilogue.; /// The epilogue will be inserted before the first terminator instruction; /// in this basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:64,Security,access,access,64,/// Is `true` for block numbers where we can guarantee no stack access; /// or computation of stack-relative addresses on any CFG path including; /// the block itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:4,Deployability,Update,Update,4,/// Update the Save and Restore points such that \p MBB is in; /// the region that is dominated by Save and post-dominated by Restore; /// and Save and Restore still match the safe point definition.; /// Such point may not exist and Save and/or Restore may be null after; /// this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:176,Safety,safe,safe,176,/// Update the Save and Restore points such that \p MBB is in; /// the region that is dominated by Save and post-dominated by Restore; /// and Save and Restore still match the safe point definition.; /// Such point may not exist and Save and/or Restore may be null after; /// this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:15,Safety,safe,safe,15,// Try to find safe point based on dominance and block frequency without; // any change in IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:87,Integrability,wrap,wrapping,87,/// Check whether or not Save and Restore points are still interesting for; /// shrink-wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:20,Integrability,wrap,wrapping,20,/// Check if shrink wrapping is enabled for this target and function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:45,Deployability,update,update,45,/// Perform the shrink-wrapping analysis and update; /// the MachineFrameInfo attached to \p MF with the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:23,Integrability,wrap,wrapping,23,/// Perform the shrink-wrapping analysis and update; /// the MachineFrameInfo attached to \p MF with the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:4,Performance,Perform,Perform,4,/// Perform the shrink-wrapping analysis and update; /// the MachineFrameInfo attached to \p MF with the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:31,Security,access,access,31,"/// Check if \p Op is known to access an address not on the function's stack .; /// At the moment, accesses where the underlying object is a global, function; /// argument, or jump table are considered non-stack accesses. Note that the; /// caller's stack may get accessed when passing an argument via the stack,; /// but not the stack of the current function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:99,Security,access,accesses,99,"/// Check if \p Op is known to access an address not on the function's stack .; /// At the moment, accesses where the underlying object is a global, function; /// argument, or jump table are considered non-stack accesses. Note that the; /// caller's stack may get accessed when passing an argument via the stack,; /// but not the stack of the current function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:212,Security,access,accesses,212,"/// Check if \p Op is known to access an address not on the function's stack .; /// At the moment, accesses where the underlying object is a global, function; /// argument, or jump table are considered non-stack accesses. Note that the; /// caller's stack may get accessed when passing an argument via the stack,; /// but not the stack of the current function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:264,Security,access,accessed,264,"/// Check if \p Op is known to access an address not on the function's stack .; /// At the moment, accesses where the underlying object is a global, function; /// argument, or jump table are considered non-stack accesses. Note that the; /// caller's stack may get accessed when passing an argument via the stack,; /// but not the stack of the current function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Performance,Load,Load,3,// Load/store operations may access the stack indirectly when we previously; // computed an address to a stack location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:29,Security,access,access,29,// Load/store operations may access the stack indirectly when we previously; // computed an address to a stack location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:18,Deployability,update,updates,18,/// This function updates the branches post restore point split.; ///; /// Restore point has been split.; /// Old restore point: MBB; /// New restore point: NMBB; /// Any basic block(say BBToUpdate) which had a fallthrough to MBB; /// previously should; /// 1. Fallthrough to NMBB iff NMBB is inserted immediately above MBB in the; /// block layout OR; /// 2. Branch unconditionally to NMBB iff NMBB is inserted at any other place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:106,Performance,optimiz,optimizer,106,// Insert this block at the end of the function. Inserting in between may; // interfere with control flow optimizer decisions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:18,Usability,undo,undoes,18,/// This function undoes the restore point split done earlier.; ///; /// DirtyPreds: All predecessors of \p NMBB that are ReachableByDirty.; ///; /// Restore point was split and the change needs to be unrolled. Make necessary; /// changes to reset restore point from \p NMBB to \p MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:19,Performance,optimiz,optimization,19,// Bail out of the optimization if any of the basic block is target of; // INLINEASM_BR instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:63,Integrability,depend,depending,63,"// Make sure if the new restore point is valid as an epilogue, depending on; // targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Safety,Abort,Abort,3,"// Abort, we can't find a restore point in this case.; // Make sure we would be able to insert the restore code before the; // terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Safety,Abort,Abort,3,"// Abort, we can't find a restore point in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:54,Integrability,wrap,wrapping,54,// Make sure Save and Restore are suitable for shrink-wrapping:; // 1. all path from Save needs to lead to Restore before exiting.; // 2. all path to Restore needs to go through Save from Entry.; // We achieve that by making sure that:; // A. Save dominates Restore.; // B. Restore post-dominates Save.; // C. Save and Restore are in the same loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:160,Safety,safe,safe,160,"// If the immediate post-dominator is not in a less nested loop,; // then we are stuck in a program with an infinite loop.; // In that case, we will not find a safe point, hence, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:31,Security,access,accesses,31,// Check if we found any stack accesses in the predecessors. We are not; // doing a full dataflow analysis here to keep things simple but just; // rely on a reverse portorder traversal (RPOT) to guarantee predecessors; // are already processed except for loops (and accept the conservative; // result for loops).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:127,Usability,simpl,simple,127,// Check if we found any stack accesses in the predecessors. We are not; // doing a full dataflow analysis here to keep things simple but just; // rely on a reverse portorder traversal (RPOT) to guarantee predecessors; // are already processed except for loops (and accept the conservative; // result for loops).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:83,Integrability,wrap,wrapping,83,// Windows with CFI has some limitations that make it impossible; // to use shrink-wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Security,Sanitiz,Sanitizers,3,"// Sanitizers look at the value of the stack at the location; // of the crash. Since a crash can happen anywhere, the; // frame must be lowered before anything else happen for the; // sanitizers to be able to get a correct stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:184,Security,sanitiz,sanitizers,184,"// Sanitizers look at the value of the stack at the location; // of the crash. Since a crash can happen anywhere, the; // frame must be lowered before anything else happen for the; // sanitizers to be able to get a correct stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:163,Integrability,wrap,wrapping,163,"// If EnableShrinkWrap is set, it takes precedence on whatever the; // target sets. The rational is that we assume we want to test; // something related to shrink-wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:126,Testability,test,test,126,"// If EnableShrinkWrap is set, it takes precedence on whatever the; // target sets. The rational is that we assume we want to test; // something related to shrink-wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:10,Integrability,Interface,Interface,10,// Public Interface To the SjLjEHPrepare pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:27,Energy Efficiency,Allocate,Allocate,27,/// setupFunctionContext - Allocate the function context on the stack and fill; /// it with all of the data that we know at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:32,Safety,avoid,avoid,32,"/// lowerIncomingArguments - To avoid having to handle incoming arguments; /// specially, we lower each arg to a copy instruction in the entry block. This; /// ensures that the argument value itself cannot be live out of the entry; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:9,Availability,error,error,9,// Swift error really is a register that we model as memory -- instruction; // selection will perform mem-to-reg for us and spill/reload appropriately; // around calls that clobber it. There is no need to spill this; // value to the stack and doing so would not be allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:94,Performance,perform,perform,94,// Swift error really is a register that we model as memory -- instruction; // selection will perform mem-to-reg for us and spill/reload appropriately; // around calls that clobber it. There is no need to spill this; // value to the stack and doing so would not be allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:58,Availability,alive,alive,58,/// lowerAcrossUnwindEdges - Find all variables which are alive across an unwind; /// edge and spill them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:38,Modifiability,variab,variables,38,/// lowerAcrossUnwindEdges - Find all variables which are alive across an unwind; /// edge and spill them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid iterator invalidation by copying users to a temporary vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:28,Safety,avoid,avoid,28,// Place PHIs into a set to avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:37,Deployability,update,update,37,"// At this point, we are all set up, update the invoke instructions to mark; // their call_site values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:49,Deployability,update,update,49,"// Following any allocas not in the entry block, update the saved SP in the; // jmpbuf to the new value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:33,Energy Efficiency,allocate,allocated,33,// The indexList's nodes are all allocated in the BumpPtrAllocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:294,Testability,assert,assert,294,"// Compute numbering as follows:; // Grab an iterator to the start of the index list.; // Iterate over all MBBs, and within each MBB all MIs, keeping the MI; // iterator in lock-step (though skipping it over indexes which have; // null pointers in the instruction field).; // At each iteration assert that the instruction pointed to in the index; // is the same one pointed to by the MI iterator. This; // FIXME: This can be simplified. The mi2iMap_, Idx2MBBMap, etc. should; // only need to be set up once after the first numbering is computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:425,Usability,simpl,simplified,425,"// Compute numbering as follows:; // Grab an iterator to the start of the index list.; // Iterate over all MBBs, and within each MBB all MIs, keeping the MI; // iterator in lock-step (though skipping it over indexes which have; // null pointers in the instruction field).; // At each iteration assert that the instruction pointed to in the index; // is the same one pointed to by the MI iterator. This; // FIXME: This can be simplified. The mi2iMap_, Idx2MBBMap, etc. should; // only need to be set up once after the first numbering is computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:51,Deployability,update,update,51,// When removing the first instruction of a bundle update mapping to next; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:3,Availability,Repair,Repair,3,// Repair indexes after adding and removing instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:84,Deployability,update,update,84,"// In theory this could be combined with the previous loop, but it is tricky; // to update the IndexList while we are iterating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:1160,Deployability,update,updated,1160,"//===- SpillPlacement.cpp - Optimal Spill Code Placement ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the spill code placement analysis.; //; // Each edge bundle corresponds to a node in a Hopfield network. Constraints on; // basic blocks are weighted by the block frequency and added to become the node; // bias.; //; // Transparent basic blocks have the variable live through, but don't care if it; // is spilled or in a register. These blocks become connections in the Hopfield; // network, again weighted by block frequency.; //; // The Hopfield network minimizes (possibly locally) its energy function:; //; // E = -sum_n V_n * ( B_n + sum_{n, m linked by b} V_m * F_b ); //; // The energy function represents the expected spill code execution frequency,; // or the cost of spilling. This is a Lyapunov function which never increases; // when a node is updated. It is guaranteed to converge to a local minimum.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:893,Energy Efficiency,energy,energy,893,"//===- SpillPlacement.cpp - Optimal Spill Code Placement ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the spill code placement analysis.; //; // Each edge bundle corresponds to a node in a Hopfield network. Constraints on; // basic blocks are weighted by the block frequency and added to become the node; // bias.; //; // Transparent basic blocks have the variable live through, but don't care if it; // is spilled or in a register. These blocks become connections in the Hopfield; // network, again weighted by block frequency.; //; // The Hopfield network minimizes (possibly locally) its energy function:; //; // E = -sum_n V_n * ( B_n + sum_{n, m linked by b} V_m * F_b ); //; // The energy function represents the expected spill code execution frequency,; // or the cost of spilling. This is a Lyapunov function which never increases; // when a node is updated. It is guaranteed to converge to a local minimum.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:990,Energy Efficiency,energy,energy,990,"//===- SpillPlacement.cpp - Optimal Spill Code Placement ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the spill code placement analysis.; //; // Each edge bundle corresponds to a node in a Hopfield network. Constraints on; // basic blocks are weighted by the block frequency and added to become the node; // bias.; //; // Transparent basic blocks have the variable live through, but don't care if it; // is spilled or in a register. These blocks become connections in the Hopfield; // network, again weighted by block frequency.; //; // The Hopfield network minimizes (possibly locally) its energy function:; //; // E = -sum_n V_n * ( B_n + sum_{n, m linked by b} V_m * F_b ); //; // The energy function represents the expected spill code execution frequency,; // or the cost of spilling. This is a Lyapunov function which never increases; // when a node is updated. It is guaranteed to converge to a local minimum.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:658,Modifiability,variab,variable,658,"//===- SpillPlacement.cpp - Optimal Spill Code Placement ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the spill code placement analysis.; //; // Each edge bundle corresponds to a node in a Hopfield network. Constraints on; // basic blocks are weighted by the block frequency and added to become the node; // bias.; //; // Transparent basic blocks have the variable live through, but don't care if it; // is spilled or in a register. These blocks become connections in the Hopfield; // network, again weighted by block frequency.; //; // The Hopfield network minimizes (possibly locally) its energy function:; //; // E = -sum_n V_n * ( B_n + sum_{n, m linked by b} V_m * F_b ); //; // The energy function represents the expected spill code execution frequency,; // or the cost of spilling. This is a Lyapunov function which never increases; // when a node is updated. It is guaranteed to converge to a local minimum.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:125,Integrability,depend,depends,125,"/// Node - Each edge bundle corresponds to a Hopfield node.; ///; /// The node contains precomputed frequency data that only depends on the CFG,; /// but Bias and Links are computed each time placeSpills is called.; ///; /// The node Value is positive when the variable should be in a register. The; /// value can change when linked nodes change, but convergence is very fast; /// because all weights are positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:261,Modifiability,variab,variable,261,"/// Node - Each edge bundle corresponds to a Hopfield node.; ///; /// The node contains precomputed frequency data that only depends on the CFG,; /// but Bias and Links are computed each time placeSpills is called.; ///; /// The node Value is positive when the variable should be in a register. The; /// value can change when linked nodes change, but convergence is very fast; /// because all weights are positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:154,Modifiability,variab,variable,154,"/// Value - Output value of this node computed from the Bias and links.; /// This is always on of the values {-1, 0, 1}. A positive number means the; /// variable should go in a register through this bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:21,Performance,Cache,Cached,21,/// SumLinkWeights - Cached sum of the weights of all links + ThresHold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:69,Integrability,depend,depend,69,"/// clear - Reset per-query data, but preserve frequencies that only depend on; /// the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:4,Usability,clear,clear,4,"/// clear - Reset per-query data, but preserve frequencies that only depend on; /// the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:3,Deployability,Update,Update,3,// Update cached sum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:10,Performance,cache,cached,10,// Update cached sum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:4,Deployability,update,update,4,/// update - Recompute Value from Bias and Links. Return true when node; /// preference changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:333,Availability,error,errors,333,"// Each weighted sum is going to be less than the total frequency of the; // bundle. Ideally, we should simply set Value = sign(SumP - SumN), but we; // will add a dead zone around 0 for two reasons:; //; // 1. It avoids arbitrary bias when all links are 0 as is possible during; // initial iterations.; // 2. It helps tame rounding errors when the links nominally sum to 0.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:214,Safety,avoid,avoids,214,"// Each weighted sum is going to be less than the total frequency of the; // bundle. Ideally, we should simply set Value = sign(SumP - SumN), but we; // will add a dead zone around 0 for two reasons:; //; // 1. It avoids arbitrary bias when all links are 0 as is possible during; // initial iterations.; // 2. It helps tame rounding errors when the links nominally sum to 0.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:104,Usability,simpl,simply,104,"// Each weighted sum is going to be less than the total frequency of the; // bundle. Ideally, we should simply set Value = sign(SumP - SumN), but we; // will add a dead zone around 0 for two reasons:; //; // 1. It avoids arbitrary bias when all links are 0 as is possible during; // initial iterations.; // 2. It helps tame rounding errors when the links nominally sum to 0.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:156,Energy Efficiency,allocate,allocate,156,"// Very large bundles usually come from big switches, indirect branches,; // landing pads, or loops with many 'continue' statements. It is difficult to; // allocate registers when so many different blocks are involved.; //; // Give a small negative bias to large bundles such that a substantial; // fraction of the connected blocks need to be interested before we consider; // expanding the region through the bundle. This helps compile time by; // limiting the number of blocks visited and the number of links in the; // Hopfield network.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:25,Deployability,update,update,25,/// iterate - Repeatedly update the Hopfield nodes until stability or the; /// maximum number of iterations is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:116,Deployability,Update,Update,116,"// Since the last iteration, the todolist have been augmented by calls; // to addConstraints, addLinks, and co.; // Update the network energy starting at this new frontier.; // The call to ::update will add the nodes that changed into the todolist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:191,Deployability,update,update,191,"// Since the last iteration, the todolist have been augmented by calls; // to addConstraints, addLinks, and co.; // Update the network energy starting at this new frontier.; // The call to ::update will add the nodes that changed into the todolist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:135,Energy Efficiency,energy,energy,135,"// Since the last iteration, the todolist have been augmented by calls; // to addConstraints, addLinks, and co.; // Update the network energy starting at this new frontier.; // The call to ::update will add the nodes that changed into the todolist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:697,Modifiability,variab,variable,697,"//===- SpillPlacement.h - Optimal Spill Code Placement ---------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This analysis computes the optimal spill code placement between basic blocks.; //; // The runOnMachineFunction() method only precomputes some profiling information; // about the CFG. The real work is done by prepare(), addConstraints(), and; // finish() which are called by the register allocator.; //; // Given a variable that is live across multiple basic blocks, and given; // constraints on the basic blocks where the variable is live, determine which; // edge bundles should have the variable in a register and which edge bundles; // should have the variable in a stack slot.; //; // The returned bit vector can be used to place optimal spill code at basic; // block entries and exits. Spill code placement inside a basic block is not; // considered.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:805,Modifiability,variab,variable,805,"//===- SpillPlacement.h - Optimal Spill Code Placement ---------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This analysis computes the optimal spill code placement between basic blocks.; //; // The runOnMachineFunction() method only precomputes some profiling information; // about the CFG. The real work is done by prepare(), addConstraints(), and; // finish() which are called by the register allocator.; //; // Given a variable that is live across multiple basic blocks, and given; // constraints on the basic blocks where the variable is live, determine which; // edge bundles should have the variable in a register and which edge bundles; // should have the variable in a stack slot.; //; // The returned bit vector can be used to place optimal spill code at basic; // block entries and exits. Spill code placement inside a basic block is not; // considered.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:872,Modifiability,variab,variable,872,"//===- SpillPlacement.h - Optimal Spill Code Placement ---------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This analysis computes the optimal spill code placement between basic blocks.; //; // The runOnMachineFunction() method only precomputes some profiling information; // about the CFG. The real work is done by prepare(), addConstraints(), and; // finish() which are called by the register allocator.; //; // Given a variable that is live across multiple basic blocks, and given; // constraints on the basic blocks where the variable is live, determine which; // edge bundles should have the variable in a register and which edge bundles; // should have the variable in a stack slot.; //; // The returned bit vector can be used to place optimal spill code at basic; // block entries and exits. Spill code placement inside a basic block is not; // considered.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:938,Modifiability,variab,variable,938,"//===- SpillPlacement.h - Optimal Spill Code Placement ---------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This analysis computes the optimal spill code placement between basic blocks.; //; // The runOnMachineFunction() method only precomputes some profiling information; // about the CFG. The real work is done by prepare(), addConstraints(), and; // finish() which are called by the register allocator.; //; // Given a variable that is live across multiple basic blocks, and given; // constraints on the basic blocks where the variable is live, determine which; // edge bundles should have the variable in a register and which edge bundles; // should have the variable in a stack slot.; //; // The returned bit vector can be used to place optimal spill code at basic; // block entries and exits. Spill code placement inside a basic block is not; // considered.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:34,Deployability,update,updated,34,/// List of nodes that need to be updated in ::iterate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:26,Modifiability,variab,variable,26,///< Block doesn't care / variable not live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:31,Modifiability,variab,variable,31,"///< A register is impossible, variable must be spilled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:154,Modifiability,variab,variable,154,"/// prepare - Reset state and prepare for a new spill placement computation.; /// @param RegBundles Bit vector to receive the edge bundles where the; /// variable should be kept in a register. Each bit; /// corresponds to an edge bundle, a set bit means the; /// variable should be kept in a register through the; /// bundle. A clear bit means the variable should be; /// spilled. This vector is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:263,Modifiability,variab,variable,263,"/// prepare - Reset state and prepare for a new spill placement computation.; /// @param RegBundles Bit vector to receive the edge bundles where the; /// variable should be kept in a register. Each bit; /// corresponds to an edge bundle, a set bit means the; /// variable should be kept in a register through the; /// bundle. A clear bit means the variable should be; /// spilled. This vector is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:348,Modifiability,variab,variable,348,"/// prepare - Reset state and prepare for a new spill placement computation.; /// @param RegBundles Bit vector to receive the edge bundles where the; /// variable should be kept in a register. Each bit; /// corresponds to an edge bundle, a set bit means the; /// variable should be kept in a register through the; /// bundle. A clear bit means the variable should be; /// spilled. This vector is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:328,Usability,clear,clear,328,"/// prepare - Reset state and prepare for a new spill placement computation.; /// @param RegBundles Bit vector to receive the edge bundles where the; /// variable should be kept in a register. Each bit; /// corresponds to an edge bundle, a set bit means the; /// variable should be kept in a register through the; /// bundle. A clear bit means the variable should be; /// spilled. This vector is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:182,Modifiability,variab,variable,182,/// addConstraints - Add constraints and biases. This method may be called; /// more than once to accumulate constraints.; /// @param LiveBlocks Constraints for blocks that have the variable live in or; /// live out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:24,Performance,Perform,Perform,24,"/// scanActiveBundles - Perform an initial scan of all bundles activated by; /// addConstraints and addLinks, updating their state. Add all the bundles; /// that now prefer a register to RecentPositive.; /// Prepare internal data structures for iterate.; /// Return true is there are any positive nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:14,Deployability,Update,Update,14,"/// iterate - Update the network iteratively until convergence, or new bundles; /// are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:392,Modifiability,variab,variable,392,"/// finish - Compute the optimal spill code placement given the; /// constraints. No MustSpill constraints will be violated, and the smallest; /// possible number of PrefX constraints will be violated, weighted by; /// expected execution frequencies.; /// The selected bundles are returned in the bitvector passed to prepare().; /// @return True if a perfect solution was found, allowing the variable to be; /// in a register through all relevant bundles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:73,Availability,alive,alive,73,// The def of statepoint instruction is a gc relocation and it should be alive; // in landing pad. So we cannot split interval after statepoint instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:52,Availability,mask,mask,52,/// Find a subrange corresponding to the exact lane mask @p LM in the live; /// interval @p LI. The interval @p LI is assumed to contain such a subrange.; /// This function is used to find corresponding subranges between the; /// original interval and the new intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:46,Availability,mask,mask,46,"/// Find a subrange corresponding to the lane mask @p LM, or a superset of it,; /// in the live interval @p LI. The interval @p LI is assumed to contain such; /// a subrange. This function is used to find corresponding subranges between; /// the original interval and the new intervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:82,Deployability,update,update,82,"// If we are transferring a def from the original interval, make sure; // to only update the subranges for which the original subranges had; // a def at this location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:203,Deployability,update,updated,203,"// This is a new def: either from rematerialization, or from an inserted; // copy. Since rematerialization can regenerate a definition of a sub-; // register, we need to check which subranges need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:98,Usability,simpl,simple,98,"// This was the first time (RegIdx, ParentVNI) was mapped, and it is not; // forced. Keep it as a simple def without any liveness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:31,Usability,simpl,simple,31,"// If the previous value was a simple mapping, add liveness for it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:15,Usability,simpl,simple,15,"// No longer a simple mapping. Switch to a complex mapping. If the; // interval has subranges, make it a forced mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:65,Usability,simpl,simple,65,// Only a subset of lanes needs to be copied. The following is a simple; // heuristic to construct a sequence of COPYs. We could add a target; // specific callback if this turns out to be suboptimal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Safety,Abort,Abort,3,// Abort if we cannot possibly implement the COPY with the given indexes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:23,Safety,avoid,avoid,23,"// We may be trying to avoid interference that ends at a deleted instruction,; // so always begin RegIdx 0 early and all others late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:35,Modifiability,extend,extended,35,// The complement interval will be extended as needed by LICalc.extend().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:64,Modifiability,extend,extend,64,// The complement interval will be extended as needed by LICalc.extend().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:78,Safety,avoid,avoid,78,// Adjust RegAssign if a register assignment is killed at Def. We want to; // avoid calculating the live range of the source register if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:103,Usability,simpl,simply,103,// Leave loop by going to the immediate dominator of the loop header.; // This is a bigger stride than simply walking up the dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:71,Availability,redundant,redundant,71,"// For VNI aggregation of each ParentVNI, collect dominated, i.e.,; // redundant VNIs to BackCopies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:71,Safety,redund,redundant,71,"// For VNI aggregation of each ParentVNI, collect dominated, i.e.,; // redundant VNIs to BackCopies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:249,Usability,simpl,simply,249,"/// For SM_Size mode, find a common dominator for all the back-copies for; /// the same ParentVNI and hoist the backcopies to the dominator BB.; /// For SM_Speed mode, if the common dominator is hot and it is not beneficial; /// to do the hoisting, simply remove the dominated backcopies for the same; /// ParentVNI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:10,Availability,redundant,redundant,10,// Remove redundant back-copies that are now known to be dominated by another; // def with the same value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:10,Safety,redund,redundant,10,// Remove redundant back-copies that are now known to be dominated by another; // def with the same value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:74,Availability,redundant,redundant,74,"// If it is not beneficial to hoist all the BackCopies, simply remove; // redundant BackCopies in speed mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:74,Safety,redund,redundant,74,"// If it is not beneficial to hoist all the BackCopies, simply remove; // redundant BackCopies in speed mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:56,Usability,simpl,simply,56,"// If it is not beneficial to hoist all the BackCopies, simply remove; // redundant BackCopies in speed mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:144,Modifiability,extend,extend,144,"/// transferValues - Transfer all possible values to the new live ranges.; /// Values that were rematerialized are left alone, they need LICalc.extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:31,Deployability,continuous,continuously,31,"// The interval [Start;End) is continuously mapped to RegIdx, ParentVNI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:15,Usability,simpl,simply,15,// Check for a simply defined value that can be blitted directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Modifiability,Extend,Extend,3,"// Extend live ranges to be live-out for successor PHI values.; // Visit each PHI def slot in the parent live interval. If the def is dead,; // remove it. Otherwise, extend the live interval to reach the end indexes; // of all predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:166,Modifiability,extend,extend,166,"// Extend live ranges to be live-out for successor PHI values.; // Visit each PHI def slot in the parent live interval. If the def is dead,; // remove it. Otherwise, extend the live interval to reach the end indexes; // of all predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:4,Modifiability,rewrite,rewriteAssigned,4,/// rewriteAssigned - Rewrite all uses of Edit->getReg().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:22,Modifiability,Rewrite,Rewrite,22,/// rewriteAssigned - Rewrite all uses of Edit->getReg().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite to the mapped register at Idx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Modifiability,Extend,Extend,3,// Extend liveness to Idx if the instruction reads reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:18,Modifiability,extend,extend,18,"// We may want to extend a live range for a partial redef, or for a use; // tied to an early clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:14,Modifiability,extend,extend,14,"// We want to extend a live range into `e` slot rather than `r` slot if; // tied-def is early clobber, because the `e` slot already contained; // in the live range of early-clobber tied-def operand, give an example; // here:; // 0 %0 = ...; // 16 early-clobber %0 = Op %0 (tied-def 0), ...; // 32 ... = Op %0; // Before extend:; // %0 = [0r, 0d) [16e, 32d); // The point we want to extend is 0d to 16e not 16r in this case, but if; // we use 16r here we will extend nothing because that already contained; // in [16e, 32d).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:320,Modifiability,extend,extend,320,"// We want to extend a live range into `e` slot rather than `r` slot if; // tied-def is early clobber, because the `e` slot already contained; // in the live range of early-clobber tied-def operand, give an example; // here:; // 0 %0 = ...; // 16 early-clobber %0 = Op %0 (tied-def 0), ...; // 32 ... = Op %0; // Before extend:; // %0 = [0r, 0d) [16e, 32d); // The point we want to extend is 0d to 16e not 16r in this case, but if; // we use 16r here we will extend nothing because that already contained; // in [16e, 32d).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:382,Modifiability,extend,extend,382,"// We want to extend a live range into `e` slot rather than `r` slot if; // tied-def is early clobber, because the `e` slot already contained; // in the live range of early-clobber tied-def operand, give an example; // here:; // 0 %0 = ...; // 16 early-clobber %0 = Op %0 (tied-def 0), ...; // 32 ... = Op %0; // Before extend:; // %0 = [0r, 0d) [16e, 32d); // The point we want to extend is 0d to 16e not 16r in this case, but if; // we use 16r here we will extend nothing because that already contained; // in [16e, 32d).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:459,Modifiability,extend,extend,459,"// We want to extend a live range into `e` slot rather than `r` slot if; // tied-def is early clobber, because the `e` slot already contained; // in the live range of early-clobber tied-def operand, give an example; // here:; // 0 %0 = ...; // 16 early-clobber %0 = Op %0 (tied-def 0), ...; // 32 ... = Op %0; // Before extend:; // %0 = [0r, 0d) [16e, 32d); // The point we want to extend is 0d to 16e not 16r in this case, but if; // we use 16r here we will extend nothing because that already contained; // in [16e, 32d).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:20,Modifiability,extend,extending,20,"// We have to delay extending subranges until we have seen all operands; // defining the register. This is because a <def,read-undef> operand; // will create an ""undef"" point, and we cannot extend any subranges; // until all of them have been accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:190,Modifiability,extend,extend,190,"// We have to delay extending subranges until we have seen all operands; // defining the register. This is because a <def,read-undef> operand; // will create an ""undef"" point, and we cannot extend any subranges; // until all of them have been accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:16,Usability,simpl,simply,16,"// Transfer the simply mapped values, check if any are skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite virtual registers, possibly extending ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:39,Modifiability,extend,extending,39,"// Rewrite virtual registers, possibly extending ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:413,Safety,avoid,avoiding,413,//===----------------------------------------------------------------------===//; // Global Live Range Splitting Support; //===----------------------------------------------------------------------===//; // These methods support a method of global live range splitting that uses a; // global algorithm to decide intervals for CFG edges. They will insert split; // points and color intervals in basic blocks while avoiding interference.; //; // Note that splitSingleBlock is also useful for blocks where both CFG edges; // are on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:132,Energy Efficiency,allocate,allocated,132,// The interference is overlapping somewhere we wanted to use IntvIn. That; // means we need to create a local interval that can be allocated a; // different register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:133,Energy Efficiency,allocate,allocated,133,// The interference is overlapping somewhere we wanted to use IntvOut. That; // means we need to create a local interval that can be allocated a; // different register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:26,Safety,safe,safe,26,"/// Determines the latest safe point in a block in which we can insert a split,; /// spill or other instruction related with CurLI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:198,Modifiability,variab,variable,198,"/// Last legal insert point in each basic block in the current function.; /// The first entry is the first terminator, the second entry is the; /// last valid point to insert a split or spill for a variable that is; /// live into a landing pad or inlineasm_br successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:21,Usability,simpl,simple,21,// Inline the common simple case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:64,Modifiability,variab,variable,64,"/// Additional information about basic blocks where the current variable is; /// live. Such a block will look like one of these templates:; ///; /// 1. | o---x | Internal to block. Variable is only live in this block.; /// 2. |---x | Live-in, kill.; /// 3. | o---| Def, live-out.; /// 4. |---x o---| Live-in, kill, def, live-out. Counted by NumGapBlocks.; /// 5. |---o---o---| Live-through with uses or defs.; /// 6. |-----------| Live-through without uses. Counted by NumThroughBlocks.; ///; /// Two BlockInfo entries are created for template 4. One for the live-in; /// segment, and one for the live-out segment. These entries look as if the; /// block were split in the middle where the live range isn't live.; ///; /// Live-through blocks without any uses don't get BlockInfo entries. They; /// are simply listed in ThroughBlocks instead.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:181,Modifiability,Variab,Variable,181,"/// Additional information about basic blocks where the current variable is; /// live. Such a block will look like one of these templates:; ///; /// 1. | o---x | Internal to block. Variable is only live in this block.; /// 2. |---x | Live-in, kill.; /// 3. | o---| Def, live-out.; /// 4. |---x o---| Live-in, kill, def, live-out. Counted by NumGapBlocks.; /// 5. |---o---o---| Live-through with uses or defs.; /// 6. |-----------| Live-through without uses. Counted by NumThroughBlocks.; ///; /// Two BlockInfo entries are created for template 4. One for the live-in; /// segment, and one for the live-out segment. These entries look as if the; /// block were split in the middle where the live range isn't live.; ///; /// Live-through blocks without any uses don't get BlockInfo entries. They; /// are simply listed in ThroughBlocks instead.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:803,Usability,simpl,simply,803,"/// Additional information about basic blocks where the current variable is; /// live. Such a block will look like one of these templates:; ///; /// 1. | o---x | Internal to block. Variable is only live in this block.; /// 2. |---x | Live-in, kill.; /// 3. | o---| Def, live-out.; /// 4. |---x o---| Live-in, kill, def, live-out. Counted by NumGapBlocks.; /// 5. |---o---o---| Live-through with uses or defs.; /// 6. |-----------| Live-through without uses. Counted by NumThroughBlocks.; ///; /// Two BlockInfo entries are created for template 4. One for the live-in; /// segment, and one for the live-out segment. These entries look as if the; /// block were split in the middle where the live range isn't live.; ///; /// Live-through blocks without any uses don't get BlockInfo entries. They; /// are simply listed in ThroughBlocks instead.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:17,Security,access,accessing,17,///< First instr accessing current reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:16,Security,access,accessing,16,///< Last instr accessing current reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:26,Modifiability,variab,variable,26,"/// LooksLikeLoopIV - The variable defines what looks like it could be a loop; /// IV, where it defs a variable in the latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:103,Modifiability,variab,variable,103,"/// LooksLikeLoopIV - The variable defines what looks like it could be a loop; /// IV, where it defs a variable in the latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:4,Usability,clear,clear,4,/// clear - clear all data structures so SplitAnalysis is ready to analyze a; /// new interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:12,Usability,clear,clear,12,/// clear - clear all data structures so SplitAnalysis is ready to analyze a; /// new interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:474,Modifiability,Rewrite,Rewrite,474,/// SplitEditor - Edit machine code and LiveIntervals for live range; /// splitting.; ///; /// - Create a SplitEditor from a SplitAnalysis.; /// - Start a new live interval with openIntv.; /// - Mark the places where the new interval is entered using enterIntv*; /// - Mark the ranges where the new interval is used with useIntv*; /// - Mark the places where the interval is exited with exitIntv*.; /// - Finish the current interval with closeIntv and repeat from 2.; /// - Rewrite instructions with finish().; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:589,Modifiability,extend,extend,589,"/// Values - keep track of the mapping from parent values to values in the new; /// intervals. Given a pair (RegIdx, ParentVNI->id), Values contains:; ///; /// 1. No entry - the value is not mapped to Edit.get(RegIdx).; /// 2. (Null, false) - the value is mapped to multiple values in; /// Edit.get(RegIdx). Each value is represented by a minimal live range at; /// its def. The full live range can be inferred exactly from the range; /// of RegIdx in RegAssign.; /// 3. (Null, true). As above, but the ranges in RegAssign are too large, and; /// the live range must be recomputed using ::extend().; /// 4. (VNI, false) The value is mapped to a single new value.; /// The new value has no live ranges anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:53,Deployability,update,update,53,"/// LICalc - Cache for computing live ranges and SSA update. Each instance; /// can only handle non-overlapping live ranges, so use a separate; /// LiveIntervalCalc instance for the complement interval when in spill mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:13,Performance,Cache,Cache,13,"/// LICalc - Cache for computing live ranges and SSA update. Each instance; /// can only handle non-overlapping live ranges, so use a separate; /// LiveIntervalCalc instance for the complement interval when in spill mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:386,Deployability,update,updated,386,"/// Add a segment to the interval LI for the value number VNI. If LI has; /// subranges, corresponding segments will be added to them as well, but; /// with newly created value numbers. If Original is true, dead def will; /// only be added a subrange of LI if the corresponding subrange of the; /// original interval has a def at this index. Otherwise, all subranges; /// of LI will be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:105,Modifiability,extend,extend,105,"/// forceRecompute - Force the live range of ParentVNI in RegIdx to be; /// recomputed by LiveRangeCalc::extend regardless of the number of defs.; /// This is used for values whose live range doesn't match RegAssign exactly.; /// They could have rematerialized, or back-copies may have been moved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:151,Availability,redundant,redundant,151,"/// Hoist back-copies to the complement interval. It tries to hoist all; /// the back-copies to one BB if it is beneficial, or else simply remove; /// redundant backcopies dominated by others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:151,Safety,redund,redundant,151,"/// Hoist back-copies to the complement interval. It tries to hoist all; /// the back-copies to one BB if it is beneficial, or else simply remove; /// redundant backcopies dominated by others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:132,Usability,simpl,simply,132,"/// Hoist back-copies to the complement interval. It tries to hoist all; /// the back-copies to one BB if it is beneficial, or else simply remove; /// redundant backcopies dominated by others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:47,Availability,Mask,Mask,47,"/// Live range @p LR corresponding to the lane Mask @p LM has a live; /// PHI def at the beginning of block @p B. Extend the range @p LR of; /// all predecessor values that reach this def. If @p LR is a subrange,; /// the array @p Undefs is the set of all locations where it is undefined; /// via <def,read-undef> in other subranges for the same register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:114,Modifiability,Extend,Extend,114,"/// Live range @p LR corresponding to the lane Mask @p LM has a live; /// PHI def at the beginning of block @p B. Extend the range @p LR of; /// all predecessor values that reach this def. If @p LR is a subrange,; /// the array @p Undefs is the set of all locations where it is undefined; /// via <def,read-undef> in other subranges for the same register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:4,Modifiability,extend,extendPHIKillRanges,4,/// extendPHIKillRanges - Extend the ranges of all values killed by original; /// parent PHIDefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:26,Modifiability,Extend,Extend,26,/// extendPHIKillRanges - Extend the ranges of all values killed by original; /// parent PHIDefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:4,Modifiability,rewrite,rewriteAssigned,4,/// rewriteAssigned - Rewrite all uses of Edit.getReg() to assigned registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:22,Modifiability,Rewrite,Rewrite,22,/// rewriteAssigned - Rewrite all uses of Edit.getReg() to assigned registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:105,Modifiability,rewrite,rewrite,105,"/// finish - after all the new live ranges have been created, compute the; /// remaining live range, and rewrite instructions to use the new registers.; /// @param LRMap When not null, this vector will map each live range in Edit; /// back to the indices returned by openIntv.; /// There may be extra indices created by dead code elimination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:185,Safety,avoid,avoids,185,"/// splitRegInBlock - Split CurLI in the given block such that it enters the; /// block in IntvIn and leaves it on the stack (or not at all). Split points; /// are placed in a way that avoids putting uses in the stack interval. This; /// may require creating a local interval when there is interference.; ///; /// @param BI Block descriptor.; /// @param IntvIn Interval index entering the block. Not 0.; /// @param LeaveBefore When set, leave IntvIn before this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:186,Safety,avoid,avoid,186,"/// splitRegOutBlock - Split CurLI in the given block such that it enters the; /// block on the stack (or isn't live-in at all) and leaves it in IntvOut.; /// Split points are placed to avoid interference and such that the uses are; /// not in the stack interval. This may require creating a local interval; /// when there is interference.; ///; /// @param BI Block descriptor.; /// @param IntvOut Interval index leaving the block.; /// @param EnterAfter When set, enter IntvOut after this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:636,Energy Efficiency,reduce,reduce,636,"//===- StackColoring.cpp --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the stack-coloring optimization that looks for; // lifetime markers machine instructions (LIFETIME_START and LIFETIME_END),; // which represent the possible lifetime of stack slots. It attempts to; // merge disjoint stack slots and reduce the used stack space.; // NOTE: This pass is not StackSlotColoring, which optimizes spill slots.; //; // TODO: In the future we plan to improve stack coloring in the following ways:; // 1. Allow merging multiple small slots into a single larger slot at different; // offsets.; // 2. Merge this pass with StackSlotColoring and allow merging of allocas with; // spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:423,Performance,optimiz,optimization,423,"//===- StackColoring.cpp --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the stack-coloring optimization that looks for; // lifetime markers machine instructions (LIFETIME_START and LIFETIME_END),; // which represent the possible lifetime of stack slots. It attempts to; // merge disjoint stack slots and reduce the used stack space.; // NOTE: This pass is not StackSlotColoring, which optimizes spill slots.; //; // TODO: In the future we plan to improve stack coloring in the following ways:; // 1. Allow merging multiple small slots into a single larger slot at different; // offsets.; // 2. Merge this pass with StackSlotColoring and allow merging of allocas with; // spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:717,Performance,optimiz,optimizes,717,"//===- StackColoring.cpp --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the stack-coloring optimization that looks for; // lifetime markers machine instructions (LIFETIME_START and LIFETIME_END),; // which represent the possible lifetime of stack slots. It attempts to; // merge disjoint stack slots and reduce the used stack space.; // NOTE: This pass is not StackSlotColoring, which optimizes spill slots.; //; // TODO: In the future we plan to improve stack coloring in the following ways:; // 1. Allow merging multiple small slots into a single larger slot at different; // offsets.; // 2. Merge this pass with StackSlotColoring and allow merging of allocas with; // spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:216,Performance,optimiz,optimize,216,"/// The user may write code that uses allocas outside of the declared lifetime; /// zone. This can happen when the user returns a reference to a local; /// data-structure. We can detect these cases and decide not to optimize the; /// code. If this flag is enabled, we try to save the user. This option; /// is treated as overriding LifetimeStartOnFirstUse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:179,Safety,detect,detect,179,"/// The user may write code that uses allocas outside of the declared lifetime; /// zone. This can happen when the user returns a reference to a local; /// data-structure. We can detect these cases and decide not to optimize the; /// code. If this flag is enabled, we try to save the user. This option; /// is treated as overriding LifetimeStartOnFirstUse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:11,Modifiability,enhance,enhanced,11,"/// Enable enhanced dataflow scheme for lifetime analysis (treat first; /// use of stack slot as start of slot lifetime, as opposed to looking; /// for LIFETIME_START marker). See ""Implementation notes"" below for; /// more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:209,Energy Efficiency,reduce,reduces,209,"//===----------------------------------------------------------------------===//; // StackColoring Pass; //===----------------------------------------------------------------------===//; //; // Stack Coloring reduces stack usage by merging stack slots when they; // can't be used together. For example, consider the following C program:; //; // void bar(char *, int);; // void foo(bool var) {; // A: {; // char z[4096];; // bar(z, 0);; // }; //; // char *p;; // char x[4096];; // char y[4096];; // if (var) {; // p = x;; // } else {; // bar(y, 1);; // p = y + 1024;; // }; // B:; // bar(p, 2);; // }; //; // Naively-compiled, this program would use 12k of stack space. However, the; // stack slot corresponding to `z` is always destroyed before either of the; // stack slots for `x` or `y` are used, and then `x` is only used if `var`; // is true, while `y` is only used if `var` is false. So in no time are 2; // of the stack slots used together, and therefore we can merge them,; // compiling the function using only a single 4k alloca:; //; // void foo(bool var) { // equivalent; // char x[4096];; // char *p;; // bar(x, 0);; // if (var) {; // p = x;; // } else {; // bar(x, 1);; // p = x + 1024;; // }; // bar(p, 2);; // }; //; // This is an important optimization if we want stack space to be under; // control in large functions, both open-coded ones and ones created by; // inlining.; //; // Implementation Notes:; // ---------------------; //; // An important part of the above reasoning is that `z` can't be accessed; // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:5830,Modifiability,Variab,Variables,5830," facts.; //; // However, we aren't interested in the *set* of points of interference; // between 2 stack slots, only *whether* there *is* such a point. So we; // can rely on a little trick: for `S` and `T` to be in-use together,; // one of them needs to become in-use while the other is in-use (or; // they might both become in use simultaneously). We can check this; // by also keeping track of the points at which a stack slot might *start*; // being in-use.; //; // Exact first use:; // ----------------; //; // Consider the following motivating example:; //; // int foo() {; // char b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:6020,Modifiability,variab,variables,6020,"; // can rely on a little trick: for `S` and `T` to be in-use together,; // one of them needs to become in-use while the other is in-use (or; // they might both become in use simultaneously). We can check this; // by also keeping track of the points at which a stack slot might *start*; // being in-use.; //; // Exact first use:; // ----------------; //; // Consider the following motivating example:; //; // int foo() {; // char b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above st",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7035,Modifiability,variab,variables,7035,"ever, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifeti",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7207,Modifiability,variab,variable,7207,"b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7537,Modifiability,variab,variables,7537," -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7972,Modifiability,variab,variable,7972,"8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +---",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:10150,Modifiability,variab,variable,10150,"-------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a first reference to slot; // K before we hit the slot K lifetime start marker. For such slots,; // we fall back on using the lifetime start marker as the beginning of; // the variable's lifetime. NB: with this implementation, slots can; // appear degenerate in cases where there is unstructured control flow:; //; // if (q) goto mid;; // if (x > 9) {; // int b[100];; // memcpy(&b[0], ...);; // mid: b[k] = ...;; // abc(&b);; // }; //; // If in RPO ordering chosen to walk the CFG we happen to visit the b[k]; // before visiting the memcpy block (which will contain the lifetime start; // for ""b"" then it will appear that 'b' has a degenerate lifetime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:1256,Performance,optimiz,optimization,1256,"-----------------------------------------===//; //; // Stack Coloring reduces stack usage by merging stack slots when they; // can't be used together. For example, consider the following C program:; //; // void bar(char *, int);; // void foo(bool var) {; // A: {; // char z[4096];; // bar(z, 0);; // }; //; // char *p;; // char x[4096];; // char y[4096];; // if (var) {; // p = x;; // } else {; // bar(y, 1);; // p = y + 1024;; // }; // B:; // bar(p, 2);; // }; //; // Naively-compiled, this program would use 12k of stack space. However, the; // stack slot corresponding to `z` is always destroyed before either of the; // stack slots for `x` or `y` are used, and then `x` is only used if `var`; // is true, while `y` is only used if `var` is false. So in no time are 2; // of the stack slots used together, and therefore we can merge them,; // compiling the function using only a single 4k alloca:; //; // void foo(bool var) { // equivalent; // char x[4096];; // char *p;; // bar(x, 0);; // if (var) {; // p = x;; // } else {; // bar(x, 1);; // p = x + 1024;; // }; // bar(p, 2);; // }; //; // This is an important optimization if we want stack space to be under; // control in large functions, both open-coded ones and ones created by; // inlining.; //; // Implementation Notes:; // ---------------------; //; // An important part of the above reasoning is that `z` can't be accessed; // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-slot is marked as *out-of-scope*, unless no; // lifetime intrinsic refers to that stack slot, in which case; // it is marked as *in-scope*.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7922,Performance,optimiz,optimizations,7922,"8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +---",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:8259,Performance,optimiz,optimization,8259,"TIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:9089,Performance,optimiz,optimization,9089,"able outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a f",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:9311,Performance,load,load,9311," the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a first reference to slot; // K before we hit the slot K lifetime start marker. For such slots,; // we fall back on using the lifetime start marker as the beginning of; // the variable's lifetime. NB: with this implementation, slots can; // appear degenerate in cases where there is unstructured control flow:; //; // if (q) goto mid;; // if (x > 9) {; // int b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:9388,Performance,load,loaded,9388," the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a first reference to slot; // K before we hit the slot K lifetime start marker. For such slots,; // we fall back on using the lifetime start marker as the beginning of; // the variable's lifetime. NB: with this implementation, slots can; // appear degenerate in cases where there is unstructured control flow:; //; // if (q) goto mid;; // if (x > 9) {; // int b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:1517,Security,access,accessed,1517,"r y[4096];; // if (var) {; // p = x;; // } else {; // bar(y, 1);; // p = y + 1024;; // }; // B:; // bar(p, 2);; // }; //; // Naively-compiled, this program would use 12k of stack space. However, the; // stack slot corresponding to `z` is always destroyed before either of the; // stack slots for `x` or `y` are used, and then `x` is only used if `var`; // is true, while `y` is only used if `var` is false. So in no time are 2; // of the stack slots used together, and therefore we can merge them,; // compiling the function using only a single 4k alloca:; //; // void foo(bool var) { // equivalent; // char x[4096];; // char *p;; // bar(x, 0);; // if (var) {; // p = x;; // } else {; // bar(x, 1);; // p = x + 1024;; // }; // bar(p, 2);; // }; //; // This is an important optimization if we want stack space to be under; // control in large functions, both open-coded ones and ones created by; // inlining.; //; // Implementation Notes:; // ---------------------; //; // An important part of the above reasoning is that `z` can't be accessed; // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-slot is marked as *out-of-scope*, unless no; // lifetime intrinsic refers to that stack slot, in which case; // it is marked as *in-scope*.; // L2) on a `lifetime.start`, a stack slot is marked as *in-scope* and; // the stack slot is overwritten with `undef`.; // L3) on a `lifetime.end`, a stack slot is marked as *out-of-scope*.; // L4) on function exit, all stack slots are marked as *out-of-scope*.; // L5) `lifetime.end` is a no-op when called on a slot that is already; // *ou",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:1680,Security,access,accesses,1680,"uld use 12k of stack space. However, the; // stack slot corresponding to `z` is always destroyed before either of the; // stack slots for `x` or `y` are used, and then `x` is only used if `var`; // is true, while `y` is only used if `var` is false. So in no time are 2; // of the stack slots used together, and therefore we can merge them,; // compiling the function using only a single 4k alloca:; //; // void foo(bool var) { // equivalent; // char x[4096];; // char *p;; // bar(x, 0);; // if (var) {; // p = x;; // } else {; // bar(x, 1);; // p = x + 1024;; // }; // bar(p, 2);; // }; //; // This is an important optimization if we want stack space to be under; // control in large functions, both open-coded ones and ones created by; // inlining.; //; // Implementation Notes:; // ---------------------; //; // An important part of the above reasoning is that `z` can't be accessed; // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-slot is marked as *out-of-scope*, unless no; // lifetime intrinsic refers to that stack slot, in which case; // it is marked as *in-scope*.; // L2) on a `lifetime.start`, a stack slot is marked as *in-scope* and; // the stack slot is overwritten with `undef`.; // L3) on a `lifetime.end`, a stack slot is marked as *out-of-scope*.; // L4) on function exit, all stack slots are marked as *out-of-scope*.; // L5) `lifetime.end` is a no-op when called on a slot that is already; // *out-of-scope*.; // L6) memory accesses to *out-of-scope* stack slots are UB.; // L7) when a stack-slot is marked as *out-of-scope*, all pointers to it; // are in",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:2511,Security,access,accesses,2511," // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-slot is marked as *out-of-scope*, unless no; // lifetime intrinsic refers to that stack slot, in which case; // it is marked as *in-scope*.; // L2) on a `lifetime.start`, a stack slot is marked as *in-scope* and; // the stack slot is overwritten with `undef`.; // L3) on a `lifetime.end`, a stack slot is marked as *out-of-scope*.; // L4) on function exit, all stack slots are marked as *out-of-scope*.; // L5) `lifetime.end` is a no-op when called on a slot that is already; // *out-of-scope*.; // L6) memory accesses to *out-of-scope* stack slots are UB.; // L7) when a stack-slot is marked as *out-of-scope*, all pointers to it; // are invalidated, unless the slot is ""degenerate"". This is used to; // justify not marking slots as in-use until the pointer to them is; // used, but feels a bit hacky in the presence of things like LICM. See; // the ""Degenerate Slots"" section for more details.; //; // Now, let's ground stack coloring on these rules. We'll define a slot; // as *in-use* at a (dynamic) point in execution if it either can be; // written to at that point, or if it has a live and non-undef content; // at that point.; //; // Obviously, slots that are never *in-use* together can be merged, and; // in our example `foo`, the slots for `x`, `y` and `z` are never; // in-use together (of course, sometimes slots that *are* in-use together; // might still be mergable, but we don't care about that here).; //; // In this implementation, we successively merge pairs of slots that are; // not *in-use* together. We",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:6034,Security,access,accessed,6034,"; // can rely on a little trick: for `S` and `T` to be in-use together,; // one of them needs to become in-use while the other is in-use (or; // they might both become in use simultaneously). We can check this; // by also keeping track of the points at which a stack slot might *start*; // being in-use.; //; // Exact first use:; // ----------------; //; // Consider the following motivating example:; //; // int foo() {; // char b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above st",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:6524,Testability,test,test,6524,"har b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the int",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:8422,Testability,test,test,8422,"TIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:6386,Usability,simpl,simplified,6386,"har b1[1024], b2[1024];; // if (...) {; // char b3[1024];; // <uses of b1, b3>;; // return x;; // } else {; // char b4[1024], b5[1024];; // <uses of b2, b4, b5>;; // return y;; // }; // }; //; // In the code above, ""b3"" and ""b4"" are declared in distinct lexical; // scopes, meaning that it is easy to prove that they can share the; // same stack slot. Variables ""b1"" and ""b2"" are declared in the same; // scope, meaning that from a lexical point of view, their lifetimes; // overlap. From a control flow pointer of view, however, the two; // variables are accessed in disjoint regions of the CFG, thus it; // should be possible for them to share the same stack slot. An ideal; // stack allocation for the function above would look like:; //; // slot 0: b1, b2; // slot 1: b3, b4; // slot 2: b5; //; // Achieving this allocation is tricky, however, due to the way; // lifetime markers are inserted. Here is a simplified view of the; // control flow graph for the code above:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------ block 2 -------+; // 2| LIFETIME_START b3 | 5| LIFETIME_START b4, b5 |; // 3| <uses of b1, b3> | 6| <uses of b2, b4, b5> |; // 4| LIFETIME_END b3 | 7| LIFETIME_END b4, b5 |; // +-----------------------+ +-----------------------+; // \. /.; // +------ block 3 -------+; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the int",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:4,Performance,Perform,Perform,4,"/// Perform the dataflow calculation and calculate the lifetime for each of; /// the slots, based on the BEGIN/END vectors. Set the LifetimeLIVE_IN and; /// LifetimeLIVE_OUT maps that represent which stack slots are live coming; /// in and out blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:217,Modifiability,variab,variable,217,"/// The input program may contain instructions which are not inside lifetime; /// markers. This can happen due to a bug in the compiler or due to a bug in; /// user code (for example, returning a reference to a local variable).; /// This procedure checks all of the instructions in the function and; /// invalidates lifetime ranges which do not contain all of the instructions; /// which access that frame slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:388,Security,access,access,388,"/// The input program may contain instructions which are not inside lifetime; /// markers. This can happen due to a bug in the compiler or due to a bug in; /// user code (for example, returning a reference to a local variable).; /// This procedure checks all of the instructions in the function and; /// invalidates lifetime ranges which do not contain all of the instructions; /// which access that frame slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:228,Integrability,interface,interface,228,"// At the moment the only way to end a variable lifetime is with; // a VARIABLE_LIFETIME op (which can't contain a start). If things; // change and the IR allows for a single inst that both begins; // and ends lifetime(s), this interface will need to be reworked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:39,Modifiability,variab,variable,39,"// At the moment the only way to end a variable lifetime is with; // a VARIABLE_LIFETIME op (which can't contain a start). If things; // change and the IR allows for a single inst that both begins; // and ends lifetime(s), this interface will need to be reworked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:70,Safety,safe,safe,70,"// PR27903: slots with multiple start or end lifetime ops are not; // safe to enable for ""lifetime-start-on-first-use"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:23,Safety,avoid,avoid,23,// Keep a reference to avoid repeated lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,// Update statistics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:22,Safety,avoid,avoid,22,// Use an iterator to avoid repeated lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:131,Safety,safe,safely,131,// PR37130: transformations prior to stack coloring can; // sometimes leave behind statically unreachable blocks; these; // can be safely skipped here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,"// Update block LiveIn set, noting whether it has changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,"// Update block LiveOut set, noting whether it has changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:73,Deployability,update,update,73,"// For each block, find which slots are active within this block; // and update the live intervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:325,Deployability,update,update,325,"// AA might be used later for instruction scheduling, and we need it to be; // able to deduce the correct aliasing releationships between pointers; // derived from the alloca being remapped and the target of that remapping.; // The only safe way, without directly informing AA about the remapping; // somehow, is to directly update the IR to reflect the change being made; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:42,Energy Efficiency,schedul,scheduling,42,"// AA might be used later for instruction scheduling, and we need it to be; // able to deduce the correct aliasing releationships between pointers; // derived from the alloca being remapped and the target of that remapping.; // The only safe way, without directly informing AA about the remapping; // somehow, is to directly update the IR to reflect the change being made; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:237,Safety,safe,safe,237,"// AA might be used later for instruction scheduling, and we need it to be; // able to deduce the correct aliasing releationships between pointers; // derived from the alloca being remapped and the target of that remapping.; // The only safe way, without directly informing AA about the remapping; // somehow, is to directly update the IR to reflect the change being made; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:72,Modifiability,variab,variable,72,"// The new alloca might not be valid in a llvm.dbg.declare for this; // variable, so undef out the use to make the verifier happy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:61,Deployability,update,update,61,"// Note that this will not replace uses in MMOs (which we'll update below),; // or anywhere else (which is why we won't delete the original; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,// Update the MachineMemOperand to use the new alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,// Update all of the machine instruction operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:420,Security,validat,validating,420,"// In a debug build, check that the instruction that we are modifying is; // inside the expected live range. If the instruction is not inside; // the calculated range then it means that the alloca usage moved; // outside of the lifetime markers, or that the user has a bug.; // NOTE: Alloca address calculations which happen outside the lifetime; // zone are okay, despite the fact that we don't have a good way; // for validating all of the usages of the calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:73,Security,validat,validating,73,"// If we *don't* protect the user from escaped allocas, don't bother; // validating the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:28,Deployability,update,updated,28,"// If any memory operand is updated, set memory references of; // this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite MachineMemOperands that reference old frame indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:3,Deployability,Update,Update,3,// Update the location of C++ catch objects for the MSVC personality routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:69,Integrability,rout,routine,69,// Update the location of C++ catch objects for the MSVC personality routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:159,Security,access,accesses,159,"// Some intervals are suspicious! In some cases we find address; // calculations outside of the lifetime zone, but not actual memory; // read or write. Memory accesses outside of the lifetime zone are a clear; // violation, but address calculations are okay. This can happen when; // GEPs are hoisted outside of the lifetime zone.; // So, in here we only check instructions which can read or write memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:203,Usability,clear,clear,203,"// Some intervals are suspicious! In some cases we find address; // calculations outside of the lifetime zone, but not actual memory; // read or write. Memory accesses outside of the lifetime zone are a clear; // violation, but address calculations are okay. This can happen when; // GEPs are hoisted outside of the lifetime zone.; // So, in here we only check instructions which can read or write memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:118,Performance,optimiz,optimize,118,"// Don't continue because there are not enough lifetime markers, or the; // stack is too small, or we are told not to optimize the slots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:257,Deployability,update,update,257,"// This is a simple greedy algorithm for merging allocas. First, sort the; // slots, placing the largest slots first. Next, perform an n^2 scan and look; // for disjoint slots. When you find disjoint slots, merge the smaller one; // into the bigger one and update the live interval. Remove the small alloca; // and continue.; // Sort the slots according to their size. Place unused slots at the end.; // Use stable sort to guarantee deterministic code generation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:124,Performance,perform,perform,124,"// This is a simple greedy algorithm for merging allocas. First, sort the; // slots, placing the largest slots first. Next, perform an n^2 scan and look; // for disjoint slots. When you find disjoint slots, merge the smaller one; // into the bigger one and update the live interval. Remove the small alloca; // and continue.; // Sort the slots according to their size. Place unused slots at the end.; // Use stable sort to guarantee deterministic code generation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:13,Usability,simpl,simple,13,"// This is a simple greedy algorithm for merging allocas. First, sort the; // slots, placing the largest slots first. Next, perform an n^2 scan and look; // for disjoint slots. When you find disjoint slots, merge the smaller one; // into the bigger one and update the live interval. Remove the small alloca; // and continue.; // Sort the slots according to their size. Place unused slots at the end.; // Use stable sort to guarantee deterministic code generation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:32,Deployability,update,update,32,// Scan the entire function and update all machine operands that use frame; // indices to use the remapped frame index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:667,Availability,avail,available,667,"//===-- StackFrameLayoutAnalysisPass.cpp; //------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // StackFrameLayoutAnalysisPass implementation. Outputs information about the; // layout of the stack frame, using the remarks interface. On the CLI it prints; // a textual representation of the stack frame. When possible it prints the; // values that occupy a stack slot using any available debug information. Since; // output is remarks based, it is also available in a machine readable file; // format, such as YAML.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:742,Availability,avail,available,742,"//===-- StackFrameLayoutAnalysisPass.cpp; //------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // StackFrameLayoutAnalysisPass implementation. Outputs information about the; // layout of the stack frame, using the remarks interface. On the CLI it prints; // a textual representation of the stack frame. When possible it prints the; // values that occupy a stack slot using any available debug information. Since; // output is remarks based, it is also available in a machine readable file; // format, such as YAML.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:512,Integrability,interface,interface,512,"//===-- StackFrameLayoutAnalysisPass.cpp; //------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // StackFrameLayoutAnalysisPass implementation. Outputs information about the; // layout of the stack frame, using the remarks interface. On the CLI it prints; // a textual representation of the stack frame. When possible it prints the; // values that occupy a stack slot using any available debug information. Since; // output is remarks based, it is also available in a machine readable file; // format, such as YAML.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:11,Availability,error,error,11,// It's an error for a slot to have this type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:7,Modifiability,variab,variables,7,// add variables to the map,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:582,Deployability,patch,patchpoint,582,"//===-- StackMapLivenessAnalysis.cpp - StackMap live Out Analysis ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the StackMap Liveness analysis pass. The pass calculates; // the liveness for each basic block in a function and attaches the register; // live-out information to a stackmap or patchpoint intrinsic if present.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:142,Deployability,patch,patchpoint,142,/// This pass calculates the liveness information for each basic block in; /// a function and attaches the register live-out information to a patchpoint; /// intrinsic if present.; ///; /// This pass can be disabled via the -enable-patchpoint-liveness=false flag.; /// The pass skips functions that don't have any patchpoint intrinsics. The; /// information provided by this pass is optional and not required by the; /// aformentioned intrinsic to function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:232,Deployability,patch,patchpoint-liveness,232,/// This pass calculates the liveness information for each basic block in; /// a function and attaches the register live-out information to a patchpoint; /// intrinsic if present.; ///; /// This pass can be disabled via the -enable-patchpoint-liveness=false flag.; /// The pass skips functions that don't have any patchpoint intrinsics. The; /// information provided by this pass is optional and not required by the; /// aformentioned intrinsic to function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:314,Deployability,patch,patchpoint,314,/// This pass calculates the liveness information for each basic block in; /// a function and attaches the register live-out information to a patchpoint; /// intrinsic if present.; ///; /// This pass can be disabled via the -enable-patchpoint-liveness=false flag.; /// The pass skips functions that don't have any patchpoint intrinsics. The; /// information provided by this pass is optional and not required by the; /// aformentioned intrinsic to function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:42,Integrability,depend,depend,42,/// Tell the pass manager which passes we depend on and what; /// information we preserve.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:4,Performance,Perform,Performs,4,/// Performs the actual liveness calculation for the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:22,Availability,mask,mask,22,/// Create a register mask and initialize it with the registers from; /// the register live set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:42,Integrability,depend,depend,42,/// Tell the pass manager which passes we depend on and what information we; /// preserve.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:38,Deployability,patch,patchpoints,38,// Skip this function if there are no patchpoints to process.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:4,Performance,Perform,Performs,4,/// Performs the actual liveness calculation for the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:119,Deployability,patch,patchpoint,119,// Reverse iterate over all instructions and add the current live register; // set to an instruction if we encounter a patchpoint instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:22,Availability,mask,mask,22,/// Create a register mask and initialize it with the registers from the; /// register live set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:7,Availability,mask,mask,7,// The mask is owned and cleaned up by the Machine Function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:42,Availability,mask,mask,42,// Give the target a chance to adjust the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:32,Availability,mask,mask,32,/// Parse the register live-out mask and return a vector of live-out registers; /// that need to be recorded in the stackmap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:64,Availability,mask,mask,64,// Create a LiveOutReg for each bit that is set in the register mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:7,Testability,log,logical,7,// Map logical index of GC ptr to MI operand index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:53,Deployability,update,update,53,// Record the stack size of the current function and update callsite count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:97,Deployability,Patch,PatchPoint,97,"/// Emit the callsite info for each callsite.; ///; /// StkMapRecord[NumRecords] {; /// uint64 : PatchPoint ID; /// uint32 : Instruction Offset; /// uint16 : Reserved (record flags); /// uint16 : NumLocations; /// Location[NumLocations] {; /// uint8 : Register | Direct | Indirect | Constant | ConstantIndex; /// uint8 : Size in Bytes; /// uint16 : Dwarf RegNum; /// int32 : Offset; /// }; /// uint16 : Padding; /// uint16 : NumLiveOuts; /// LiveOuts[NumLiveOuts] {; /// uint16 : Dwarf RegNum; /// uint8 : Reserved; /// uint8 : Size in Bytes; /// }; /// uint32 : Padding (only if required to align to 8 byte); /// }; ///; /// Location Encoding, Type, Value:; /// 0x1, Register, Reg (value in register); /// 0x2, Direct, Reg + Offset (frame index); /// 0x3, Indirect, [Reg + Offset] (spilled value); /// 0x4, Constant, Offset (small constant); /// 0x5, ConstIndex, Constants[Offset] (large constant)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:230,Availability,error,errors,230,"// Verify stack map entry. It's better to communicate a problem to the; // runtime than crash in case of in-process compilation. Currently, we do; // simple overflow checks, but we may eventually communicate other; // compilation errors this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:150,Usability,simpl,simple,150,"// Verify stack map entry. It's better to communicate a problem to the; // runtime than crash in case of in-process compilation. Currently, we do; // simple overflow checks, but we may eventually communicate other; // compilation errors this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:551,Energy Efficiency,allocate,allocated,551,"//===- StackProtector.cpp - Stack Protector Insertion ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:452,Modifiability,variab,variable,452,"//===- StackProtector.cpp - Stack Protector Insertion ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:533,Modifiability,variab,variables,533,"//===- StackProtector.cpp - Stack Protector Insertion ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:690,Safety,abort,aborts,690,"//===- StackProtector.cpp - Stack Protector Insertion ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:123,Performance,load,loads,123,/// InsertStackProtectors - Insert code into the prologue and epilogue of the; /// function.; ///; /// - The prologue code loads and stores the stack guard onto the stack.; /// - The epilogue checks the value stored in the prologue against the original; /// value. It calls __stack_chk_fail if they differ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:52,Energy Efficiency,allocate,allocated,52,"// If an array has more than SSPBufferSize bytes of allocated space, then we; // emit stack protectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:96,Energy Efficiency,allocate,allocated,96,// If this instruction accesses memory make sure it doesn't access beyond; // the bounds of the allocated object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:23,Security,access,accesses,23,// If this instruction accesses memory make sure it doesn't access beyond; // the bounds of the allocated object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:60,Security,access,access,60,// If this instruction accesses memory make sure it doesn't access beyond; // the bounds of the allocated object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:40,Performance,load,load,40,"// cmpxchg conceptually includes both a load and store from the same; // location. So, like store, the value being stored is what matters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:136,Security,access,access,136,"// If the GEP offset is out-of-bounds, or is non-constant and so has to be; // assumed to be potentially out-of-bounds, then any memory access that; // would use it could also be out-of-bounds meaning stack protection is; // required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:107,Performance,scalab,scalable,107,"// Adjust AllocSize to be the space remaining after this offset.; // We can't subtract a fixed size from a scalable one, so in that case; // assume the scalable value is of minimum size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:152,Performance,scalab,scalable,152,"// Adjust AllocSize to be the space remaining after this offset.; // We can't subtract a fixed size from a scalable one, so in that case; // assume the scalable value is of minimum size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:56,Performance,load,load-like,56,"// These instructions take an address operand, but have load-like or; // other innocuous behavior that should not trigger a stack protector.; // atomicrmw conceptually has both load and store semantics, but the; // value being stored must be integer; so if a pointer is being stored,; // we'll catch it in the PtrToInt case above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:177,Performance,load,load,177,"// These instructions take an address operand, but have load-like or; // other innocuous behavior that should not trigger a stack protector.; // atomicrmw conceptually has both load and store semantics, but the; // value being stored must be integer; so if a pointer is being stored,; // we'll catch it in the PtrToInt case above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:231,Modifiability,variab,variable,231,"/// Check whether or not this function needs a stack protector based; /// upon the stack protector level.; ///; /// We use two heuristics: a standard (ssp) and strong (sspstrong).; /// The standard heuristic which will add a guard variable to functions that; /// call alloca with a either a variable size or a size >= SSPBufferSize,; /// functions with character buffers larger than SSPBufferSize, and functions; /// with aggregates containing character buffers larger than SSPBufferSize. The; /// strong heuristic will add a guard variables to functions that call alloca; /// regardless of size, functions with any buffer regardless of type and size,; /// functions with aggregates that contain any buffer regardless of type and; /// size, and functions that contain stack-based variables that have had their; /// address taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:291,Modifiability,variab,variable,291,"/// Check whether or not this function needs a stack protector based; /// upon the stack protector level.; ///; /// We use two heuristics: a standard (ssp) and strong (sspstrong).; /// The standard heuristic which will add a guard variable to functions that; /// call alloca with a either a variable size or a size >= SSPBufferSize,; /// functions with character buffers larger than SSPBufferSize, and functions; /// with aggregates containing character buffers larger than SSPBufferSize. The; /// strong heuristic will add a guard variables to functions that call alloca; /// regardless of size, functions with any buffer regardless of type and size,; /// functions with aggregates that contain any buffer regardless of type and; /// size, and functions that contain stack-based variables that have had their; /// address taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:532,Modifiability,variab,variables,532,"/// Check whether or not this function needs a stack protector based; /// upon the stack protector level.; ///; /// We use two heuristics: a standard (ssp) and strong (sspstrong).; /// The standard heuristic which will add a guard variable to functions that; /// call alloca with a either a variable size or a size >= SSPBufferSize,; /// functions with character buffers larger than SSPBufferSize, and functions; /// with aggregates containing character buffers larger than SSPBufferSize. The; /// strong heuristic will add a guard variables to functions that call alloca; /// regardless of size, functions with any buffer regardless of type and size,; /// functions with aggregates that contain any buffer regardless of type and; /// size, and functions that contain stack-based variables that have had their; /// address taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:780,Modifiability,variab,variables,780,"/// Check whether or not this function needs a stack protector based; /// upon the stack protector level.; ///; /// We use two heuristics: a standard (ssp) and strong (sspstrong).; /// The standard heuristic which will add a guard variable to functions that; /// call alloca with a either a variable size or a size >= SSPBufferSize,; /// functions with character buffers larger than SSPBufferSize, and functions; /// with aggregates containing character buffers larger than SSPBufferSize. The; /// strong heuristic will add a guard variables to functions that call alloca; /// regardless of size, functions with any buffer regardless of type and size,; /// functions with aggregates that contain any buffer regardless of type and; /// size, and functions that contain stack-based variables that have had their; /// address taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:54,Modifiability,variab,variable,54,// The set of PHI nodes visited when determining if a variable's reference has; // been taken. This set is maintained to ensure we don't visit the same PHI; // node multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:167,Availability,avail,available,167,// We are constructing the OptimizationRemarkEmitter on the fly rather than; // using the analysis pass to avoid building DominatorTree and LoopInfo which; // are not available this late in the IR pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:197,Deployability,pipeline,pipeline,197,// We are constructing the OptimizationRemarkEmitter on the fly rather than; // using the analysis pass to avoid building DominatorTree and LoopInfo which; // are not available this late in the IR pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:27,Performance,Optimiz,OptimizationRemarkEmitter,27,// We are constructing the OptimizationRemarkEmitter on the fly rather than; // using the analysis pass to avoid building DominatorTree and LoopInfo which; // are not available this late in the IR pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:107,Safety,avoid,avoid,107,// We are constructing the OptimizationRemarkEmitter on the fly rather than; // using the analysis pass to avoid building DominatorTree and LoopInfo which; // are not available this late in the IR pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:27,Modifiability,variab,variable,27,// A call to alloca with a variable size requires protectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:3,Usability,Clear,Clear,3,"// Clear any PHIs that we visited, to make sure we examine all uses of; // any subsequent allocas that we look at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:25,Performance,load,loading,25,/// Create a stack guard loading and populate whether SelectionDAG SSP is; /// supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:150,Performance,perform,perform,150,"// Use SelectionDAG SSP handling, since there isn't an IR guard.; //; // This is more or less weird, since we optionally output whether we; // should perform a SelectionDAG SP here. The reason is that it's strictly; // defined as !TLI->getIRStackGuard(B), where getIRStackGuard is also; // mutating. There is no way to get this bit without mutating the IR, so; // getting this bit has to happen in this right time.; //; // We could have define a new function TLI::supportsSelectionDAGSP(), but that; // will put more burden on the backends' overriding work, especially when it; // actually conveys the same information getIRStackGuard() already gives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:70,Modifiability,variab,variable,70,"/// Insert code into the entry block that stores the stack guard; /// variable onto the stack:; ///; /// entry:; /// StackGuardSlot = alloca i8*; /// StackGuard = <stack guard>; /// call void @llvm.stackprotector(StackGuard, StackGuardSlot); ///; /// Returns true if the platform/triple supports the stackprotectorcreate pseudo; /// node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:103,Integrability,depend,depending,103,// Generate epilogue instrumentation. The epilogue intrumentation can be; // function-based or inlined depending on which mechanism the target is; // providing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:309,Performance,load,load,309,"// Generate the epilogue with inline instrumentation.; // If we do not support SelectionDAG based calls, generate IR level; // calls.; //; // For each block with a return instruction, convert this:; //; // return:; // ...; // ret ...; //; // into this:; //; // return:; // ...; // %1 = <stack guard>; // %2 = load StackGuardSlot; // %3 = icmp ne i1 %1, %2; // br i1 %3, label %CallStackCheckFailBlk, label %SP_return; //; // SP_return:; // ret ...; //; // CallStackCheckFailBlk:; // call void @__stack_chk_fail(); // unreachable; // Create the FailBB. We duplicate the BB every time since the MI tail; // merge pass will merge together all of the various BB into one including; // fail BB generated by the stack protector pseudo instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:101,Testability,test,test,101,// Join all intervals sharing one color into a single LiveIntervalUnion to; // speedup range overlap test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:29,Safety,avoid,avoid,29,// Single liverange (used to avoid creation of LiveIntervalUnion).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:24,Performance,perform,perform,24,// LiveIntervalUnion to perform overlap test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:40,Testability,test,test,40,// LiveIntervalUnion to perform overlap test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:124,Deployability,update,update,124,// end anonymous namespace; /// ScanForSpillSlotRefs - Scan all the machine instructions for spill slot; /// references and update spill slot weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:26,Availability,avail,available,26,// Assign it to the first available color (assumed to be the best) if it's; // not possible to share a used color with other objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:36,Energy Efficiency,allocate,allocated,36,"// Change size and alignment of the allocated slot. If there are multiple; // objects sharing the same slot, then make sure the size and alignment; // are large enough for all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:49,Modifiability,rewrite,rewrite,49,/// Colorslots - Color all spill stack slots and rewrite all frameindex machine; /// operands in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all MachineMemOperands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all MO_FrameIndex operands. Look for dead stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:4,Modifiability,Rewrite,RewriteInstruction,4,/// RewriteInstruction - Rewrite specified instruction by replacing references; /// to old frame index with new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:25,Modifiability,Rewrite,Rewrite,25,/// RewriteInstruction - Rewrite specified instruction by replacing references; /// to old frame index with new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:3,Deployability,Update,Update,3,// Update the operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:44,Deployability,update,updated,44,// The MachineMemOperands have already been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:63,Performance,load,loads,63,"/// RemoveDeadStores - Scan through a basic block and look for loads followed; /// by stores. If they're both using the same stack slot, then the store is; /// definitely dead. This could obviously be much more aggressive (consider; /// pairs with instructions between them), but such extensions might have a; /// considerable compile time impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:58,Performance,load,load,58,// Skip the ...pseudo debugging... instructions between a load and store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:52,Performance,perform,perform,52,"// If there are calls to setjmp or sigsetjmp, don't perform stack slot; // coloring. The stack could be modified before the longjmp is executed,; // resulting in the wrong value being used afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:179,Security,expose,exposed,179,"// If this is the first use of this swifterror value in this basic block,; // create a new virtual register.; // After we processed all basic blocks we will satisfy this ""upwards exposed; // use"" by inserting a copy or phi at the beginning of this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:156,Availability,down,downward,156,// If there is no upwards exposed use and an entry for the swifterror in; // the def map for this value we don't need to do anything: We already; // have a downward def for this basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:26,Security,expose,exposed,26,// If there is no upwards exposed use and an entry for the swifterror in; // the def map for this value we don't need to do anything: We already; // have a downward def for this basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:111,Availability,down,downward,111,// Otherwise we either have an upwards exposed use vreg that we need to; // materialize or need to forward the downward def from predecessors.; // Check whether we have a single vreg def from all predecessors.; // Otherwise we need a phi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:39,Security,expose,exposed,39,// Otherwise we either have an upwards exposed use vreg that we need to; // materialize or need to forward the downward def from predecessors.; // Check whether we have a single vreg def from all predecessors.; // Otherwise we need a phi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:78,Availability,down,downward,78,// We need a phi node if we have more than one predecessor with different; // downward defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:26,Security,expose,exposed,26,// If there is no upwards exposed used and we don't need a phi just; // forward the swifterror vreg from the predecessor(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:54,Security,expose,exposed,54,// If we don't need a phi create a copy to the upward exposed vreg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:41,Security,expose,exposed,41,// We need a phi: if there is an upwards exposed use we already have a; // destination virtual register number otherwise we generate a new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:93,Availability,down,downward,93,// We did not have a definition in this block before: store the phi's vreg; // as this block downward exposed def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:102,Security,expose,exposed,102,// We did not have a definition in this block before: store the phi's vreg; // as this block downward exposed def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:5,Performance,load,load,5,// A load is a use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:423,Performance,optimiz,optimizations,423,"//===- SwitchLoweringUtils.cpp - Switch Lowering --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains switch inst lowering optimizations and utilities for; // codegen, so that it can be used for both SelectionDAG and GlobalISel.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:36,Safety,avoid,avoid,36,// Note: loop indexes are signed to avoid underflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:50,Testability,test,tests,50,// Clusters[First..Last] should be lowered as bit tests instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:28,Performance,load,load,28,"// Create the MBB that will load from and jump through the table.; // Note: We create it here, but it's not inserted into the function yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:61,Testability,test,tests,61,"// If target does not have legal shift left, do not emit bit tests at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:63,Testability,test,test,63,// FIXME: This might not be the best algorithm for finding bit test clusters.; // Base case: There is only one way to partition Clusters[N-1].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:36,Safety,avoid,avoid,36,// Note: loop indexes are signed to avoid underflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:93,Energy Efficiency,efficient,efficient,93,"// Check nbr of destinations and cluster types.; // FIXME: This works, but doesn't seem very efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:51,Testability,test,test,51,"// Iterate over the partitions, replacing with bit-test clusters in-place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the case where all the case values fit in a word without having; // to subtract minValue. In this case, we can optimize away the subtraction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:123,Performance,optimiz,optimize,123,"// Optimize the case where all the case values fit in a word without having; // to subtract minValue. In this case, we can optimize away the subtraction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:10,Availability,Mask,Mask,10,"// Update Mask, Bits and ExtraProb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:3,Deployability,Update,Update,3,"// Update Mask, Bits and ExtraProb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:57,Availability,mask,mask,57,"// Sort by probability first, number of bits second, bit mask third.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:236,Energy Efficiency,efficient,efficient,236,"// Our binary search tree differs from a typical BST in that ours can have; // up to three values in each leaf. The pivot selection above doesn't take; // that into account, which means the tree might require more nodes and be; // less efficient. We compensate for this here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Deployability,Update,Update,3,// Update SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:60,Availability,avail,available,60,"// If the original definition is still around, add it as an available; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:24,Availability,avail,available,24,// Add the new vregs as available values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite uses that are outside of the original def's block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite debug uses last so that they can take advantage of any; // register mappings introduced by other users in its BB, since we; // cannot create new register definitions specifically for the debug; // instruction (as debug instructions should not affect CodeGen).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:63,Deployability,update,update,63,/// Add a definition and source virtual registers pair for SSA update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:135,Deployability,update,update,135,/// Process PHI node in TailBB by turning it into a copy in PredBB. Remember the; /// source register that's contributed by PredBB and update SSA update map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:146,Deployability,update,update,146,/// Process PHI node in TailBB by turning it into a copy in PredBB. Remember the; /// source register that's contributed by PredBB and update SSA update map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:82,Availability,avail,available,82,// Insert a copy from source to the end of the block. The def register is the; // available value liveout of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:49,Deployability,update,update,49,/// Duplicate a TailBB instruction to PredBB and update; /// the source operands due to earlier PHI translation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:56,Usability,simpl,simply,56,"// For mapped registers that do not have sub-registers, simply; // restrict their class to match the original one.; // We don't want debug instructions affecting the resulting code so; // if we're cloning a debug instruction then just use MappedRC; // rather than constraining the register class further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:47,Usability,simpl,simply,47,"// If the class constraining succeeded, we can simply replace; // the old register with the mapped one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Usability,Clear,Clear,3,"// Clear any kill flags from this operand. The new register could; // have uses after this one, so kills are not valid here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:115,Deployability,Update,Update,115,"/// After FromBB is tail duplicated into its predecessor blocks, the successors; /// have gained new predecessors. Update the PHI instructions in them; /// accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:94,Safety,avoid,avoid,94,"// If Idx is set, the operands at Idx and Idx+1 must be removed.; // We reuse the location to avoid expensive removeOperand calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:163,Safety,avoid,avoid,163,"// If we didn't duplicate a bb into a particular predecessor, we; // might still have added an entry to SSAUpdateVals to correcly; // recompute SSA. If that case, avoid adding a dummy extra argument; // this PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:48,Performance,optimiz,optimizing,48,"// Set the limit on the cost to duplicate. When optimizing for size,; // duplicate only one, because one branch instruction can be eliminated to; // compensate for the duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:279,Performance,optimiz,optimizations,279,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:37,Safety,predict,prediction,37,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:124,Safety,predict,predictable,124,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:233,Usability,undo,undoing,233,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:90,Integrability,depend,dependencies,90,"// Convergent instructions can be duplicated only if doing so doesn't add; // new control dependencies, which is what we're going to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Safety,Avoid,Avoid,3,// Avoid duplicating calls before register allocation. Calls presents a; // barrier to register allocation so duplicating them may end up increasing; // spills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:479,Safety,abort,abort,479,"// Check if any of the successors of TailBB has a PHI node in which the; // value corresponding to TailBB uses a subregister.; // If a phi node uses a register paired with a subregister, the actual; // ""value type"" of the phi may differ from the type of the register without; // any subregisters. Due to a bug, tail duplication may add a new operand; // without a necessary subregister, producing an invalid code. This is; // demonstrated by test/CodeGen/Hexagon/tail-dup-subreg-abort.ll.; // Disable tail duplication for this case for now, until the problem is; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:442,Testability,test,test,442,"// Check if any of the successors of TailBB has a PHI node in which the; // value corresponding to TailBB uses a subregister.; // If a phi node uses a register paired with a subregister, the actual; // ""value type"" of the phi may differ from the type of the register without; // any subregisters. Due to a bug, tail duplication may add a new operand; // without a necessary subregister, producing an invalid code. This is; // demonstrated by test/CodeGen/Hexagon/tail-dup-subreg-abort.ll.; // Disable tail duplication for this case for now, until the problem is; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Safety,Avoid,Avoid,3,// Avoid adding fall through branches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:487,Availability,redundant,redundant,487,"/// If it is profitable, duplicate TailBB's contents in each; /// of its predecessors.; /// \p IsSimple result of isSimpleBB; /// \p TailBB Block to be duplicated.; /// \p ForcedLayoutPred When non-null, use this block as the layout predecessor; /// instead of the previous block in MF's order.; /// \p TDBBs A vector to keep track of all blocks tail-duplicated; /// into.; /// \p Copies A vector of copy instructions inserted. Used later to; /// walk all the inserted copies and remove redundant ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:487,Safety,redund,redundant,487,"/// If it is profitable, duplicate TailBB's contents in each; /// of its predecessors.; /// \p IsSimple result of isSimpleBB; /// \p TailBB Block to be duplicated.; /// \p ForcedLayoutPred When non-null, use this block as the layout predecessor; /// instead of the previous block in MF's order.; /// \p TDBBs A vector to keep track of all blocks tail-duplicated; /// into.; /// \p Copies A vector of copy instructions inserted. Used later to; /// walk all the inserted copies and remove redundant ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:145,Safety,avoid,avoids,145,"// Iterate through all the unique predecessors and tail-duplicate this; // block into them, if possible. Copying the list ahead of time also; // avoids trouble with the predecessor list reallocating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:89,Availability,avail,available,89,"// Don't duplicate into a fall-through predecessor (at least for now).; // If profile is available, findDuplicateCandidates can choose better; // fall-through predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:60,Deployability,update,update,60,"// Replace def of virtual registers with new registers, and update; // uses with PHI source register or the new registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:39,Deployability,Update,Update,39,// subtract one for removed branch; // Update the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Deployability,Update,Update,3,// Update branches in pred to jump to tail's layout successor if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:41,Safety,abort,abort,41,"// If there are still tail instructions, abort the merge",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:60,Deployability,update,update,60,"// Replace def of virtual registers with new registers, and update; // uses with PHI source register or the new registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Deployability,Update,Update,3,// Update branches in PrevBB based on Tail's layout successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:40,Safety,safe,safe,40,"// If we made no changes so far, we are safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Deployability,Update,Update,3,// Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp:60,Integrability,interface,interface,60,"//===- TargetFrameLoweringImpl.cpp - Implement target frame interface ------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements the layout of a stack frame on the target machine.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp:26,Performance,optimiz,optimized,26,// Function should not be optimized as tail call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetFrameLoweringImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:335,Modifiability,Variab,Variable-length,335,"/// Measure the specified inline asm to determine an approximation of its; /// length.; /// Comments (which run till the next SeparatorString or newline) do not; /// count as an instruction.; /// Any other non-whitespace text is considered an instruction, with; /// multiple instructions separated by SeparatorString or newlines.; /// Variable-length instructions are not handled here; this function; /// may be overloaded in the target code to do that.; /// We implement a special case of the .space directive which takes only a; /// single integer argument in base 10 that is the size in bytes. This is a; /// restricted form of the GAS directive in that we only interpret; /// simple--i.e. not a logical or arithmetic expression--size values without; /// the optional fill value. This is primarily used for creating arbitrary; /// sized inline asm blocks for testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:699,Testability,log,logical,699,"/// Measure the specified inline asm to determine an approximation of its; /// length.; /// Comments (which run till the next SeparatorString or newline) do not; /// count as an instruction.; /// Any other non-whitespace text is considered an instruction, with; /// multiple instructions separated by SeparatorString or newlines.; /// Variable-length instructions are not handled here; this function; /// may be overloaded in the target code to do that.; /// We implement a special case of the .space directive which takes only a; /// single integer argument in base 10 that is the size in bytes. This is a; /// restricted form of the GAS directive in that we only interpret; /// simple--i.e. not a logical or arithmetic expression--size values without; /// the optional fill value. This is primarily used for creating arbitrary; /// sized inline asm blocks for testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:862,Testability,test,testing,862,"/// Measure the specified inline asm to determine an approximation of its; /// length.; /// Comments (which run till the next SeparatorString or newline) do not; /// count as an instruction.; /// Any other non-whitespace text is considered an instruction, with; /// multiple instructions separated by SeparatorString or newlines.; /// Variable-length instructions are not handled here; this function; /// may be overloaded in the target code to do that.; /// We implement a special case of the .space directive which takes only a; /// single integer argument in base 10 that is the size in bytes. This is a; /// restricted form of the GAS directive in that we only interpret; /// simple--i.e. not a logical or arithmetic expression--size values without; /// the optional fill value. This is primarily used for creating arbitrary; /// sized inline asm blocks for testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:680,Usability,simpl,simple--i,680,"/// Measure the specified inline asm to determine an approximation of its; /// length.; /// Comments (which run till the next SeparatorString or newline) do not; /// count as an instruction.; /// Any other non-whitespace text is considered an instruction, with; /// multiple instructions separated by SeparatorString or newlines.; /// Variable-length instructions are not handled here; this function; /// may be overloaded in the target code to do that.; /// We implement a special case of the .space directive which takes only a; /// single integer argument in base 10 that is the size in bytes. This is a; /// restricted form of the GAS directive in that we only interpret; /// simple--i.e. not a logical or arithmetic expression--size values without; /// the optional fill value. This is primarily used for creating arbitrary; /// sized inline asm blocks for testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Deployability,Update,Update,3,// Update call site info and remove all the dead instructions; // from the end of MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid calling isRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:60,Testability,assert,assert,60,// Avoid calling isRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:89,Deployability,update,updated,89,"// If destination is tied to either of the commuted source register, then; // it must be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid calling setIsRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:63,Testability,assert,assert,63,// Avoid calling setIsRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:7,Deployability,Patch,PatchPoint,7,"// For PatchPoint, the call args are not foldable (even if reported in the; // stackmap e.g. via anyregcc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:64,Deployability,patch,patchpoint,64,// getPatchpointUnfoldableRange throws guarantee if MI is not a patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Deployability,Update,Update,3,"// Update mayload/maystore metadata, and memoperands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:26,Performance,load,load,26,"// If we're not folding a load into a subreg, the size of the load is the; // size of the spill slot. But if we are, we need to figure out what the; // actual load size is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:62,Performance,load,load,62,"// If we're not folding a load into a subreg, the size of the load is the; // size of the spill slot. But if we are, we need to figure out what the; // actual load size is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:159,Performance,load,load,159,"// If we're not folding a load into a subreg, the size of the load is the; // size of the spill slot. But if we are, we need to figure out what the; // actual load size is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:17,Deployability,patch,patchpoint,17,// Fold stackmap/patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:29,Performance,load,load,29,"// The pass ""x86 speculative load hardening"" always attaches symbols to; // call instructions. We need copy it form old instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:29,Performance,load,load,29,// Straight COPY may fold as load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:17,Deployability,patch,patchpoint,17,// Fold stackmap/patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:33,Performance,load,load,33,// Copy the memoperands from the load to the folded instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:44,Performance,load,loads,44,// Handle the rare case of folding multiple loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:348,Deployability,pipeline,pipeline,348,"// The concept of the reassociation pass is that these operations can benefit; // from this kind of transformation:; //; // A = ? op ?; // B = A op X (Prev); // C = B op Y (Root); // -->; // A = ? op ?; // B = X op Y; // C = A op B; //; // breaking the dependency between A and B, allowing them to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; // FIXME: This has the potential to be expensive (compile time) while not; // improving the code at all. Some ways to limit the overhead:; // 1. Track successful transforms; bail out if hit rate gets too low.; // 2. Only enable at -O3 or some other non-default optimization level.; // 3. Pre-screen pattern candidates here: if an operand of the previous; // instruction is known to not increase the critical path, then don't match; // that pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:253,Integrability,depend,dependency,253,"// The concept of the reassociation pass is that these operations can benefit; // from this kind of transformation:; //; // A = ? op ?; // B = A op X (Prev); // C = B op Y (Root); // -->; // A = ? op ?; // B = X op Y; // C = A op B; //; // breaking the dependency between A and B, allowing them to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; // FIXME: This has the potential to be expensive (compile time) while not; // improving the code at all. Some ways to limit the overhead:; // 1. Track successful transforms; bail out if hit rate gets too low.; // 2. Only enable at -O3 or some other non-default optimization level.; // 3. Pre-screen pattern candidates here: if an operand of the previous; // instruction is known to not increase the critical path, then don't match; // that pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:369,Integrability,depend,depending,369,"// The concept of the reassociation pass is that these operations can benefit; // from this kind of transformation:; //; // A = ? op ?; // B = A op X (Prev); // C = B op Y (Root); // -->; // A = ? op ?; // B = X op Y; // C = A op B; //; // breaking the dependency between A and B, allowing them to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; // FIXME: This has the potential to be expensive (compile time) while not; // improving the code at all. Some ways to limit the overhead:; // 1. Track successful transforms; bail out if hit rate gets too low.; // 2. Only enable at -O3 or some other non-default optimization level.; // 3. Pre-screen pattern candidates here: if an operand of the previous; // instruction is known to not increase the critical path, then don't match; // that pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:656,Performance,optimiz,optimization,656,"// The concept of the reassociation pass is that these operations can benefit; // from this kind of transformation:; //; // A = ? op ?; // B = A op X (Prev); // C = B op Y (Root); // -->; // A = ? op ?; // B = X op Y; // C = A op B; //; // breaking the dependency between A and B, allowing them to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; // FIXME: This has the potential to be expensive (compile time) while not; // improving the code at all. Some ways to limit the overhead:; // 1. Track successful transforms; bail out if hit rate gets too low.; // 2. Only enable at -O3 or some other non-default optimization level.; // 3. Pre-screen pattern candidates here: if an operand of the previous; // instruction is known to not increase the critical path, then don't match; // that pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:54,Performance,throughput,throughput,54,/// Return true when a code sequence can improve loop throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:48,Energy Efficiency,reduce,reduce,48,/// Attempt the reassociation transformation to reduce critical path length.; /// See the above comments before getMachineCombinerPatterns().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:62,Usability,clear,clear,62,// Propagate FP flags from the original instructions.; // But clear poison-generating flags because those may not be valid now.; // TODO: There should be a helper function for copying only fast-math-flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:237,Safety,safe,safely,237,// A sub-register definition can only be rematerialized if the instruction; // doesn't read the other parts of the register. Otherwise it is really a; // read-modify-write operation on the full virtual register which cannot be; // moved safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:73,Availability,redundant,redundant,73,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:5,Performance,load,load,5,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:73,Safety,redund,redundant,73,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:140,Usability,simpl,simple,140,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid instructions obviously unsafe for remat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:32,Safety,unsafe,unsafe,32,// Avoid instructions obviously unsafe for remat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:28,Performance,load,load,28,// Avoid instructions which load from potentially varying memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid instructions which load from potentially varying memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:27,Security,access,accessed,27,"// If any of the registers accessed are non-constant, conservatively assume; // the instruction is not rematerializable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:160,Energy Efficiency,allocate,allocated,160,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:85,Energy Efficiency,schedul,scheduling,85,/// isSchedulingBoundary - Test if the given instruction should be; /// considered a scheduling boundary. This primarily includes labels; /// and terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:27,Testability,Test,Test,27,/// isSchedulingBoundary - Test if the given instruction should be; /// considered a scheduling boundary. This primarily includes labels; /// and terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:35,Energy Efficiency,schedul,scheduled,35,// Terminators and labels can't be scheduled around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:20,Energy Efficiency,schedul,schedule,20,"// Don't attempt to schedule around any instruction that defines; // a stack-oriented pointer, as it's unlikely to be profitable. This; // saves compile time, because it doesn't require every single; // stack slot reference to depend on the instruction that does the; // modification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:227,Integrability,depend,depend,227,"// Don't attempt to schedule around any instruction that defines; // a stack-oriented pointer, as it's unlikely to be profitable. This; // saves compile time, because it doesn't require every single; // stack slot reference to depend on the instruction that does the; // modification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:49,Safety,hazard,hazard,49,// Provide a global flag for disabling the PreRA hazard recognizer that targets; // may choose to honor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:9,Safety,hazard,hazard,9,// Dummy hazard recognizer allows all instructions to issue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:106,Integrability,interface,interface,106,//===----------------------------------------------------------------------===//; // SelectionDAG latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:98,Performance,latency,latency,98,//===----------------------------------------------------------------------===//; // SelectionDAG latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:106,Integrability,interface,interface,106,//===----------------------------------------------------------------------===//; // MachineInstr latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:98,Performance,latency,latency,98,//===----------------------------------------------------------------------===//; // MachineInstr latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:32,Performance,latency,latency,32,/// Return the default expected latency for a def based on it's opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:6,Usability,simpl,simplify,6,"// To simplify the sub-register handling, verify that we only need to; // consider physical registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:10,Performance,Scalab,Scalable,10,// FIXME: Scalable offsets are not yet handled in the offset code below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:26,Safety,safe,safely,26,// Labels generally can't safely be outlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:692,Availability,down,down,692,"// Make sure none of the operands of this instruction do anything that; // might break if they're moved outside their current function.; // This includes MachineBasicBlock references, BlockAddressses,; // Constant pool indices and jump table indices.; //; // A quick note on MO_TargetIndex:; // This doesn't seem to be used in any of the architectures that the; // MachineOutliner supports, but it was still filtered out in all of them.; // There was one exception (RISC-V), but MO_TargetIndex also isn't used there.; // As such, this check is removed both here and in the target-specific; // implementations. Instead, we assert to make sure this doesn't; // catch anyone off-guard somewhere down the line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:622,Testability,assert,assert,622,"// Make sure none of the operands of this instruction do anything that; // might break if they're moved outside their current function.; // This includes MachineBasicBlock references, BlockAddressses,; // Constant pool indices and jump table indices.; //; // A quick note on MO_TargetIndex:; // This doesn't seem to be used in any of the architectures that the; // MachineOutliner supports, but it was still filtered out in all of them.; // There was one exception (RISC-V), but MO_TargetIndex also isn't used there.; // As such, this check is removed both here and in the target-specific; // implementations. Instead, we assert to make sure this doesn't; // catch anyone off-guard somewhere down the line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:19,Testability,assert,assertion,19,"// If you hit this assertion, please remove it and adjust; // `getOutliningTypeImpl` for your target appropriately if necessary.; // Adding the assertion back to other supported architectures; // would be nice too :)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:144,Testability,assert,assertion,144,"// If you hit this assertion, please remove it and adjust; // `getOutliningTypeImpl` for your target appropriately if necessary.; // Adding the assertion back to other supported architectures; // would be nice too :)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:33,Testability,test,test,33,"// FIXME: This option is only to test if the strict fp operation processed; // correctly by preventing mutating strict fp operation to normal fp operation; // during development. When the backend supports strict float operation, this; // option will be meaningless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:24,Performance,optimiz,optimized,24,// Some darwins have an optimized __bzero/bzero function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Performance,Perform,Perform,3,// Perform these initializations only once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:23,Performance,load,load,23,// Default all indexed load / store to expand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:69,Performance,load,loaded,69,// Most backends expect to see the node which just returns the value loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:155,Performance,optimiz,optimize,155,"// ConstantFP nodes default to expand. Targets can either change this to; // Legal, in which case all fp constants are legal, or use isFPImmLegal(); // to optimize expansions for certain constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:52,Safety,abort,abort,52,// Default ISD::TRAP to expand (which turns it into abort).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:86,Safety,safe,safe,86,"// If any possible shift value won't fit in the prefered type, just use; // something safe. Assume it will be legalized when the shift is expanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:16,Usability,simpl,simple,16,"// If this is a simple type, use the ComputeRegisterProp mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:10,Modifiability,Extend,Extended,10,// Handle Extended Scalar Types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:22,Energy Efficiency,power,power-of-two,22,"// First promote to a power-of-two size, then expand if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Safety,Avoid,Avoid,3,// Avoid multi-step promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:60,Energy Efficiency,power,power,60,"// Try to widen vector elements until the element type is a power of two and; // promote it to a legal type later on, for example:; // <3 x i8> -> <4 x i8> -> <4 x i32>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:51,Energy Efficiency,power,power,51,"// Vectors with a number of elements that is not a power of two are always; // widened, for example <3 x i8> -> <4 x i8>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:34,Usability,simpl,simple,34,// Stop trying when getting a non-simple element type.; // Note that vector elements may be greater than legal vector element; // types. Example: X86 XMM registers hold 64bit element on 32bit; // systems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:24,Energy Efficiency,power,power,24,// Round up to the next power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:18,Usability,simpl,simple,18,// If there is no simple vector type with this many elements then there; // cannot be a larger legal vector type. Note that this assumes that; // there are no skipped intermediate vector types in the simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:200,Usability,simpl,simple,200,// If there is no simple vector type with this many elements then there; // cannot be a larger legal vector type. Note that this assumes that; // there are no skipped intermediate vector types in the simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:29,Energy Efficiency,power,power,29,// Widen odd vectors to next power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot be scalarized, so splitting or widening is; // required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:92,Availability,down,down,92,// FIXME: We don't support non-power-of-2-sized vectors for now.; // Ideally we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:31,Energy Efficiency,power,power-of-,31,// FIXME: We don't support non-power-of-2-sized vectors for now.; // Ideally we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:26,Performance,scalab,scalable,26,// Split EC to unit size (scalable property is preserved).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:122,Performance,scalab,scalable,122,// Divide the input until we get to a supported size. This will; // always end up with an EC that represent a scalar or a scalable; // scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:63,Integrability,depend,dependent,63,/// Replace/modify any TargetFrameIndex operands with a targte-dependent; /// sequence of memory operands that is recognized by PrologEpilogInserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:55,Deployability,PATCH,PATCHPOINT,55,"// We're handling multiple types of operands here:; // PATCHPOINT MetaArgs - live-in, read only, direct; // STATEPOINT Deopt Spill - live-through, read only, indirect; // STATEPOINT Deopt Alloca - live-through, read only, direct; // (We're currently conservative and mark the deopt slots read/write in; // practice.); // STATEPOINT GC Spill - live-through, read/write, indirect; // STATEPOINT GC Alloca - live-through, read/write, direct; // The live-in vs live-through is handled already (the live through ones are; // all stack slots), but we need to handle the different type of stackmap; // operands and memory effects here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit previous memory operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:130,Deployability,patch,patchpoints,130,"// indirect-mem-ref tag, size, #FI, offset.; // Used for spills inserted by StatepointLowering. This codepath is not; // used for patchpoints/stackmaps at all, for these spilling is done via; // foldMemoryOperand callback only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:48,Deployability,patch,patchpoint,48,"// direct-mem-ref tag, #FI, offset.; // Used by patchpoint, and direct alloca arguments to statepoints",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:74,Deployability,PATCH,PATCHPOINT,74,"// Note: STATEPOINT MMOs are added during SelectionDAG. STACKMAP, and; // PATCHPOINT should be updated to do the same. (TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:95,Deployability,update,updated,95,"// Note: STATEPOINT MMOs are added during SelectionDAG. STACKMAP, and; // PATCHPOINT should be updated to do the same. (TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:129,Security,expose,expose,129,"/// computeRegisterProperties - Once all of the register classes are added,; /// this allows us to compute derived properties we expose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:26,Energy Efficiency,power,power,26,// Only widen to the next power of 2 to keep consistency with EVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:21,Energy Efficiency,power,power,21,// Type is already a power of 2. The default action is to split.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:53,Availability,down,down,53,"/// getVectorTypeBreakdown - Vector types are broken down into some number of; /// legal first class types. For example, MVT::v8f32 maps to 2 MVT::v4f32; /// with Altivec or SSE1, or 8 promoted MVT::f64 values with the X86 FP stack.; /// Similarly, MVT::v2i64 turns into 4 MVT::i32 values with both PPC and X86.; ///; /// This method returns the number of registers needed, and the VT for each; /// register. It also returns the VT and quantity of the intermediate values; /// before they are promoted/expanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot be scalarized, so handle the legalisation of the; // types like done elsewhere in SelectionDAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:92,Availability,down,down,92,// FIXME: We don't support non-power-of-2-sized vectors for now. Ideally; // we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:31,Energy Efficiency,power,power-of-,31,// FIXME: We don't support non-power-of-2-sized vectors for now. Ideally; // we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:228,Performance,perform,performed,228,"// FIXME: This function check the maximum table size and density, but the; // minimum size is not checked. It would be nice if the minimum size is; // also combined within this function. Currently, the minimum size check is; // performed in findJumpTable() in SelectionDAGBuiler and; // getEstimatedNumberOfCaseClusters() in BasicTTIImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:174,Testability,log,logarithm,174,"/// getByValTypeAlignment - Return the desired alignment for ByVal aggregate; /// function arguments in the caller parameter area. This is the actual; /// alignment, not its logarithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:18,Security,access,access,18,// Assume that an access that meets the ABI-specified alignment is fast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:24,Security,access,access,24,// This is a misaligned access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:26,Modifiability,variab,variable,26,// compiler-rt provides a variable with a magic name. Targets that do not; // link with compiler-rt may also provide such a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:124,Modifiability,variab,variable,124,// compiler-rt provides a variable with a magic name. Targets that do not; // link with compiler-rt may also provide such a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:14,Modifiability,variab,variable,14,"// The global variable is not defined yet, define it ourselves.; // We use the initial-exec TLS model because we do not support the; // variable living anywhere other than in the main executable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:136,Modifiability,variab,variable,136,"// The global variable is not defined yet, define it ourselves.; // We use the initial-exec TLS model because we do not support the; // variable living anywhere other than in the main executable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:7,Modifiability,variab,variable,7,"// The variable exists, check its type and attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:88,Safety,unsafe,unsafe,88,// Android provides a libc function to retrieve the address of the current; // thread's unsafe stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:316,Performance,load,load,316,"//===----------------------------------------------------------------------===//; // Loop Strength Reduction hooks; //===----------------------------------------------------------------------===//; /// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:116,Modifiability,extend,extended,116,"// The default implementation of this implements a conservative RISCy, r+r and; // r+i addr mode.; // Allows a sign-extended 16-bit immediate field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:22,Integrability,depend,depending,22,"// ""r+i"" or just ""i"", depending on HasBaseReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:224,Modifiability,variab,variable,224,"//===----------------------------------------------------------------------===//; // Stack Protector; //===----------------------------------------------------------------------===//; // For OpenBSD return its special guard variable. Otherwise return nullptr,; // so that SelectionDAG handle SSP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:65,Safety,avoid,avoid,65,"// Single-element vectors are scalarized, so we should generally avoid having; // any memory operations on such types, as they would get scalarized too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:38,Performance,load,load,38,"// Don't do if we could do an indexed load on the original type, but not on; // the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:267,Safety,avoid,avoid,267,"// The small model guarantees static code/data size < 4GB, but not where it; // will be in memory. Most of these could end up >2GB away so even a signed; // pc-relative 32-bit address is insufficient, theoretically.; //; // Use DW_EH_PE_indirect even for -fno-pic to avoid copy relocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:77,Availability,avail,available,77,// Emit a descriptor for every function including functions that have an; // available external linkage. We may not want this for imported functions; // that has code in another thinLTO module but we don't have a good way to; // tell them apart from inline functions defined in header files. Therefore; // we put each descriptor in a separate comdat section and rely on the; // linker to deduplicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:29,Testability,stub,stub,29,// Add information about the stub reference to ELFMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:66,Testability,stub,stub,66,// Add information about the stub reference to ELFMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:98,Modifiability,variab,variable,98,"// Use SHT_NOTE for section whose name starts with "".note"" to allow; // emitting ELF notes from C variable declaration.; // See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=77609",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:58,Deployability,update,update,58,"/// Calculate an appropriate unique ID for a section, and update Flags,; /// EntrySize and NextUniqueID where appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:137,Safety,avoid,avoid,137,"// If two symbols with differing sizes end up in the same mergeable section; // that section can be assigned an incorrect entry size. To avoid this we; // usually put symbols of the same size into distinct mergeable sections with; // the same name. Doing so relies on the "",unique ,"" assembly feature. This; // feature is not avalible until bintuils version 2.35; // (https://sourceware.org/bugzilla/show_bug.cgi?id=25380).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:129,Availability,error,error,129,"// If we are using GNU as before 2.35, then this symbol might have; // been placed in an incompatible mergeable section. Emit an error if this; // is the case to avoid creating broken output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:162,Safety,avoid,avoid,162,"// If we are using GNU as before 2.35, then this symbol might have; // been placed in an incompatible mergeable section. Emit an error if this; // is the case to avoid creating broken output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:26,Availability,error,error,26,"// If invalid, report the error with report_fatal_error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:26,Availability,error,error,26,"// If invalid, report the error with report_fatal_error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:60,Testability,Stub,StubSize,60,"// Okay, now that we got the section, verify that the TAA & StubSize agree.; // If the user declared multiple globals with different section flags, we need; // to reject it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:26,Availability,error,error,26,"// If invalid, report the error with report_fatal_error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:91,Integrability,depend,depending,91,"// If this is weak/linkonce, put this in a coalescable section, either in text; // or data depending on if it is writable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:19,Modifiability,variab,variables,19,"// With MachO only variables whose corresponding symbol starts with 'l' or; // 'L' can be merged, so we only try merging GVs with private linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:68,Performance,optimiz,optimize,68,"// Otherwise, if it is readonly, but not something we can specially optimize,; // just drop it in .const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:28,Modifiability,variab,variable,28,"// Otherwise, just drop the variable in the normal data section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:61,Testability,stub,stub,61,// The mach-o version of this method defaults to returning a stub reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:29,Testability,stub,stub,29,// Add information about the stub reference to MachOMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:68,Testability,stub,stub,68,// Add information about the stub reference to MachOMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:61,Testability,stub,stub,61,// The mach-o version of this method defaults to returning a stub reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:29,Testability,stub,stub,29,// Add information about the stub reference to MachOMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:68,Testability,stub,stub,68,// Add information about the stub reference to MachOMMI so that the stub; // gets emitted by the asmprinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:129,Security,access,accessing,129,"// Although MachO 32-bit targets do not explicitly have a GOTPCREL relocation; // as 64-bit do, we replace the GOT equivalent by accessing the final symbol; // through a non_lazy_ptr stub instead. One advantage is that it allows the; // computation of deltas to final external symbols. Example:; //; // _extgotequiv:; // .long _extfoo; //; // _delta:; // .long _extgotequiv-_delta; //; // is transformed to:; //; // _delta:; // .long L_extfoo$non_lazy_ptr-(_delta+0); //; // .section __IMPORT,__pointers,non_lazy_symbol_pointers; // L_extfoo$non_lazy_ptr:; // .indirect_symbol _extfoo; // .long 0; //; // The indirect symbol table (and sections of non_lazy_symbol_pointers type); // may point to both local (same translation unit) and global (other; // translation units) symbols. Example:; //; // .section __DATA,__pointers,non_lazy_symbol_pointers; // L1:; // .indirect_symbol _myGlobal; // .long 0; // L2:; // .indirect_symbol _myLocal; // .long _myLocal; //; // If the symbol is local, instead of the symbol's index, the assembler; // places the constant INDIRECT_SYMBOL_LOCAL into the indirect symbol table.; // Then the linker will notice the constant in the table and will look at the; // content of the symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:183,Testability,stub,stub,183,"// Although MachO 32-bit targets do not explicitly have a GOTPCREL relocation; // as 64-bit do, we replace the GOT equivalent by accessing the final symbol; // through a non_lazy_ptr stub instead. One advantage is that it allows the; // computation of deltas to final external symbols. Example:; //; // _extgotequiv:; // .long _extfoo; //; // _delta:; // .long _extgotequiv-_delta; //; // is transformed to:; //; // _delta:; // .long L_extfoo$non_lazy_ptr-(_delta+0); //; // .section __IMPORT,__pointers,non_lazy_symbol_pointers; // L_extfoo$non_lazy_ptr:; // .indirect_symbol _extfoo; // .long 0; //; // The indirect symbol table (and sections of non_lazy_symbol_pointers type); // may point to both local (same translation unit) and global (other; // translation units) symbols. Example:; //; // .section __DATA,__pointers,non_lazy_symbol_pointers; // L1:; // .indirect_symbol _myGlobal; // .long 0; // L2:; // .indirect_symbol _myLocal; // .long _myLocal; //; // If the symbol is local, instead of the symbol's index, the assembler; // places the constant INDIRECT_SYMBOL_LOCAL into the indirect symbol table.; // Then the linker will notice the constant in the table and will look at the; // content of the symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:3,Security,Access,Access,3,// Access the final symbol via sym$non_lazy_ptr and generate the appropriated; // non_lazy_ptr stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:95,Testability,stub,stubs,95,// Access the final symbol via sym$non_lazy_ptr and generate the appropriated; // non_lazy_ptr stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:228,Safety,safe,safety,228,"// FIXME: we should be able to use private labels for sections that can't be; // dead-stripped (there's no issue with blocking atomization there), but `ld; // -r` sometimes drops the no_dead_strip attribute from sections so for safety; // we don't allow it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:110,Availability,error,error,110,"// Global symbols with internal or private linkage are not visible to; // the linker, and thus would cause an error when the linker tried to; // preserve the symbol due to the `/include:` directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:438,Integrability,contract,contract,438,"// Otherwise, we need to compute a new section name. Low priorities should; // run earlier. The linker will sort sections ASCII-betically, and we need a; // string that sorts between .CRT$XCA and .CRT$XCU. In the general case, we; // make a name like "".CRT$XCT12345"", since that runs before .CRT$XCU. Really; // low priorities need to sort before 'L', since the CRT uses that; // internally, so we use "".CRT$XCA00001"" for them. We have a contract with; // the frontend that ""init_seg(compiler)"" corresponds to priority 200 and; // ""init_seg(lib)"" corresponds to priority 400, and those respectively use; // 'C' and 'L' without the priority suffix. Priorities between 200 and 400; // use 'C' with the priority as a suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:35,Integrability,wrap,wrap,35,"// Both ptrtoint instructions must wrap global objects:; // - Only global variables are eligible for image relative relocations.; // - The subtrahend refers to the special symbol __ImageBase, a GlobalVariable.; // We expect __ImageBase to be a global variable without a section, externally; // defined.; //; // It should look something like this: @__ImageBase = external constant i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:74,Modifiability,variab,variables,74,"// Both ptrtoint instructions must wrap global objects:; // - Only global variables are eligible for image relative relocations.; // - The subtrahend refers to the special symbol __ImageBase, a GlobalVariable.; // We expect __ImageBase to be a global variable without a section, externally; // defined.; //; // It should look something like this: @__ImageBase = external constant i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:251,Modifiability,variab,variable,251,"// Both ptrtoint instructions must wrap global objects:; // - Only global variables are eligible for image relative relocations.; // - The subtrahend refers to the special symbol __ImageBase, a GlobalVariable.; // We expect __ImageBase to be a global variable without a section, externally; // defined.; //; // It should look something like this: @__ImageBase = external constant i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:221,Availability,error,error,221,"// This creates comdat sections with the given symbol name, but unless; // AsmPrinter::GetCPISymbol actually makes the symbol global, the symbol; // will be created with a null storage class, which makes GNU binutils; // error out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:127,Safety,avoid,avoided,127,// Certain data sections we treat as named custom sections rather than; // segments within the data section.; // This could be avoided if all data segements (the wasm sense) were; // represented as their own sections (in the llvm sense).; // TODO(sbc): https://github.com/WebAssembly/tool-conventions/issues/138,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:143,Modifiability,variab,variables,143,// We don't use PersonalityEncoding and LSDAEncoding because we don't emit; // .cfi directives. We use TTypeEncoding to encode typeinfo global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:28,Deployability,canary,canary,28,// FIXME: check presence of canary word; // There are cases that the stack protectors are not really inserted even if; // the attributes are on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:256,Safety,avoid,avoided,256,"// We always use a qualname symbol for a GV that represents; // a declaration, a function descriptor, or a common symbol.; // If a GV represents a GlobalVariable and -fdata-sections is enabled, we; // also return a qualname so that a label symbol could be avoided.; // It is inherently ambiguous when the GO represents the address of a; // function, as the GO could either represent a function descriptor or a; // function entry point. We choose to always return a function descriptor; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:161,Availability,error,error,161,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:61,Deployability,integrat,integrated,61,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:61,Integrability,integrat,integrated,61,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:130,Modifiability,variab,variable,130,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:234,Modifiability,variab,variables,234,"// AIX debug for thread local location is not ready. And for integrated as; // mode, the relocatable address for the thread local variable will cause; // linker error. So disable the location attribute generation for thread local; // variables for now.; // FIXME: when TLS debug on AIX is ready, remove this setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:223,Energy Efficiency,allocate,allocated,223,"// Use TE storage-mapping class when large code model is enabled so that; // the chance of needing -bbigtoc is decreased. Also, the toc-entry for; // EH info is never referenced directly using instructions so it can be; // allocated with TE storage-mapping class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp:82,Performance,optimiz,optimization,82,/// DisableFramePointerElim - This returns true if frame pointer elimination; /// optimization should be disabled for the given machine function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp:343,Testability,test,testing,343,"/// NOTE: There are targets that still do not support the debug entry values; /// production and that is being controlled with the SupportsDebugEntryValues.; /// In addition, SCE debugger does not have the feature implemented, so prefer; /// not to emit the debug entry values in that case.; /// The EnableDebugEntryValues can be used for the testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetOptionsImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:401,Integrability,interface,interfaces,401,"//===- TargetPassConfig.cpp - Target independent code generation passes ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code; // generation passes provided by the LLVM backend.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:415,Security,access,access,415,"//===- TargetPassConfig.cpp - Target independent code generation passes ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code; // generation passes provided by the LLVM backend.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:87,Deployability,pipeline,pipeline,87,"// Disable the pass to fix unwind information. Whether the pass is included in; // the pipeline is controlled via the target options, this option serves as; // manual override.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:82,Energy Efficiency,schedul,scheduler,82,"// Temporary option to allow experimenting with MachineScheduler as a post-RA; // scheduler. Targets can ""properly"" enable this with; // substitutePass(&PostRASchedulerID, &PostMachineSchedulerID).; // Targets can return true in targetSchedulesPostRAScheduling() and; // insert a PostRA scheduling pass wherever it wants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:287,Energy Efficiency,schedul,scheduling,287,"// Temporary option to allow experimenting with MachineScheduler as a post-RA; // scheduler. Targets can ""properly"" enable this with; // substitutePass(&PostRASchedulerID, &PostMachineSchedulerID).; // Targets can return true in targetSchedulesPostRAScheduling() and; // insert a PostRA scheduling pass wherever it wants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:75,Availability,error,error,75,/// Option names for limiting the codegen pipeline.; /// Those are used in error reporting and we didn't want; /// to duplicate their names all over the place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:42,Deployability,pipeline,pipeline,42,/// Option names for limiting the codegen pipeline.; /// Those are used in error reporting and we didn't want; /// to duplicate their names all over the place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:43,Testability,test,testing,43,/// Disable the expand reductions pass for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:23,Performance,optimiz,optimization,23,/// Disable the select optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:85,Usability,simpl,simple,85,/// Allow standard passes to be disabled by command line options. This supports; /// simple binary flags that either suppress the pass or do nothing.; /// i.e. -disable-mypass=false has no effect.; /// These should be converted to boolOrDefault in order to use applyOverride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:170,Deployability,pipeline,pipeline,170,"/// Allow standard passes to be disabled by the command line, regardless of who; /// is adding the pass.; ///; /// StandardID is the pass identified in the standard pass pipeline and provided; /// to addPass(). It may be a target-specific ID in the case that the target; /// directly adds its own pass, but in that case we harmlessly fall through.; ///; /// TargetID is the pass that the target has configured to override StandardID.; ///; /// StandardID may be a pseudo ID. In that case TargetID is the name of the real; /// pass to run. This allows multiple options to control a single pass depending; /// on where in the pipeline that pass is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:624,Deployability,pipeline,pipeline,624,"/// Allow standard passes to be disabled by the command line, regardless of who; /// is adding the pass.; ///; /// StandardID is the pass identified in the standard pass pipeline and provided; /// to addPass(). It may be a target-specific ID in the case that the target; /// directly adds its own pass, but in that case we harmlessly fall through.; ///; /// TargetID is the pass that the target has configured to override StandardID.; ///; /// StandardID may be a pseudo ID. In that case TargetID is the name of the real; /// pass to run. This allows multiple options to control a single pass depending; /// on where in the pipeline that pass is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:593,Integrability,depend,depending,593,"/// Allow standard passes to be disabled by the command line, regardless of who; /// is adding the pass.; ///; /// StandardID is the pass identified in the standard pass pipeline and provided; /// to addPass(). It may be a target-specific ID in the case that the target; /// directly adds its own pass, but in that case we harmlessly fall through.; ///; /// TargetID is the pass that the target has configured to override StandardID.; ///; /// StandardID may be a pseudo ID. In that case TargetID is the name of the real; /// pass to run. This allows multiple options to control a single pass depending; /// on where in the pipeline that pass is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:399,Modifiability,config,configured,399,"/// Allow standard passes to be disabled by the command line, regardless of who; /// is adding the pass.; ///; /// StandardID is the pass identified in the standard pass pipeline and provided; /// to addPass(). It may be a target-specific ID in the case that the target; /// directly adds its own pass, but in that case we harmlessly fall through.; ///; /// TargetID is the pass that the target has configured to override StandardID.; ///; /// StandardID may be a pseudo ID. In that case TargetID is the name of the real; /// pass to run. This allows multiple options to control a single pass depending; /// on where in the pipeline that pass is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:188,Deployability,pipeline,pipeline,188,"// List of passes explicitly substituted by this target. Normally this is; // empty, but it is a convenient way to suppress or replace specific passes; // that are part of a standard pass pipeline without overridding the entire; // pipeline. This mechanism allows target options to inherit a standard pass's; // user interface. For example, a target may disable a standard pass by; // default by substituting a pass ID of zero, and the user may still enable; // that standard pass with an explicit command line option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:232,Deployability,pipeline,pipeline,232,"// List of passes explicitly substituted by this target. Normally this is; // empty, but it is a convenient way to suppress or replace specific passes; // that are part of a standard pass pipeline without overridding the entire; // pipeline. This mechanism allows target options to inherit a standard pass's; // user interface. For example, a target may disable a standard pass by; // default by substituting a pass ID of zero, and the user may still enable; // that standard pass with an explicit command line option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:317,Integrability,interface,interface,317,"// List of passes explicitly substituted by this target. Normally this is; // empty, but it is a convenient way to suppress or replace specific passes; // that are part of a standard pass pipeline without overridding the entire; // pipeline. This mechanism allows target options to inherit a standard pass's; // user interface. For example, a target may disable a standard pass by; // default by substituting a pass ID of zero, and the user may still enable; // that standard pass with an explicit command line option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:282,Modifiability,inherit,inherit,282,"// List of passes explicitly substituted by this target. Normally this is; // empty, but it is a convenient way to suppress or replace specific passes; // that are part of a standard pass pipeline without overridding the entire; // pipeline. This mechanism allows target options to inherit a standard pass's; // user interface. For example, a target may disable a standard pass by; // default by substituting a pass ID of zero, and the user may still enable; // that standard pass with an explicit command line option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:37,Deployability,configurat,configuration,37,/// createPassConfig - Create a pass configuration object to be used by; /// addPassToEmitX methods for generating a pipeline of CodeGen passes.; ///; /// Targets may override this to extend TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:117,Deployability,pipeline,pipeline,117,/// createPassConfig - Create a pass configuration object to be used by; /// addPassToEmitX methods for generating a pipeline of CodeGen passes.; ///; /// Targets may override this to extend TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:37,Modifiability,config,configuration,37,/// createPassConfig - Create a pass configuration object to be used by; /// addPassToEmitX methods for generating a pipeline of CodeGen passes.; ///; /// Targets may override this to extend TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:184,Modifiability,extend,extend,184,/// createPassConfig - Create a pass configuration object to be used by; /// addPassToEmitX methods for generating a pipeline of CodeGen passes.; ///; /// Targets may override this to extend TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:74,Availability,redundant,redundant,74,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:114,Availability,avail,available,114,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:102,Energy Efficiency,schedul,scheduled,102,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:3,Performance,Cache,Cache,3,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:74,Safety,redund,redundant,74,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:20,Integrability,message,message,20,// Construct banner message before PM->add() as that may delete the pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:44,Deployability,pipeline,pipeline,44,/// Add a CodeGen pass at this point in the pipeline after checking for target; /// and command line overrides.; ///; /// addPass cannot return a pointer to the pass instance because is internal the; /// PassManager and the instance we create here may already be freed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:22,Modifiability,config,configurable,22,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:47,Performance,perform,perform,47,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:115,Performance,optimiz,optimization,115,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:110,Performance,optimiz,optimizer,110,"// Before running any passes, run the verifier to determine if the input; // coming from the front-end and/or optimizer is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:80,Performance,load,loads,80,// The MergeICmpsPass tries to create memcmp calls by grouping sequences of; // loads and compares. ExpandMemCmpPass then tries to expand those calls; // into optimally-sized loads and compares. The transforms are enabled by a; // target lowering hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:175,Performance,load,loads,175,// The MergeICmpsPass tries to create memcmp calls by grouping sequences of; // loads and compares. ExpandMemCmpPass then tries to expand those calls; // into optimally-sized loads and compares. The transforms are enabled by a; // target lowering hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:96,Safety,avoid,avoid,96,"// For MachO, lower @llvm.global_dtors into @llvm.global_ctors with; // __cxa_atexit() calls to avoid emitting the deprecated __mod_term_func.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:45,Availability,mask,masked,45,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:213,Availability,mask,mask,213,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:169,Performance,load,loads,169,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:105,Testability,test,testing,105,// Expand reduction intrinsics into shuffle sequences if the target wants to.; // Allow disabling it for testing purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:27,Performance,perform,perform,27,/// Add common passes that perform LLVM IR to IR transforms in preparation for; /// instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:16,Safety,safe,safe,16,// Add both the safe stack and the stack protection passes: each of them will; // only protect functions that have corresponding attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:37,Deployability,pipeline,pipeline,37,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:147,Energy Efficiency,schedul,schedule,147,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:10,Integrability,Inject,Injecting,10,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:378,Integrability,inject,injecting,378,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:10,Security,Inject,Injecting,10,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:378,Security,inject,injecting,378,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:562,Testability,test,testing,562,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:240,Usability,clear,clear,240,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:50,Safety,abort,abort,50,// Provide a fallback path when we do not want to abort on; // not-yet-supported input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:186,Deployability,configurat,configuration,186,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:258,Integrability,rout,routines,258,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:306,Integrability,rout,routine,306,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:415,Integrability,inject,injecting,415,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:627,Integrability,rout,routines,627,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:855,Integrability,depend,dependencies,855,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:1012,Integrability,inject,injection,1012,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:186,Modifiability,config,configuration,186,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:667,Modifiability,maintainab,maintainability,667,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:415,Security,inject,injecting,415,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:1012,Security,inject,injection,1012,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:19,Performance,optimiz,optimize,19,// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:166,Safety,safe,safe,166,// Debugifying the register allocator passes seems to provoke some; // non-determinism that affects CodeGen and there doesn't seem to be a point; // where it becomes safe again so stop debugifying here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:106,Energy Efficiency,schedul,scheduling,106,"// Run register allocation and passes that are tightly coupled with it,; // including phi elimination and scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:44,Energy Efficiency,schedul,scheduling,44,// Expand pseudo instructions before second scheduling pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:15,Energy Efficiency,schedul,scheduler,15,// Second pass scheduler.; // Let Target optionally insert this pass by itself at some other; // point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:61,Availability,mask,mask,61,"// Collect register usage information and produce a register mask of; // clobbered registers, to be used to optimize call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:108,Performance,optimiz,optimize,108,"// Collect register usage information and produce a register mask of; // clobbered registers, to be used to optimize call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:240,Deployability,Update,Update,240,"// Machine function splitter uses the basic block sections feature. Both; // cannot be enabled at the same time. Basic block sections takes precedence.; // FIXME: In principle, BasicBlockSection::Labels and splitting can used; // together. Update this check once we have addressed any issues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:87,Performance,perform,performance,87,"// Sample profile is given, but FSDiscriminator is not; // enabled, this may result in performance regression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:3,Performance,Optimiz,Optimize,3,// Optimize PHIs before DCE: removing dead PHI cycles may make more; // instructions dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:8,Performance,optimiz,optimization,8,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:250,Testability,test,test,250,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:110,Deployability,Configurat,Configuration,110,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:110,Modifiability,Config,Configuration,110,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:88,Performance,optimiz,optimized,88,/// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:253,Performance,optimiz,optimized,253,/// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:343,Performance,optimiz,optimized,343,/// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:296,Availability,avail,available,296,"/// Find and instantiate the register allocation pass requested by this target; /// at the current optimization level. Different register allocators are; /// defined as separate passes because they may require different analysis.; ///; /// This helper ensures that the regalloc= option is always available,; /// even for targets that override the default allocator.; ///; /// FIXME: When MachinePassRegistry register pass IDs instead of function ptrs,; /// this can be folded into addPass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:99,Performance,optimiz,optimization,99,"/// Find and instantiate the register allocation pass requested by this target; /// at the current optimization level. Different register allocators are; /// defined as separate passes because they may require different analysis.; ///; /// This helper ensures that the regalloc= option is always available,; /// even for targets that override the default allocator.; ///; /// FIXME: When MachinePassRegistry register pass IDs instead of function ptrs,; /// this can be folded into addPass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:11,Modifiability,rewrite,rewrite,11,// Finally rewrite virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:62,Usability,learn,learning,62,// Regalloc scoring for ML-driven eviction - noop except when learning a new; // eviction policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:118,Energy Efficiency,schedul,scheduling,118,/// Add the minimum set of target-independent passes that are required for; /// register allocation. No coalescing or scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:156,Energy Efficiency,schedul,scheduling,156,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:78,Performance,optimiz,optimized,78,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:324,Integrability,depend,depend,324,"// LiveVariables currently requires pure SSA form.; //; // FIXME: Once TwoAddressInstruction pass no longer uses kill flags,; // LiveVariables can be removed completely, and LiveIntervals can be directly; // computed. (We still either need to regenerate kill flags after regalloc, or; // preferably fix the scavenger to not depend on them).; // FIXME: UnreachableMachineBlockElim is a dependant pass of LiveVariables.; // When LiveVariables is removed this has to be removed/moved either.; // Explicit addition of UnreachableMachineBlockElim allows stopping before or; // after it with -stop-before/-stop-after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:385,Integrability,depend,dependant,385,"// LiveVariables currently requires pure SSA form.; //; // FIXME: Once TwoAddressInstruction pass no longer uses kill flags,; // LiveVariables can be removed completely, and LiveIntervals can be directly; // computed. (We still either need to regenerate kill flags after regalloc, or; // preferably fix the scavenger to not depend on them).; // FIXME: UnreachableMachineBlockElim is a dependant pass of LiveVariables.; // When LiveVariables is removed this has to be removed/moved either.; // Explicit addition of UnreachableMachineBlockElim allows stopping before or; // after it with -stop-before/-stop-after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:15,Energy Efficiency,schedul,scheduler,15,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:121,Safety,avoid,avoid,121,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:21,Energy Efficiency,schedul,scheduling,21,// PreRA instruction scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:3,Performance,Perform,Perform,3,// Perform stack slot coloring and post-ra machine LICM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:47,Integrability,depend,depending,47,// Allow targets to expand pseudo instructions depending on the choice of; // registers before MachineCopyPropagation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:104,Deployability,Configurat,Configuration,104,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:104,Modifiability,Config,Configuration,104,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:220,Performance,optimiz,optimize,220,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:14,Availability,redundant,redundant,14,// Cleanup of redundant immediate/address loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:42,Performance,load,loads,42,// Cleanup of redundant immediate/address loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:14,Safety,redund,redundant,14,// Cleanup of redundant immediate/address loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:94,Performance,perform,performance,94,// Tail duplication.; // Note that duplicating tail just increases code size and degrades; // performance for targets that require Structured Control Flow.; // In addition it can also make CFG irreducible. Thus we disable it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:96,Deployability,Configurat,Configuration,96,//===---------------------------------------------------------------------===//; /// GlobalISel Configuration; //===---------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:96,Modifiability,Config,Configuration,96,//===---------------------------------------------------------------------===//; /// GlobalISel Configuration; //===---------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:427,Integrability,interface,interface,427,"//==- TargetRegisterInfo.cpp - Target Register Information Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the TargetRegisterInfo interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:77,Safety,avoid,avoid,77,// We transitively check superregs. So we can remember this for later; // to avoid compiletime explosion in deep register hierarchies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:29,Deployability,Toggle,Toggle,29,/// getAllocatableSetForRC - Toggle the bits that represent allocatable; /// registers for the specific register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:3,Availability,Mask,Mask,3,// Mask out the reserved registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:11,Availability,mask,mask,11,// The bit mask contains all register classes that are projected into B; // by Idx. Find a class that is also a sub-class of A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:65,Safety,avoid,avoid,65,"// At most one of the register is a sub register, make it Src to avoid; // duplicating the test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:91,Testability,test,test,91,"// At most one of the register is a sub register, make it Src to avoid; // duplicating the test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:86,Energy Efficiency,allocate,allocated,86,// Don't add the same reg twice (Hints_MRI may contain multiple virtual; // registers allocated to the same physreg).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:7,Usability,clear,clear,7,"// All clear, tell the register allocator to prefer this register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:28,Availability,avail,available,28,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:86,Security,access,access,86,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:3,Safety,Abort,Abort,3,// Abort if we cannot possibly implement the COPY with the given indexes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:41,Safety,avoid,avoid,41,// Do not cover already-covered lanes to avoid creating cycles; // in copy bundles (= bundle contains copies that write to the; // registers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:507,Availability,avail,available,507,"//===- llvm/Target/TargetSchedule.cpp - Sched Machine Model ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a wrapper around MCSchedModel that allows the interface; // to benefit from information currently only available in TargetInstrInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:406,Integrability,wrap,wrapper,406,"//===- llvm/Target/TargetSchedule.cpp - Sched Machine Model ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a wrapper around MCSchedModel that allows the interface; // to benefit from information currently only available in TargetInstrInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:450,Integrability,interface,interface,450,"//===- llvm/Target/TargetSchedule.cpp - Sched Machine Model ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a wrapper around MCSchedModel that allows the interface; // to benefit from information currently only available in TargetInstrInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:55,Performance,latency,latency,55,"// The machine model may explicitly specify an invalid latency, which; // effectively means infinite latency. Since users of the TargetSchedule API; // don't know how to handle this, we convert it to a very large latency that is; // easy to distinguish when debugging the DAG but won't induce overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:101,Performance,latency,latency,101,"// The machine model may explicitly specify an invalid latency, which; // effectively means infinite latency. Since users of the TargetSchedule API; // don't know how to handle this, we convert it to a very large latency that is; // easy to distinguish when debugging the DAG but won't induce overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:213,Performance,latency,latency,213,"// The machine model may explicitly specify an invalid latency, which; // effectively means infinite latency. Since users of the TargetSchedule API; // don't know how to handle this, we convert it to a very large latency that is; // easy to distinguish when debugging the DAG but won't induce overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:115,Integrability,depend,depend,115,/// Return the MCSchedClassDesc for this instruction. Some SchedClasses require; /// evaluation of predicates that depend on instruction operands or flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:24,Energy Efficiency,schedul,scheduling,24,// Get the definition's scheduling class descriptor from this machine model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:191,Usability,simpl,simply,191,"/// Find the use index of this operand. This is independent of the instruction's; /// def operands.; ///; /// Note that uses are not determined by the operand's isUse property, which; /// is simply the inverse of isDef. Here we consider any readsReg operand to be; /// a ""use"". The machine model allows an operand to be both a Def and Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:146,Performance,latency,latency,146,"// Top-level API for clients that know the operand indices. This doesn't need to; // return std::optional<unsigned>, as it always returns a valid latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:12,Performance,latency,latency,12,"// Expected latency is the max of InstrLatency and DefaultDefLatency, if we; // didn't find an operand latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:103,Performance,latency,latency,103,"// Expected latency is the max of InstrLatency and DefaultDefLatency, if we; // didn't find an operand latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:33,Performance,latency,latency,33,// Lookup the definition's write latency in SubtargetInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:20,Performance,latency,latency,20,// Lookup the use's latency adjustment in SubtargetInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:12,Integrability,wrap,wrap,12,// unsigned wrap,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:84,Performance,latency,latency,84,"// If DefIdx does not exist in the model (e.g. implicit defs), then return; // unit latency (defaultDefLatency may be too conservative).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:202,Performance,latency,latency,202,// FIXME: Automatically giving all implicit defs defaultDefLatency is; // undesirable. We should only do it for defs that are known to the MC; // desc like flags. Truly implicit defs should get 1 cycle latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:43,Integrability,depend,dependencies,43,"// Out-of-order processor can dispatch WAW dependencies in the same cycle.; // Treat predication as a data dependency for out-of-order cpus. In-order; // cpus do not need to treat predicated writes specially.; //; // TODO: The following hack exists because predication passes do not; // correctly append imp-use operands, and readsReg() strangely returns false; // for predicated defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:107,Integrability,depend,dependency,107,"// Out-of-order processor can dispatch WAW dependencies in the same cycle.; // Treat predication as a data dependency for out-of-order cpus. In-order; // cpus do not need to treat predicated writes specially.; //; // TODO: The following hack exists because predication passes do not; // correctly append imp-use operands, and readsReg() strangely returns false; // for predicated defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:28,Energy Efficiency,schedul,scheduling,28,"// If we have a per operand scheduling model, check if this def is writing; // an unbuffered resource. If so, it treated like an in-order cpu.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:4,Testability,Test,Test,4,"/// Test if the given register value, which is used by the; /// given instruction, is killed by the given instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:249,Availability,avail,available,249,"// FIXME: Sometimes tryInstructionTransform() will add instructions and; // test whether they can be folded before keeping them. In this case it; // sets a kill before recursively calling tryInstructionTransform() again.; // If there is no interval available, we assume that this instruction is; // one of those. A kill flag is manually inserted on the operand so the; // check below will handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:76,Testability,test,test,76,"// FIXME: Sometimes tryInstructionTransform() will add instructions and; // test whether they can be folded before keeping them. In this case it; // sets a kill before recursively calling tryInstructionTransform() again.; // If there is no interval available, we assume that this instruction is; // one of those. A kill flag is manually inserted on the operand so the; // check below will handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:4,Testability,Test,Test,4,/// Test if the register used by the given operand is killed by the operand's; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:4,Testability,Test,Test,4,"/// Test if the given register value, which is used by the given; /// instruction, is killed by the given instruction. This looks through; /// coalescable copies to see if the original value is potentially not killed.; ///; /// For example, in this code:; ///; /// %reg1034 = copy %reg1024; /// %reg1035 = copy killed %reg1025; /// %reg1036 = add killed %reg1034, killed %reg1035; ///; /// %reg1034 is not considered to be killed, since it is copied from a; /// register which is not killed. Treating it as not killed lets the; /// normal heuristics commute the (two-address) add, which lets; /// coalescing eliminate the extra copy.; ///; /// If allowFalsePositives is true then likely kills are treated as kills even; /// if it can't be proven that they are kills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:45,Usability,simpl,simple,45,"// If there are multiple defs, we can't do a simple analysis, so just; // go with what the kill flag says.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:687,Availability,avail,available,687,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:614,Deployability,integrat,integrated,614,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:614,Integrability,integrat,integrated,614,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:307,Modifiability,extend,extend,307,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:318,Testability,log,logic,318,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:565,Testability,log,logic,565,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
