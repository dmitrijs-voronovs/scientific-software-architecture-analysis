id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/4.0b4/installfile.html:23898,Safety,detect,detect,23898,"2 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PS",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:18251,Security,access,access,18251,"available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; gri",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:20975,Security,access,access,20975,"ibutions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the ",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:3540,Testability,test,tests,3540,"l psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, i",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:3555,Testability,test,tests,3555,"l psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, i",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:3599,Testability,test,tests,3599," this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you ",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16335,Testability,test,test,16335,"brary or suffix to use. --with-boost-regex[=special-lib] —; Use the Regex library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is au",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16386,Testability,test,tests,16386,"brary or suffix to use. --with-boost-regex[=special-lib] —; Use the Regex library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is au",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16457,Testability,test,test,16457,"specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTe",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16514,Testability,test,test,16514,"_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir ",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16607,Testability,test,testing,16607,"; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefi",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16657,Testability,test,testing,16657,"rary for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save ",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16705,Testability,test,tests,16705,"rary for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save ",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16760,Testability,test,testsclean,16760,"ith-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 packa",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16794,Testability,test,test,16794,"ith-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 packa",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16839,Testability,test,testing,16839,"; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her p",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:19179,Testability,test,testing,19179," Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is le",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:4464,Usability,simpl,simple,4464,"./do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile ",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:16366,Usability,simpl,simply,16366,"brary or suffix to use. --with-boost-regex[=special-lib] —; Use the Regex library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is au",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:20678,Usability,simpl,simplest,20678,"libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; ",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:24510,Usability,simpl,simply,24510,"ottling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. T",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/installfile.html:25516,Usability,simpl,simple,25516," make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instruc",MatchSource.WIKI,psi4manual/4.0b4/installfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:2097,Deployability,update,updated,2097,"Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:440,Energy Efficiency,energy,energy,440,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:567,Energy Efficiency,energy,energy,567,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:603,Energy Efficiency,energy,energy,603,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:753,Energy Efficiency,energy,energy,753,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:929,Energy Efficiency,energy,energy,929,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:1052,Energy Efficiency,energy,energy,1052,"dex. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:1082,Energy Efficiency,energy,energy,1082,"dex. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:351,Performance,optimiz,optimize,351,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls-1.html:645,Security,validat,validated,645,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls-1.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:2097,Deployability,update,updated,2097,"Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:440,Energy Efficiency,energy,energy,440,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:567,Energy Efficiency,energy,energy,567,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:603,Energy Efficiency,energy,energy,603,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:753,Energy Efficiency,energy,energy,753,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:929,Energy Efficiency,energy,energy,929,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:1052,Energy Efficiency,energy,energy,1052,"dex. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:1082,Energy Efficiency,energy,energy,1082,"dex. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:351,Performance,optimiz,optimize,351,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/intercalls.html:645,Security,validat,validated,645,"﻿. Function Intercalls — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; Spectroscopic Constants for Diatomics; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [be",MatchSource.WIKI,psi4manual/4.0b4/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/intercalls.html
https://psicode.org/psi4manual/4.0b4/interfacing-1.html:879,Deployability,update,updated,879,"﻿. Interfaces: Enhancing PSI4 Capabilities — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Interfaces: Enhancing PSI4 Capabilities¶; PSI4’s capabilites have been expanded by interfacing with other; software packages. These programs aren’t necessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to MRCC by M. Kállay; Installation; Running MRCC. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Interface to Molden. Previous topic; Evaluation of One-Electron Properties; Next topic; Interface to MRCC by M. Kállay; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/interfacing-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/interfacing-1.html
https://psicode.org/psi4manual/4.0b4/interfacing.html:879,Deployability,update,updated,879,"﻿. Interfaces: Enhancing PSI4 Capabilities — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Interfaces: Enhancing PSI4 Capabilities¶; PSI4’s capabilites have been expanded by interfacing with other; software packages. These programs aren’t necessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to MRCC by M. Kállay; Installation; Running MRCC. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Interface to Molden. Previous topic; Evaluation of One-Electron Properties; Next topic; Interface to MRCC by M. Kállay; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/interfacing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/interfacing.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:1549,Availability,avail,available,1549,"mate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci. 2, 556 (2012).; (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementa",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:1611,Availability,avail,available,1611,"mate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci. 2, 556 (2012).; (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementa",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:11718,Availability,avail,available,11718," Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or 12.1 (we have had; trouble with version 12.0). See Sec. Compiling and Installing for details. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DF-SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DCFT; Y; Y; UHF; partially threaded. MP2; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y [2]; RHF/ROHF/UHF; threaded. MP3; Y; Y; RHF/UHF; threaded [3]. MP2.5; Y; Y; RHF/UHF; threaded [3]. MP4; Y; —; RHF; threaded [3]. MP(n); Y; —; RHF/ROHF; partially threaded. ZAPT(n); Y; —; RHF/ROHF; partially threaded. OMP2; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QC",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:11862,Availability,avail,available,11862,"Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or 12.1 (we have had; trouble with version 12.0). See Sec. Compiling and Installing for details. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DF-SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DCFT; Y; Y; UHF; partially threaded. MP2; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y [2]; RHF/ROHF/UHF; threaded. MP3; Y; Y; RHF/UHF; threaded [3]. MP2.5; Y; Y; RHF/UHF; threaded [3]. MP4; Y; —; RHF; threaded [3]. MP(n); Y; —; RHF/ROHF; partially threaded. ZAPT(n); Y; —; RHF/ROHF; partially threaded. OMP2; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QCISD; Y; —; RHF; threaded [3]. QCISD(T); Y; —; RHF; threaded [3]. CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:13790,Availability,reliab,reliability,13790,"/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —; RHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). DF-CCSD(T); Y; —; RHF; threaded [3]. CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). Mk-MRPT2; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; —; RHF/ROHF/TCSCF; threaded [3]. CI(n); Y; —; RHF/ROHF; partially threaded. RAS-CI; Y; —; RHF/ROHF; partially threaded. SAPT; Y; —; RHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . ADC(2); Y; —; RHF; threaded [3]. EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub account.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta4. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introducti",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:3493,Deployability,configurat,configuration,3493,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:3542,Deployability,configurat,configuration,3542,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:15499,Deployability,update,updated,15499," differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub account.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta4. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Functional Theory (DCFT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree-Fock Methods; Second-Order Algebraic-Diagrammatic Construction [ADC(2)]. Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:341,Energy Efficiency,efficient,efficiently,341,"﻿. Introduction — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic s",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:6319,Energy Efficiency,efficient,efficient,6319," F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010).; (doi: 10.1063/1.3305335). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Imp",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:6901,Energy Efficiency,adapt,adapted,6901,"4927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Tri",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:8612,Energy Efficiency,energy,energy,8612,"; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherr",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:13448,Energy Efficiency,energy,energy,13448,"3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QCISD; Y; —; RHF; threaded [3]. QCISD(T); Y; —; RHF; threaded [3]. CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —; RHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). DF-CCSD(T); Y; —; RHF; threaded [3]. CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). Mk-MRPT2; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; —; RHF/ROHF/TCSCF; threaded [3]. CI(n); Y; —; RHF/ROHF; partially threaded. RAS-CI; Y; —; RHF/ROHF; partially threaded. SAPT; Y; —; RHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . ADC(2); Y; —; RHF; threaded [3]. EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub accoun",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:492,Integrability,rout,routine,492,"﻿. Introduction — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic s",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:14636,Integrability,rout,routines,14636," differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub account.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta4. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Functional Theory (DCFT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree-Fock Methods; Second-Order Algebraic-Diagrammatic Construction [ADC(2)]. Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:3493,Modifiability,config,configuration,3493,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:3542,Modifiability,config,configuration,3542,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:6901,Modifiability,adapt,adapted,6901,"4927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Tri",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:1383,Performance,optimiz,optimization,1383," machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci. 2, 556 (2012).; (doi: 1",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:3469,Performance,optimiz,optimized,3469,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:4191,Performance,perform,performance,4191,"9423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) and Cholesky decomposition (CD); coupled cluster in PSI, and its performance for non-covalent interactions; and reaction energies, is discussed in. “Accuracy and Efficiency of Coupled-Cluster Theory Using; Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,; and a T1-Transformed Hamiltonian,” A. E. DePrince and C. D. Sherrill,; submitted. Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC)¶; PSI4 features production-level Mukherjee-style state-specific; coupled-cluster theory, including perturbative triples and also associated; multi-reference perturbation theories. The theory and PSI4; implementation of these methods is discussed in the ",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:4566,Performance,perform,performance,4566," interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) and Cholesky decomposition (CD); coupled cluster in PSI, and its performance for non-covalent interactions; and reaction energies, is discussed in. “Accuracy and Efficiency of Coupled-Cluster Theory Using; Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,; and a T1-Transformed Hamiltonian,” A. E. DePrince and C. D. Sherrill,; submitted. Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC)¶; PSI4 features production-level Mukherjee-style state-specific; coupled-cluster theory, including perturbative triples and also associated; multi-reference perturbation theories. The theory and PSI4; implementation of these methods is discussed in the following papers.; General Mk-MRCC. “Coupling Term Derivation and General Implementation of; State-Specific Multireference Coupled-Cluster Theories,”; F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:6337,Performance,perform,perform,6337," F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010).; (doi: 10.1063/1.3305335). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Imp",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:8216,Performance,optimiz,optimized,8216,"656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistr",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:8315,Performance,optimiz,optimization,8315,"the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair ",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:8344,Performance,optimiz,optimized,8344,"the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair ",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:8400,Performance,optimiz,optimized,8400,"the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair ",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:8645,Performance,optimiz,optimized,8645,"; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherr",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:8761,Performance,optimiz,optimized,8761,"r Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its an",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:9333,Performance,optimiz,optimized,9333,"oupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) the",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:9436,Performance,optimiz,optimization,9436,", Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:9465,Performance,optimiz,optimized,9465,", Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:9521,Performance,optimiz,optimized,9521,", Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:9732,Performance,optimiz,optimized,9732,"tal-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:9964,Performance,optimiz,optimized,9964,"ing Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:11417,Performance,perform,perform,11417,"hirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or 12.1 (we have had; trouble with version 12.0). See Sec. Compiling and Installing for details. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DF-SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DCFT; Y; Y; UHF; partially threaded. MP2; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y [2]; RHF/ROHF/UHF; threaded. MP3; Y; Y; RHF/UHF; threaded [3]. MP2.5; Y; Y; RHF/UHF; threaded [3]. MP4; Y; —; RHF; threaded [3]. MP(n); Y; —; RHF/ROHF; partially threaded. ZAPT(n); Y; —; RHF/ROHF; partially threaded. OMP2; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:13382,Performance,optimiz,optimization,13382,"3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QCISD; Y; —; RHF; threaded [3]. QCISD(T); Y; —; RHF; threaded [3]. CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —; RHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). DF-CCSD(T); Y; —; RHF; threaded [3]. CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). Mk-MRPT2; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; —; RHF/ROHF/TCSCF; threaded [3]. CI(n); Y; —; RHF/ROHF; partially threaded. RAS-CI; Y; —; RHF/ROHF; partially threaded. SAPT; Y; —; RHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . ADC(2); Y; —; RHF; threaded [3]. EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub accoun",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:13402,Performance,perform,performed,13402,"3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QCISD; Y; —; RHF; threaded [3]. QCISD(T); Y; —; RHF; threaded [3]. CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —; RHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). DF-CCSD(T); Y; —; RHF; threaded [3]. CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). Mk-MRPT2; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; —; RHF/ROHF/TCSCF; threaded [3]. CI(n); Y; —; RHF/ROHF; partially threaded. RAS-CI; Y; —; RHF/ROHF; partially threaded. SAPT; Y; —; RHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . ADC(2); Y; —; RHF; threaded [3]. EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub accoun",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:11080,Testability,test,tested,11080,"mponent and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or 12.1 (we have had; trouble with version 12.0). See Sec. Compiling and Installing for details. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DF-SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DCFT; Y; Y; UHF; p",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction-1.html:475,Usability,simpl,simple,475,"﻿. Introduction — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic s",MatchSource.WIKI,psi4manual/4.0b4/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html
https://psicode.org/psi4manual/4.0b4/introduction.html:1549,Availability,avail,available,1549,"mate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci. 2, 556 (2012).; (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementa",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:1611,Availability,avail,available,1611,"mate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci. 2, 556 (2012).; (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementa",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:11718,Availability,avail,available,11718," Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or 12.1 (we have had; trouble with version 12.0). See Sec. Compiling and Installing for details. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DF-SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DCFT; Y; Y; UHF; partially threaded. MP2; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y [2]; RHF/ROHF/UHF; threaded. MP3; Y; Y; RHF/UHF; threaded [3]. MP2.5; Y; Y; RHF/UHF; threaded [3]. MP4; Y; —; RHF; threaded [3]. MP(n); Y; —; RHF/ROHF; partially threaded. ZAPT(n); Y; —; RHF/ROHF; partially threaded. OMP2; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QC",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:11862,Availability,avail,available,11862,"Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or 12.1 (we have had; trouble with version 12.0). See Sec. Compiling and Installing for details. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DF-SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DCFT; Y; Y; UHF; partially threaded. MP2; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y [2]; RHF/ROHF/UHF; threaded. MP3; Y; Y; RHF/UHF; threaded [3]. MP2.5; Y; Y; RHF/UHF; threaded [3]. MP4; Y; —; RHF; threaded [3]. MP(n); Y; —; RHF/ROHF; partially threaded. ZAPT(n); Y; —; RHF/ROHF; partially threaded. OMP2; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QCISD; Y; —; RHF; threaded [3]. QCISD(T); Y; —; RHF; threaded [3]. CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:13790,Availability,reliab,reliability,13790,"/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —; RHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). DF-CCSD(T); Y; —; RHF; threaded [3]. CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). Mk-MRPT2; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; —; RHF/ROHF/TCSCF; threaded [3]. CI(n); Y; —; RHF/ROHF; partially threaded. RAS-CI; Y; —; RHF/ROHF; partially threaded. SAPT; Y; —; RHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . ADC(2); Y; —; RHF; threaded [3]. EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub account.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta4. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introducti",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:3493,Deployability,configurat,configuration,3493,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:3542,Deployability,configurat,configuration,3542,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:15499,Deployability,update,updated,15499," differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub account.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta4. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Functional Theory (DCFT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree-Fock Methods; Second-Order Algebraic-Diagrammatic Construction [ADC(2)]. Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:341,Energy Efficiency,efficient,efficiently,341,"﻿. Introduction — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic s",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:6319,Energy Efficiency,efficient,efficient,6319," F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010).; (doi: 10.1063/1.3305335). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Imp",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:6901,Energy Efficiency,adapt,adapted,6901,"4927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Tri",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:8612,Energy Efficiency,energy,energy,8612,"; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherr",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:13448,Energy Efficiency,energy,energy,13448,"3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QCISD; Y; —; RHF; threaded [3]. QCISD(T); Y; —; RHF; threaded [3]. CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —; RHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). DF-CCSD(T); Y; —; RHF; threaded [3]. CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). Mk-MRPT2; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; —; RHF/ROHF/TCSCF; threaded [3]. CI(n); Y; —; RHF/ROHF; partially threaded. RAS-CI; Y; —; RHF/ROHF; partially threaded. SAPT; Y; —; RHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . ADC(2); Y; —; RHF; threaded [3]. EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub accoun",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:492,Integrability,rout,routine,492,"﻿. Introduction — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic s",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:14636,Integrability,rout,routines,14636," differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub account.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta4. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Functional Theory (DCFT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree-Fock Methods; Second-Order Algebraic-Diagrammatic Construction [ADC(2)]. Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; Installation and Runtime Configuration; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:3493,Modifiability,config,configuration,3493,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:3542,Modifiability,config,configuration,3542,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:6901,Modifiability,adapt,adapted,6901,"4927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Tri",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:1383,Performance,optimiz,optimization,1383," machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci. 2, 556 (2012).; (doi: 1",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:3469,Performance,optimiz,optimized,3469,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:4191,Performance,perform,performance,4191,"9423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) and Cholesky decomposition (CD); coupled cluster in PSI, and its performance for non-covalent interactions; and reaction energies, is discussed in. “Accuracy and Efficiency of Coupled-Cluster Theory Using; Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,; and a T1-Transformed Hamiltonian,” A. E. DePrince and C. D. Sherrill,; submitted. Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC)¶; PSI4 features production-level Mukherjee-style state-specific; coupled-cluster theory, including perturbative triples and also associated; multi-reference perturbation theories. The theory and PSI4; implementation of these methods is discussed in the ",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:4566,Performance,perform,performance,4566," interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) and Cholesky decomposition (CD); coupled cluster in PSI, and its performance for non-covalent interactions; and reaction energies, is discussed in. “Accuracy and Efficiency of Coupled-Cluster Theory Using; Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,; and a T1-Transformed Hamiltonian,” A. E. DePrince and C. D. Sherrill,; submitted. Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC)¶; PSI4 features production-level Mukherjee-style state-specific; coupled-cluster theory, including perturbative triples and also associated; multi-reference perturbation theories. The theory and PSI4; implementation of these methods is discussed in the following papers.; General Mk-MRCC. “Coupling Term Derivation and General Implementation of; State-Specific Multireference Coupled-Cluster Theories,”; F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:6337,Performance,perform,perform,6337," F. A. Evangelista, W. D. Allen, and H. F. Schaefer,; J. Chem. Phys. 127, 024102 (2007).; (doi: 10.1063/1.2743014). Mk-MRCCSD(T). “Perturbative Triples Corrections in State-Specific Multireference; Coupled Cluster Theory,”; F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010).; (doi: 10.1063/1.3305335). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Imp",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:8216,Performance,optimiz,optimized,8216,"656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistr",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:8315,Performance,optimiz,optimization,8315,"the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair ",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:8344,Performance,optimiz,optimized,8344,"the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair ",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:8400,Performance,optimiz,optimized,8400,"the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair ",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:8645,Performance,optimiz,optimized,8645,"; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherr",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:8761,Performance,optimiz,optimized,8761,"r Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its an",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:9333,Performance,optimiz,optimized,9333,"oupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) the",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:9436,Performance,optimiz,optimization,9436,", Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:9465,Performance,optimiz,optimized,9465,", Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:9521,Performance,optimiz,optimized,9521,", Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:9732,Performance,optimiz,optimized,9732,"tal-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:9964,Performance,optimiz,optimized,9964,"ing Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:11417,Performance,perform,perform,11417,"hirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or 12.1 (we have had; trouble with version 12.0). See Sec. Compiling and Installing for details. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DF-SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DCFT; Y; Y; UHF; partially threaded. MP2; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y [2]; RHF/ROHF/UHF; threaded. MP3; Y; Y; RHF/UHF; threaded [3]. MP2.5; Y; Y; RHF/UHF; threaded [3]. MP4; Y; —; RHF; threaded [3]. MP(n); Y; —; RHF/ROHF; partially threaded. ZAPT(n); Y; —; RHF/ROHF; partially threaded. OMP2; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:13382,Performance,optimiz,optimization,13382,"3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QCISD; Y; —; RHF; threaded [3]. QCISD(T); Y; —; RHF; threaded [3]. CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —; RHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). DF-CCSD(T); Y; —; RHF; threaded [3]. CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). Mk-MRPT2; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; —; RHF/ROHF/TCSCF; threaded [3]. CI(n); Y; —; RHF/ROHF; partially threaded. RAS-CI; Y; —; RHF/ROHF; partially threaded. SAPT; Y; —; RHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . ADC(2); Y; —; RHF; threaded [3]. EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub accoun",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:13402,Performance,perform,performed,13402,"3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QCISD; Y; —; RHF; threaded [3]. QCISD(T); Y; —; RHF; threaded [3]. CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —; RHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). DF-CCSD(T); Y; —; RHF; threaded [3]. CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). Mk-MRPT2; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; —; RHF/ROHF/TCSCF; threaded [3]. CI(n); Y; —; RHF/ROHF; partially threaded. RAS-CI; Y; —; RHF/ROHF; partially threaded. SAPT; Y; —; RHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . ADC(2); Y; —; RHF; threaded [3]. EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub accoun",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:11080,Testability,test,tested,11080,"mponent and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or 12.1 (we have had; trouble with version 12.0). See Sec. Compiling and Installing for details. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DF-SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DCFT; Y; Y; UHF; p",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/introduction.html:475,Usability,simpl,simple,475,"﻿. Introduction — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic s",MatchSource.WIKI,psi4manual/4.0b4/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction.html
https://psicode.org/psi4manual/4.0b4/methods-1.html:222,Availability,avail,available,222,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementati",MatchSource.WIKI,psi4manual/4.0b4/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods-1.html
https://psicode.org/psi4manual/4.0b4/methods-1.html:396,Availability,avail,available,396,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementati",MatchSource.WIKI,psi4manual/4.0b4/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods-1.html
https://psicode.org/psi4manual/4.0b4/methods-1.html:332,Deployability,configurat,configuration,332,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementati",MatchSource.WIKI,psi4manual/4.0b4/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods-1.html
https://psicode.org/psi4manual/4.0b4/methods-1.html:1757,Deployability,configurat,configuration,1757,"sity Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Qu",MatchSource.WIKI,psi4manual/4.0b4/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods-1.html
https://psicode.org/psi4manual/4.0b4/methods-1.html:2991,Deployability,update,updated,2991,"ory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods-1.html
https://psicode.org/psi4manual/4.0b4/methods-1.html:332,Modifiability,config,configuration,332,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementati",MatchSource.WIKI,psi4manual/4.0b4/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods-1.html
https://psicode.org/psi4manual/4.0b4/methods-1.html:1757,Modifiability,config,configuration,1757,"sity Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Qu",MatchSource.WIKI,psi4manual/4.0b4/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods-1.html
https://psicode.org/psi4manual/4.0b4/methods.html:222,Availability,avail,available,222,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementati",MatchSource.WIKI,psi4manual/4.0b4/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods.html
https://psicode.org/psi4manual/4.0b4/methods.html:396,Availability,avail,available,396,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementati",MatchSource.WIKI,psi4manual/4.0b4/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods.html
https://psicode.org/psi4manual/4.0b4/methods.html:332,Deployability,configurat,configuration,332,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementati",MatchSource.WIKI,psi4manual/4.0b4/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods.html
https://psicode.org/psi4manual/4.0b4/methods.html:1757,Deployability,configurat,configuration,1757,"sity Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Qu",MatchSource.WIKI,psi4manual/4.0b4/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods.html
https://psicode.org/psi4manual/4.0b4/methods.html:2991,Deployability,update,updated,2991,"ory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods.html
https://psicode.org/psi4manual/4.0b4/methods.html:332,Modifiability,config,configuration,332,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementati",MatchSource.WIKI,psi4manual/4.0b4/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods.html
https://psicode.org/psi4manual/4.0b4/methods.html:1757,Modifiability,config,configuration,1757,"sity Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Qu",MatchSource.WIKI,psi4manual/4.0b4/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/methods.html
https://psicode.org/psi4manual/4.0b4/molden-1.html:460,Availability,avail,available,460,"﻿. Interface to Molden — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to Molden¶; Code author: Justin M. Turney; Section author: C. David Sherrill; PSI4 contains an interface to the Molden program. Molden is a; visualization program for electronic structure developed by Gijs Schaftenaar; at the University of of Nijmegen, Netherlands. It is available at; http://www.cmbi.ru.nl/molden/. Molden can; plot atomic orbitals, densities, electrostatic potentials (ESP’s), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in ”.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. Previous topic; Interface to DFTD3 by S. Grimme; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/molden-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/molden-1.html
https://psicode.org/psi4manual/4.0b4/molden-1.html:1518,Deployability,update,updated,1518,"﻿. Interface to Molden — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to Molden¶; Code author: Justin M. Turney; Section author: C. David Sherrill; PSI4 contains an interface to the Molden program. Molden is a; visualization program for electronic structure developed by Gijs Schaftenaar; at the University of of Nijmegen, Netherlands. It is available at; http://www.cmbi.ru.nl/molden/. Molden can; plot atomic orbitals, densities, electrostatic potentials (ESP’s), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in ”.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. Previous topic; Interface to DFTD3 by S. Grimme; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/molden-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/molden-1.html
https://psicode.org/psi4manual/4.0b4/molden-1.html:283,Integrability,interface,interface,283,"﻿. Interface to Molden — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to Molden¶; Code author: Justin M. Turney; Section author: C. David Sherrill; PSI4 contains an interface to the Molden program. Molden is a; visualization program for electronic structure developed by Gijs Schaftenaar; at the University of of Nijmegen, Netherlands. It is available at; http://www.cmbi.ru.nl/molden/. Molden can; plot atomic orbitals, densities, electrostatic potentials (ESP’s), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in ”.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. Previous topic; Interface to DFTD3 by S. Grimme; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/molden-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/molden-1.html
https://psicode.org/psi4manual/4.0b4/molden.html:460,Availability,avail,available,460,"﻿. Interface to Molden — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to Molden¶; Code author: Justin M. Turney; Section author: C. David Sherrill; PSI4 contains an interface to the Molden program. Molden is a; visualization program for electronic structure developed by Gijs Schaftenaar; at the University of of Nijmegen, Netherlands. It is available at; http://www.cmbi.ru.nl/molden/. Molden can; plot atomic orbitals, densities, electrostatic potentials (ESP’s), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in ”.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. Previous topic; Interface to DFTD3 by S. Grimme; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/molden.html
https://psicode.org/psi4manual/4.0b4/molden.html:1518,Deployability,update,updated,1518,"﻿. Interface to Molden — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to Molden¶; Code author: Justin M. Turney; Section author: C. David Sherrill; PSI4 contains an interface to the Molden program. Molden is a; visualization program for electronic structure developed by Gijs Schaftenaar; at the University of of Nijmegen, Netherlands. It is available at; http://www.cmbi.ru.nl/molden/. Molden can; plot atomic orbitals, densities, electrostatic potentials (ESP’s), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in ”.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. Previous topic; Interface to DFTD3 by S. Grimme; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/molden.html
https://psicode.org/psi4manual/4.0b4/molden.html:283,Integrability,interface,interface,283,"﻿. Interface to Molden — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to Molden¶; Code author: Justin M. Turney; Section author: C. David Sherrill; PSI4 contains an interface to the Molden program. Molden is a; visualization program for electronic structure developed by Gijs Schaftenaar; at the University of of Nijmegen, Netherlands. It is available at; http://www.cmbi.ru.nl/molden/. Molden can; plot atomic orbitals, densities, electrostatic potentials (ESP’s), etc.; PSI4 can create a file containing; atomic coordinates, basis set, and SCF orbital coefficients in the; so-called Molden format. This file is; written by the SCF module (see Section SCF); if the user sets the MOLDEN_WRITE keyword to true. This Molden file is; also used to pass information between PSI4 and WebMO, if PSI4; computations are invoked using the WebMO GUI. The filename of the; Molden file ends in ”.molden”, and the prefix is determined by; WRITER_FILE_LABEL (if set), or else by the name of the output; file plus the name of the current molecule. Previous topic; Interface to DFTD3 by S. Grimme; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/molden.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/molden.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:763,Availability,error,error,763,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1730,Availability,avail,available,1730,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigati",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:2185,Availability,avail,available,2185,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:2906,Deployability,update,updated,2906,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:923,Energy Efficiency,energy,energy,923,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1069,Energy Efficiency,energy,energy,1069,". Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1113,Energy Efficiency,energy,energy,1113,"es: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1214,Energy Efficiency,energy,energy,1214,"es: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1238,Energy Efficiency,energy,energy,1238,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1286,Energy Efficiency,energy,energy,1286,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:372,Integrability,interface,interface,372,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1753,Integrability,interface,interface,1753,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigati",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:2272,Integrability,interface,interface,2272,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1147,Performance,perform,perform,1147,"es: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1316,Performance,perform,perform,1316,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1333,Performance,optimiz,optimization,1333,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:2287,Performance,optimiz,optimize,2287,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:2440,Performance,optimiz,optimize,2440,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:965,Usability,simpl,simply,965,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1246,Usability,simpl,simply,1246,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b4/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:763,Availability,error,error,763,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1730,Availability,avail,available,1730,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigati",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:2185,Availability,avail,available,2185,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:2906,Deployability,update,updated,2906,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:923,Energy Efficiency,energy,energy,923,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1069,Energy Efficiency,energy,energy,1069,". Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1113,Energy Efficiency,energy,energy,1113,"es: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1214,Energy Efficiency,energy,energy,1214,"es: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1238,Energy Efficiency,energy,energy,1238,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1286,Energy Efficiency,energy,energy,1286,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:372,Integrability,interface,interface,372,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1753,Integrability,interface,interface,1753,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigati",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:2272,Integrability,interface,interface,2272,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1147,Performance,perform,perform,1147,"es: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1316,Performance,perform,perform,1316,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1333,Performance,optimiz,optimization,1333,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:2287,Performance,optimiz,optimize,2287,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:2440,Performance,optimiz,optimize,2440,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:965,Usability,simpl,simply,965,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/mrcc.html:1246,Usability,simpl,simply,1246,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b4/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc.html
https://psicode.org/psi4manual/4.0b4/notes_c-1.html:846,Availability,toler,tolerance,846,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_c-1.html
https://psicode.org/psi4manual/4.0b4/notes_c-1.html:1503,Deployability,update,updated,1503,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_c-1.html
https://psicode.org/psi4manual/4.0b4/notes_c-1.html:404,Energy Efficiency,energy,energy,404,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_c-1.html
https://psicode.org/psi4manual/4.0b4/notes_c-1.html:1068,Energy Efficiency,energy,energy,1068,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_c-1.html
https://psicode.org/psi4manual/4.0b4/notes_c.html:846,Availability,toler,tolerance,846,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_c.html
https://psicode.org/psi4manual/4.0b4/notes_c.html:1503,Deployability,update,updated,1503,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_c.html
https://psicode.org/psi4manual/4.0b4/notes_c.html:404,Energy Efficiency,energy,energy,404,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_c.html
https://psicode.org/psi4manual/4.0b4/notes_c.html:1068,Energy Efficiency,energy,energy,1068,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_c.html
https://psicode.org/psi4manual/4.0b4/notes_py-1.html:2063,Deployability,update,updated,2063,"[beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py-1.html
https://psicode.org/psi4manual/4.0b4/notes_py-1.html:349,Energy Efficiency,energy,energy,349,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoki",MatchSource.WIKI,psi4manual/4.0b4/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py-1.html
https://psicode.org/psi4manual/4.0b4/notes_py-1.html:904,Energy Efficiency,energy,energy,904,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoki",MatchSource.WIKI,psi4manual/4.0b4/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py-1.html
https://psicode.org/psi4manual/4.0b4/notes_py-1.html:1274,Energy Efficiency,energy,energy,1274,"[beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py-1.html
https://psicode.org/psi4manual/4.0b4/notes_py-1.html:1409,Integrability,wrap,wrapped,1409,"[beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py-1.html
https://psicode.org/psi4manual/4.0b4/notes_py-1.html:1685,Integrability,wrap,wrapped,1685,"[beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py-1.html
https://psicode.org/psi4manual/4.0b4/notes_py-1.html:847,Performance,optimiz,optimize,847,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoki",MatchSource.WIKI,psi4manual/4.0b4/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py-1.html
https://psicode.org/psi4manual/4.0b4/notes_py.html:2063,Deployability,update,updated,2063,"[beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py.html
https://psicode.org/psi4manual/4.0b4/notes_py.html:349,Energy Efficiency,energy,energy,349,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoki",MatchSource.WIKI,psi4manual/4.0b4/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py.html
https://psicode.org/psi4manual/4.0b4/notes_py.html:904,Energy Efficiency,energy,energy,904,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoki",MatchSource.WIKI,psi4manual/4.0b4/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py.html
https://psicode.org/psi4manual/4.0b4/notes_py.html:1274,Energy Efficiency,energy,energy,1274,"[beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py.html
https://psicode.org/psi4manual/4.0b4/notes_py.html:1409,Integrability,wrap,wrapped,1409,"[beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py.html
https://psicode.org/psi4manual/4.0b4/notes_py.html:1685,Integrability,wrap,wrapped,1685,"[beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py.html
https://psicode.org/psi4manual/4.0b4/notes_py.html:847,Performance,optimiz,optimize,847,"﻿. Notes on Options — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoki",MatchSource.WIKI,psi4manual/4.0b4/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/notes_py.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:10623,Availability,avail,available,10623,"ns it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation ",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:10692,Availability,avail,available,10692,"zed-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Next topic; CC: Coupled Cluster Methods; This Page. Show Source. Quick search. Enter searc",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:11896,Deployability,update,updated,11896,"bation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Next topic; CC: Coupled Cluster Methods; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:1739,Energy Efficiency,energy,energy,1739,"bed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster ba",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:2898,Energy Efficiency,energy,energy,2898," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to th",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:3530,Energy Efficiency,energy,energy,3530,"ngles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Pub",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:3812,Energy Efficiency,energy,energy,3812,"le corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of th",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:3863,Energy Efficiency,energy,energy,3863,"ter potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] an",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:4034,Energy Efficiency,energy,energy,4034,"perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:7336,Energy Efficiency,energy,energy,7336,"3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option ob",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:10236,Energy Efficiency,energy,energy,10236,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:7664,Integrability,depend,depending,7664,"P2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer;",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:430,Performance,optimiz,optimized,430,"﻿. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem a",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:481,Performance,optimiz,optimized,481,"﻿. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem a",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:528,Performance,optimiz,optimized,528,"﻿. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem a",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:1133,Performance,optimiz,optimized,1133,"ical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:1335,Performance,optimiz,optimized,1335,"Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-repres",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:2323,Performance,optimiz,optimized,2323,"y-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. w",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:2352,Performance,optimiz,optimized,2352,"y-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. w",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:2504,Performance,perform,performance,2504,"ole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where su",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:2574,Performance,optimiz,optimized,2574,"ole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where su",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:2773,Performance,optimiz,optimized,2773," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to th",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:3011,Performance,optimiz,optimized,3011,"iction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefo",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:5207,Performance,optimiz,optimized,5207, [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the CEPA0 code should cite the following publication(s):; [Bozkaya:2011:omp2]. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite S,MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:5905,Performance,optimiz,optimized,5905,from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the CEPA0 code should cite the following publication(s):; [Bozkaya:2011:omp2]. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Met,MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:6593,Performance,optimiz,optimized,6593,/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD,MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:6851,Performance,optimiz,optimized,6851, conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations t,MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:8057,Performance,optimiz,optimize,8057,"ponent Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: do",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:8148,Performance,optimiz,optimization,8148,"Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: doubl",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:8489,Performance,perform,performed,8489,"NVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM ",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:9229,Performance,optimiz,optimized-,9229,"phson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and ",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:10250,Performance,optimiz,optimize,10250,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:10562,Performance,optimiz,optimized,10562,"ns it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation ",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:1159,Safety,avoid,avoids,1159,"ical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ-1.html:10161,Security,access,access,10161,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ",MatchSource.WIKI,psi4manual/4.0b4/occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html
https://psicode.org/psi4manual/4.0b4/occ.html:10623,Availability,avail,available,10623,"ns it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation ",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:10692,Availability,avail,available,10692,"zed-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Next topic; CC: Coupled Cluster Methods; This Page. Show Source. Quick search. Enter searc",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:11896,Deployability,update,updated,11896,"bation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Next topic; CC: Coupled Cluster Methods; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:1739,Energy Efficiency,energy,energy,1739,"bed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster ba",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:2898,Energy Efficiency,energy,energy,2898," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to th",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:3530,Energy Efficiency,energy,energy,3530,"ngles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Pub",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:3812,Energy Efficiency,energy,energy,3812,"le corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of th",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:3863,Energy Efficiency,energy,energy,3863,"ter potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] an",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:4034,Energy Efficiency,energy,energy,4034,"perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:7336,Energy Efficiency,energy,energy,7336,"3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option ob",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:10236,Energy Efficiency,energy,energy,10236,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:7664,Integrability,depend,depending,7664,"P2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer;",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:430,Performance,optimiz,optimized,430,"﻿. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem a",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:481,Performance,optimiz,optimized,481,"﻿. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem a",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:528,Performance,optimiz,optimized,528,"﻿. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem a",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:1133,Performance,optimiz,optimized,1133,"ical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:1335,Performance,optimiz,optimized,1335,"Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-repres",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:2323,Performance,optimiz,optimized,2323,"y-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. w",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:2352,Performance,optimiz,optimized,2352,"y-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. w",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:2504,Performance,perform,performance,2504,"ole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where su",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:2574,Performance,optimiz,optimized,2574,"ole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where su",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:2773,Performance,optimiz,optimized,2773," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to th",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:3011,Performance,optimiz,optimized,3011,"iction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefo",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:5207,Performance,optimiz,optimized,5207, [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the CEPA0 code should cite the following publication(s):; [Bozkaya:2011:omp2]. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite S,MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:5905,Performance,optimiz,optimized,5905,from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the CEPA0 code should cite the following publication(s):; [Bozkaya:2011:omp2]. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Met,MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:6593,Performance,optimiz,optimized,6593,/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD,MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:6851,Performance,optimiz,optimized,6851, conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations t,MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:8057,Performance,optimiz,optimize,8057,"ponent Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: do",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:8148,Performance,optimiz,optimization,8148,"Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: doubl",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:8489,Performance,perform,performed,8489,"NVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM ",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:9229,Performance,optimiz,optimized-,9229,"phson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and ",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:10250,Performance,optimiz,optimize,10250,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:10562,Performance,optimiz,optimized,10562,"ns it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation ",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:1159,Safety,avoid,avoids,1159,"ical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/occ.html:10161,Security,access,access,10161,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ",MatchSource.WIKI,psi4manual/4.0b4/occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ.html
https://psicode.org/psi4manual/4.0b4/oeprop-1.html:983,Availability,avail,available,983,"aluation of One-Electron Properties — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Evaluation of One-Electron Properties¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword",MatchSource.WIKI,psi4manual/4.0b4/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html
https://psicode.org/psi4manual/4.0b4/oeprop-1.html:2746,Deployability,update,updated,2746,"; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html
https://psicode.org/psi4manual/4.0b4/oeprop-1.html:1625,Energy Efficiency,charge,charges,1625,"and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . nex",MatchSource.WIKI,psi4manual/4.0b4/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html
https://psicode.org/psi4manual/4.0b4/oeprop-1.html:1669,Energy Efficiency,charge,charges,1669,"et during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theore",MatchSource.WIKI,psi4manual/4.0b4/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html
https://psicode.org/psi4manual/4.0b4/oeprop-1.html:2316,Energy Efficiency,charge,charge,2316,"; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html
https://psicode.org/psi4manual/4.0b4/oeprop-1.html:664,Modifiability,variab,variables,664,"﻿. Evaluation of One-Electron Properties — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Evaluation of One-Electron Properties¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN ke",MatchSource.WIKI,psi4manual/4.0b4/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html
https://psicode.org/psi4manual/4.0b4/oeprop-1.html:1310,Modifiability,variab,variables,1310," Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nu",MatchSource.WIKI,psi4manual/4.0b4/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html
https://psicode.org/psi4manual/4.0b4/oeprop-1.html:1521,Modifiability,variab,variables,1521,"wing syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source",MatchSource.WIKI,psi4manual/4.0b4/oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html
https://psicode.org/psi4manual/4.0b4/oeprop.html:983,Availability,avail,available,983,"aluation of One-Electron Properties — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Evaluation of One-Electron Properties¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword",MatchSource.WIKI,psi4manual/4.0b4/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop.html
https://psicode.org/psi4manual/4.0b4/oeprop.html:2746,Deployability,update,updated,2746,"; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop.html
https://psicode.org/psi4manual/4.0b4/oeprop.html:1625,Energy Efficiency,charge,charges,1625,"and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . nex",MatchSource.WIKI,psi4manual/4.0b4/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop.html
https://psicode.org/psi4manual/4.0b4/oeprop.html:1669,Energy Efficiency,charge,charges,1669,"et during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theore",MatchSource.WIKI,psi4manual/4.0b4/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop.html
https://psicode.org/psi4manual/4.0b4/oeprop.html:2316,Energy Efficiency,charge,charge,2316,"; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop.html
https://psicode.org/psi4manual/4.0b4/oeprop.html:664,Modifiability,variab,variables,664,"﻿. Evaluation of One-Electron Properties — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Evaluation of One-Electron Properties¶; Code author: Robert M. Parrish and Andrew C. Simmonett; Section author: Andrew C. Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN ke",MatchSource.WIKI,psi4manual/4.0b4/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop.html
https://psicode.org/psi4manual/4.0b4/oeprop.html:1310,Modifiability,variab,variables,1310," Simmonett; PSI4 is capable of computing a number of one-electron properties; summarized in the table below. The properties will be computed from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nu",MatchSource.WIKI,psi4manual/4.0b4/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop.html
https://psicode.org/psi4manual/4.0b4/oeprop.html:1521,Modifiability,variab,variables,1521,"wing syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). The named argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source",MatchSource.WIKI,psi4manual/4.0b4/oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:437,Availability,avail,available,437,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7441,Availability,avail,available,7441,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:6997,Deployability,continuous,continuous,6997,"z Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7182,Deployability,continuous,continuous,7182,"z Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:8225,Deployability,update,updated,8225,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:332,Energy Efficiency,energy,energy,332,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:524,Energy Efficiency,energy,energy,524,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:6620,Energy Efficiency,energy,energy,6620,"; PZ81 Correlation. rpbe_x; RPBE GGA Exchange Hole (Parameter Free). sogga; Second Order GGA Exchange-Correlation Functional. sogga_x; Second Order GGA Exchange Hole (Parameter Free). svwn; SVWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:6660,Energy Efficiency,energy,energy,6660,"Second Order GGA Exchange-Correlation Functional. sogga_x; Second Order GGA Exchange Hole (Parameter Free). svwn; SVWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite d",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:6787,Energy Efficiency,energy,energy,6787,"WN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7401,Energy Efficiency,energy,energy,7401,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:379,Modifiability,variab,variables,379,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:180,Performance,optimiz,optimize,180,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:250,Performance,perform,perform,250,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:269,Performance,optimiz,optimization,269,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:342,Performance,optimiz,optimized,342,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:963,Performance,optimiz,optimized,963,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:1035,Performance,optimiz,optimized,1035,"tion. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Corre",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:1075,Performance,optimiz,optimized,1075,"revious    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:1145,Performance,optimiz,optimized,1145,"n ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation F",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:6715,Performance,perform,performed,6715,"Second Order GGA Exchange-Correlation Functional. sogga_x; Second Order GGA Exchange Hole (Parameter Free). svwn; SVWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite d",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:6809,Performance,perform,performs,6809,"WN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7065,Performance,optimiz,optimization,7065,"z Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7141,Performance,optimiz,optimization,7141,"z Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7474,Performance,optimiz,optimization,7474,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7496,Performance,perform,performed,7496,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7632,Performance,optimiz,optimization,7632,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7650,Performance,optimiz,optimize,7650,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7699,Performance,optimiz,optimization,7699,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7769,Performance,optimiz,optimization,7769,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7787,Performance,optimiz,optimize,7787,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:7851,Performance,optimiz,optimization,7851,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt-1.html:6763,Security,access,accesses,6763,"WN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4manual/4.0b4/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html
https://psicode.org/psi4manual/4.0b4/opt.html:437,Availability,avail,available,437,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7441,Availability,avail,available,7441,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:6997,Deployability,continuous,continuous,6997,"z Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7182,Deployability,continuous,continuous,7182,"z Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:8225,Deployability,update,updated,8225,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:332,Energy Efficiency,energy,energy,332,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:524,Energy Efficiency,energy,energy,524,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:6620,Energy Efficiency,energy,energy,6620,"; PZ81 Correlation. rpbe_x; RPBE GGA Exchange Hole (Parameter Free). sogga; Second Order GGA Exchange-Correlation Functional. sogga_x; Second Order GGA Exchange Hole (Parameter Free). svwn; SVWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:6660,Energy Efficiency,energy,energy,6660,"Second Order GGA Exchange-Correlation Functional. sogga_x; Second Order GGA Exchange Hole (Parameter Free). svwn; SVWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite d",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:6787,Energy Efficiency,energy,energy,6787,"WN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7401,Energy Efficiency,energy,energy,7401,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:379,Modifiability,variab,variables,379,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:180,Performance,optimiz,optimize,180,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:250,Performance,perform,perform,250,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:269,Performance,optimiz,optimization,269,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:342,Performance,optimiz,optimized,342,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:963,Performance,optimiz,optimized,963,"﻿. Optimize — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:1035,Performance,optimiz,optimized,1035,"tion. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Corre",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:1075,Performance,optimiz,optimized,1075,"revious    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:1145,Performance,optimiz,optimized,1145,"n ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation F",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:6715,Performance,perform,performed,6715,"Second Order GGA Exchange-Correlation Functional. sogga_x; Second Order GGA Exchange Hole (Parameter Free). svwn; SVWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite d",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:6809,Performance,perform,performs,6809,"WN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7065,Performance,optimiz,optimization,7065,"z Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7141,Performance,optimiz,optimization,7141,"z Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7474,Performance,optimiz,optimization,7474,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7496,Performance,perform,performed,7496,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7632,Performance,optimiz,optimization,7632,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7650,Performance,optimiz,optimize,7650,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7699,Performance,optimiz,optimization,7699,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7769,Performance,optimiz,optimization,7769,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7787,Performance,optimiz,optimize,7787,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:7851,Performance,optimiz,optimization,7851,"e the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/opt.html:6763,Security,access,accesses,6763,"WN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4manual/4.0b4/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:894,Availability,avail,available,894,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:6326,Availability,avail,available,6326,"river function is to query for the value of any option the; function may want to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; PsiMod.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that ",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:11377,Availability,error,error,11377,"n the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, t",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:11598,Availability,error,error,11598,"F', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, this returns whether the option has been touched in the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:11892,Availability,error,error,11892,"l scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, this returns whether the option has been touched in the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by either user or code. Notwithstanding, code is; written such that in practice, this returns whether the option has been; touched in the module scope by the user. PsiMod.has_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched either locally; to specified module or globally, by eith",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:14396,Deployability,update,updated,14396," scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by either user or code. Notwithstanding, code is; written such that in practice, this returns whether the option has been; touched in the module scope by the user. PsiMod.has_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched either locally; to specified module or globally, by either user or code.; Notwithstanding, code is written such that in practice, this returns; whether the option has been touched by the user. PsiMod.revoke_global_option_changed(keyword)¶; Given a string of keyword name, sets the has_changed attribute in the; global options scope to false. Used in python driver when a function; sets the value of an option. Before the function exits, this command is; called on the option so that has_changed reflects whether the user (not; the program) has touched the option. PsiMod.revoke_local_option_changed(module, keyword)¶; Given a string of keyword name and a particular module, sets the; has_changed attribute in the module options scope to false. Used in; python driver when a function sets the value of an option. Before the; function exits, this command is called on the option so that; has_changed reflects whether the user (not the program) has touched the; option. Table Of Contents. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver; PsiMod Options Commands. Previous topic; Programming: Using the Core Libraries; Next topic; Adding Methods to Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:1045,Integrability,rout,routine,1045,"I4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:1241,Integrability,rout,routine,1241,"nd all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.add_str(""AO_BASIS"", ""NONE"", ""NONE DISK DIRECT"");; }. In the above example, the following options are declared (in order):. An integer called PRINT with a default value of 1.; A boolean calle",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:10480,Integrability,depend,depending,10480,"_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Same for FREEZE_CORE. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:407,Modifiability,plugin,plugin,407,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:692,Modifiability,plugin,plugin,692,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:1031,Modifiability,plugin,plugins,1031,"I4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:1085,Modifiability,plugin,plugin,1085,"I4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:10462,Modifiability,variab,variable,10462,"_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Same for FREEZE_CORE. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:7755,Performance,perform,performed,7755,"gative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for interacting with options in the python driver. Preserving User Options (Enforcing definition [a] of has_changed); The first, less-interesting, use of retrieving user option values has; been to preserve them so that they may be restored at the end after the; procedure itself has clobbered them. By decoupling global_option and; local_option commands, this can now be performed neatly by saving at the; beginning the global and local values and the global and local; has_changed values, then restoring them at the end. Below is an example; of this procedure; don’t actually do this.; g_user_scftype = PsiMod.get_global_option('SCF_TYPE'); l_user_scftype_scf = PsiMod.get_local_option('SCF', 'SCF_TYPE'); bg_user_scftype = PsiMod.has_global_option_changed('SCF_TYPE'); bl_user_scftype_scf = PsiMod.has_local_option_changed('SCF', 'SCF_TYPE'). g_user_wfn = PsiMod.get_global_option('WFN'); l_user_wfn = PsiMod.get_local_option('MP2', 'WFN'); bg_user_wfn = PsiMod.has_global_option_changed('WFN'); bl_user_wfn = PsiMod.has_local_option_changed('MP2', 'WFN'). # body of function; # scf_type and wfn are freely changed, LOCALLY; # PsiMod.scf() and PsiMod.mp2() are run. PsiMod.set_global_option('SCF_TYPE', g_user_scftype); if not bg_user_scftype:; PsiMod.revoke_global_option_changed('SCF_TYPE'); PsiMod.set_local_option('SCF', 'SCF_TYPE', l_user_scftype_scf); if not bl_user_scftype_scf:; PsiMod.revoke_local_o",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:805,Security,access,accessible,805,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:6381,Security,access,accessible,6381,"t to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; PsiMod.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for in",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:269,Usability,simpl,simplify,269,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:3369,Usability,clear,clear,3369," A double called FREQUENCY_SCALE_FACTOR with a default of 1.0.; A string called DATA_FILE, with a default of “data.dat” and any possible value.; A string called AO_BASIS with a default of “NONE”, and possible values of “NONE”, “DISK”, or “DIRECT”. The purpose of the “if” statement in the above read_options function is; the following. Suppose in an input file the user sets an option through; the construct set mymodule print 1 or through a set mymodule {...}; block. The first thing to happen is a call to read_options with name set; to “MYMODULE”. (Note that all user input is converted to upper case.) This; call to read_options should tell the Options object only about those; options expected by the module called “mymodule”; this prevents overlap of; options between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed ",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:4114,Usability,guid,guidelines,4114,"between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed value, in addition to the option; value itself. A clarification of definition:. [a] has_changed DOESN’T answer “Has option been changed by the user?”; [b] has_changed DOESN’T answer “Is option now different from the default?”; [c] has_changed DOES answer “Has option value been touched at all, by user or code?”. The above items notwithstanding, psi4 code should be written so that; has_changed DOES effectively mean, “Has option been changed by the; user?”. The way to do this is to isolate and nullify any changes to; options made by the code, the difference between [a] and [c]. C-side,; there is no concern since options are read but essentially never; written-to within the modules.; Py-side is another matter since the driver’s role is to take terse; instruct",MatchSource.WIKI,psi4manual/4.0b4/optionshandling-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:894,Availability,avail,available,894,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:6326,Availability,avail,available,6326,"river function is to query for the value of any option the; function may want to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; PsiMod.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that ",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:11377,Availability,error,error,11377,"n the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, t",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:11598,Availability,error,error,11598,"F', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, this returns whether the option has been touched in the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:11892,Availability,error,error,11892,"l scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; value associated with the keyword in the module options scope. Returns; error if keyword is not recognized for the module. PsiMod.get_option(module, keyword)¶; Given a string of keyword name and a particular module, returns the; local value associated with the keyword if it’s been set, else the global; value if it’s been set, else the local default value. Returns error if; keyword is not recognized globally or if keyword is not recognized for the; module. PsiMod.set_global_option(keyword, value)¶; Sets value to option keyword for all modules. PsiMod.set_local_option(module, keyword, value)¶; Sets value to option keyword scoped only to specific module. PsiMod.has_global_option_changed(keyword)¶; Returns boolean for whether the keyword has been touched in the global; scope, by either user or code. Notwithstanding, code is written such that; in practice, this returns whether the option has been touched in the; global scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by either user or code. Notwithstanding, code is; written such that in practice, this returns whether the option has been; touched in the module scope by the user. PsiMod.has_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched either locally; to specified module or globally, by eith",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:14396,Deployability,update,updated,14396," scope by the user. PsiMod.has_local_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched in the scope of; the specified module, by either user or code. Notwithstanding, code is; written such that in practice, this returns whether the option has been; touched in the module scope by the user. PsiMod.has_option_changed(module, keyword)¶; Returns boolean for whether keyword has been touched either locally; to specified module or globally, by either user or code.; Notwithstanding, code is written such that in practice, this returns; whether the option has been touched by the user. PsiMod.revoke_global_option_changed(keyword)¶; Given a string of keyword name, sets the has_changed attribute in the; global options scope to false. Used in python driver when a function; sets the value of an option. Before the function exits, this command is; called on the option so that has_changed reflects whether the user (not; the program) has touched the option. PsiMod.revoke_local_option_changed(module, keyword)¶; Given a string of keyword name and a particular module, sets the; has_changed attribute in the module options scope to false. Used in; python driver when a function sets the value of an option. Before the; function exits, this command is called on the option so that; has_changed reflects whether the user (not the program) has touched the; option. Table Of Contents. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver; PsiMod Options Commands. Previous topic; Programming: Using the Core Libraries; Next topic; Adding Methods to Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:1045,Integrability,rout,routine,1045,"I4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:1241,Integrability,rout,routine,1241,"nd all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.add_str(""AO_BASIS"", ""NONE"", ""NONE DISK DIRECT"");; }. In the above example, the following options are declared (in order):. An integer called PRINT with a default value of 1.; A boolean calle",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:10480,Integrability,depend,depending,10480,"_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Same for FREEZE_CORE. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:407,Modifiability,plugin,plugin,407,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:692,Modifiability,plugin,plugin,692,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:1031,Modifiability,plugin,plugins,1031,"I4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:1085,Modifiability,plugin,plugin,1085,"I4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:10462,Modifiability,variab,variable,10462,"_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Same for FREEZE_CORE. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:7755,Performance,perform,performed,7755,"gative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for interacting with options in the python driver. Preserving User Options (Enforcing definition [a] of has_changed); The first, less-interesting, use of retrieving user option values has; been to preserve them so that they may be restored at the end after the; procedure itself has clobbered them. By decoupling global_option and; local_option commands, this can now be performed neatly by saving at the; beginning the global and local values and the global and local; has_changed values, then restoring them at the end. Below is an example; of this procedure; don’t actually do this.; g_user_scftype = PsiMod.get_global_option('SCF_TYPE'); l_user_scftype_scf = PsiMod.get_local_option('SCF', 'SCF_TYPE'); bg_user_scftype = PsiMod.has_global_option_changed('SCF_TYPE'); bl_user_scftype_scf = PsiMod.has_local_option_changed('SCF', 'SCF_TYPE'). g_user_wfn = PsiMod.get_global_option('WFN'); l_user_wfn = PsiMod.get_local_option('MP2', 'WFN'); bg_user_wfn = PsiMod.has_global_option_changed('WFN'); bl_user_wfn = PsiMod.has_local_option_changed('MP2', 'WFN'). # body of function; # scf_type and wfn are freely changed, LOCALLY; # PsiMod.scf() and PsiMod.mp2() are run. PsiMod.set_global_option('SCF_TYPE', g_user_scftype); if not bg_user_scftype:; PsiMod.revoke_global_option_changed('SCF_TYPE'); PsiMod.set_local_option('SCF', 'SCF_TYPE', l_user_scftype_scf); if not bl_user_scftype_scf:; PsiMod.revoke_local_o",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:805,Security,access,accessible,805,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:6381,Security,access,accessible,6381,"t to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; PsiMod.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for in",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:269,Usability,simpl,simplify,269,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:3369,Usability,clear,clear,3369," A double called FREQUENCY_SCALE_FACTOR with a default of 1.0.; A string called DATA_FILE, with a default of “data.dat” and any possible value.; A string called AO_BASIS with a default of “NONE”, and possible values of “NONE”, “DISK”, or “DIRECT”. The purpose of the “if” statement in the above read_options function is; the following. Suppose in an input file the user sets an option through; the construct set mymodule print 1 or through a set mymodule {...}; block. The first thing to happen is a call to read_options with name set; to “MYMODULE”. (Note that all user input is converted to upper case.) This; call to read_options should tell the Options object only about those; options expected by the module called “mymodule”; this prevents overlap of; options between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed ",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optionshandling.html:4114,Usability,guid,guidelines,4114,"between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed value, in addition to the option; value itself. A clarification of definition:. [a] has_changed DOESN’T answer “Has option been changed by the user?”; [b] has_changed DOESN’T answer “Is option now different from the default?”; [c] has_changed DOES answer “Has option value been touched at all, by user or code?”. The above items notwithstanding, psi4 code should be written so that; has_changed DOES effectively mean, “Has option been changed by the; user?”. The way to do this is to isolate and nullify any changes to; options made by the code, the difference between [a] and [c]. C-side,; there is no concern since options are read but essentially never; written-to within the modules.; Py-side is another matter since the driver’s role is to take terse; instruct",MatchSource.WIKI,psi4manual/4.0b4/optionshandling.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:594,Availability,redundant,redundant,594,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:732,Availability,redundant,redundant,732,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:1043,Availability,redundant,redundant,1043,"eta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of opt",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:4839,Availability,avail,available,4839,"nternal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:5013,Availability,avail,available,5013,"1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:5258,Availability,avail,available,5258," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:7880,Availability,avail,available,7880,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:659,Deployability,update,update,659,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:5239,Deployability,update,update,5239," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:11028,Deployability,update,updated,11028,"eyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; ADC: Ab Initio Polarization Propagator; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:4351,Energy Efficiency,energy,energy,4351,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:4413,Energy Efficiency,energy,energy,4413,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:7156,Energy Efficiency,monitor,monitors,7156,"en stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:7281,Energy Efficiency,energy,energy,7281,"lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Ma",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:8768,Energy Efficiency,monitor,monitored,8768,"dance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; -------------",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:9172,Energy Efficiency,monitor,monitored,9172,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:344,Performance,optimiz,optimizations,344,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:2897,Performance,optimiz,optimization,2897,"ll result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; ",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:3097,Performance,optimiz,optimization,3097,"ich connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the fo",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:3168,Performance,optimiz,optimization,3168,"ragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optim",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:3627,Performance,optimiz,optimization,3627,"c; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; int",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:4225,Performance,optimiz,optimize,4225,"of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:4319,Performance,optimiz,optimize,4319,"the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; ",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:4388,Performance,optimiz,optimize,4388,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:4511,Performance,optimiz,optimize,4511,"efault: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a star",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:4681,Performance,optimiz,optimize,4681,"means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:4776,Performance,optimiz,optimize,4776,"N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set ",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:5386,Performance,optimiz,optimization,5386,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragmen",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:5535,Performance,optimiz,optimize,5535,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment c",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:5793,Performance,optimiz,optimize,5793,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fr",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:6122,Performance,optimiz,optimize,6122,"Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 ",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:6220,Performance,optimiz,optimize,6220,"he; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to eva",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:6566,Performance,optimiz,optimizations,6566,"mize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of di",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:6927,Performance,optimiz,optimize,6927,"347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. G",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:7221,Performance,optimiz,optimization,7221,"en stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:7858,Performance,optimiz,optimization,7858,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:9152,Performance,optimiz,optimization,9152,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:10352,Performance,optimiz,optimizations,10352,"eyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; ADC: Ab Initio Polarization Propagator; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:10382,Performance,optimiz,optimize,10382,"eyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; ADC: Ab Initio Polarization Propagator; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:594,Safety,redund,redundant,594,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:732,Safety,redund,redundant,732,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:1043,Safety,redund,redundant,1043,"eta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of opt",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:9053,Safety,avoid,avoid,9053,"MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:903,Testability,test,tested,903,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:1305,Testability,test,testing,1305," optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole sys",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking-1.html:5140,Usability,simpl,simple,5140,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coord",MatchSource.WIKI,psi4manual/4.0b4/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html
https://psicode.org/psi4manual/4.0b4/optking.html:594,Availability,redundant,redundant,594,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:732,Availability,redundant,redundant,732,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:1043,Availability,redundant,redundant,1043,"eta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of opt",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:4839,Availability,avail,available,4839,"nternal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:5013,Availability,avail,available,5013,"1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:5258,Availability,avail,available,5258," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:7880,Availability,avail,available,7880,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:659,Deployability,update,update,659,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:5239,Deployability,update,update,5239," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:11028,Deployability,update,updated,11028,"eyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; ADC: Ab Initio Polarization Propagator; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:4351,Energy Efficiency,energy,energy,4351,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:4413,Energy Efficiency,energy,energy,4413,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:7156,Energy Efficiency,monitor,monitors,7156,"en stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:7281,Energy Efficiency,energy,energy,7281,"lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Ma",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:8768,Energy Efficiency,monitor,monitored,8768,"dance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; -------------",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:9172,Energy Efficiency,monitor,monitored,9172,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:344,Performance,optimiz,optimizations,344,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:2897,Performance,optimiz,optimization,2897,"ll result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; ",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:3097,Performance,optimiz,optimization,3097,"ich connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the fo",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:3168,Performance,optimiz,optimization,3168,"ragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optim",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:3627,Performance,optimiz,optimization,3627,"c; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; int",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:4225,Performance,optimiz,optimize,4225,"of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:4319,Performance,optimiz,optimize,4319,"the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; ",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:4388,Performance,optimiz,optimize,4388,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:4511,Performance,optimiz,optimize,4511,"efault: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a star",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:4681,Performance,optimiz,optimize,4681,"means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:4776,Performance,optimiz,optimize,4776,"N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set ",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:5386,Performance,optimiz,optimization,5386,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragmen",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:5535,Performance,optimiz,optimize,5535,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment c",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:5793,Performance,optimiz,optimize,5793,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fr",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:6122,Performance,optimiz,optimize,6122,"Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 ",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:6220,Performance,optimiz,optimize,6220,"he; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to eva",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:6566,Performance,optimiz,optimizations,6566,"mize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of di",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:6927,Performance,optimiz,optimize,6927,"347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. G",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:7221,Performance,optimiz,optimization,7221,"en stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:7858,Performance,optimiz,optimization,7858,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:9152,Performance,optimiz,optimization,9152,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:10352,Performance,optimiz,optimizations,10352,"eyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; ADC: Ab Initio Polarization Propagator; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:10382,Performance,optimiz,optimize,10382,"eyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; ADC: Ab Initio Polarization Propagator; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:594,Safety,redund,redundant,594,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:732,Safety,redund,redundant,732,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:1043,Safety,redund,redundant,1043,"eta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of opt",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:9053,Safety,avoid,avoid,9053,"MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:903,Testability,test,tested,903,"﻿. Geometry Optimization — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representati",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:1305,Testability,test,testing,1305," optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole sys",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/optking.html:5140,Usability,simpl,simple,5140,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coord",MatchSource.WIKI,psi4manual/4.0b4/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking.html
https://psicode.org/psi4manual/4.0b4/pep0001-1.html:1580,Availability,down,down,1580,"osal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; ",MatchSource.WIKI,psi4manual/4.0b4/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001-1.html
https://psicode.org/psi4manual/4.0b4/pep0001-1.html:3551,Deployability,update,updated,3551,"e statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 »; PsiPEP: Plans and Practices to Organize PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001-1.html
https://psicode.org/psi4manual/4.0b4/pep0001-1.html:520,Integrability,protocol,protocol,520,"﻿. PEP1: Proposing PsiPEP for PSI4 — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 »; PsiPEP: Plans and Practices to Organize PSI4 ». PEP1: Proposing PsiPEP for PSI4¶. PEP:1. Title:Proposing PsiPEP for PSI4. Last-Modified:04-Jul-2012. Author:Lori Burns. Content-Type:text/x-rst. Created:04-Jul-2012. This document proposes using a (much more informal) version of Python’s; PEP (Python Enhancement Proposal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices o",MatchSource.WIKI,psi4manual/4.0b4/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001-1.html
https://psicode.org/psi4manual/4.0b4/pep0001-1.html:2287,Integrability,interface,interface,2287,"ther PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a mo",MatchSource.WIKI,psi4manual/4.0b4/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001-1.html
https://psicode.org/psi4manual/4.0b4/pep0001-1.html:2361,Integrability,interface,interface,2361," Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . ",MatchSource.WIKI,psi4manual/4.0b4/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001-1.html
https://psicode.org/psi4manual/4.0b4/pep0001-1.html:1603,Usability,simpl,simple,1603,"e is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them.",MatchSource.WIKI,psi4manual/4.0b4/pep0001-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001-1.html
https://psicode.org/psi4manual/4.0b4/pep0001.html:1580,Availability,down,down,1580,"osal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; ",MatchSource.WIKI,psi4manual/4.0b4/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001.html
https://psicode.org/psi4manual/4.0b4/pep0001.html:3551,Deployability,update,updated,3551,"e statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 »; PsiPEP: Plans and Practices to Organize PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001.html
https://psicode.org/psi4manual/4.0b4/pep0001.html:520,Integrability,protocol,protocol,520,"﻿. PEP1: Proposing PsiPEP for PSI4 — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 »; PsiPEP: Plans and Practices to Organize PSI4 ». PEP1: Proposing PsiPEP for PSI4¶. PEP:1. Title:Proposing PsiPEP for PSI4. Last-Modified:04-Jul-2012. Author:Lori Burns. Content-Type:text/x-rst. Created:04-Jul-2012. This document proposes using a (much more informal) version of Python’s; PEP (Python Enhancement Proposal PEP1) protocol to organize; PSI4. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices o",MatchSource.WIKI,psi4manual/4.0b4/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001.html
https://psicode.org/psi4manual/4.0b4/pep0001.html:2287,Integrability,interface,interface,2287,"ther PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a mo",MatchSource.WIKI,psi4manual/4.0b4/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001.html
https://psicode.org/psi4manual/4.0b4/pep0001.html:2361,Integrability,interface,interface,2361," Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there’s; no question of whether the task is to be done as described. Comments¶; 04-Jul-2012, LAB; This is an example comment that refers to PEP1: Proposing PsiPEP for PSI4 and a trac ticket #221. Table Of Contents. PEP1: Proposing PsiPEP for PSI4; Path of a PsiPEP; Roles of a PsiPEP Include; Comments. Previous topic; PsiPEP: Plans and Practices to Organize PSI4; Next topic; Programming: Using the Core Libraries; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . ",MatchSource.WIKI,psi4manual/4.0b4/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001.html
https://psicode.org/psi4manual/4.0b4/pep0001.html:1603,Usability,simpl,simple,1603,"e is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them.",MatchSource.WIKI,psi4manual/4.0b4/pep0001.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/pep0001.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3296,Availability,avail,available,3296,"plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5087,Availability,avail,available,5087,"e and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C+",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:7873,Deployability,update,updated,7873,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5031,Energy Efficiency,energy,energy,5031,"tegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additio",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5515,Energy Efficiency,energy,energy,5515,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5556,Energy Efficiency,energy,energy,5556,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:1159,Integrability,wrap,wrapped,1159,"s: Adding New Functionality to PSI4¶. Modular Approach to Development¶; The redesign of PSI4 into a single-executable changed the way that; code development is done. The standalone nature of modules in previous; versions of Psi made their development very easy, as new functionality; could be implemented almost as a standalone executable, which could easily; be ported into the Psi code when completed. The new design specifies that; these modules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5944,Integrability,depend,depends,5944,"y must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:1857,Modifiability,plugin,plugin,1857," be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2036,Modifiability,plugin,plugins,2036,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplu",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2108,Modifiability,plugin,plugins,2108,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2170,Modifiability,plugin,plugins,2170,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2193,Modifiability,config,configure,2193,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2233,Modifiability,plugin,plugins,2233,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2299,Modifiability,plugin,plugins,2299,"to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consul",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2397,Modifiability,plugin,plugin,2397," it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. Fo",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2558,Modifiability,plugin,plugin,2558,"ed to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2643,Modifiability,plugin,plugin,2643,"le initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no sy",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3048,Modifiability,plugin,plugin,3048,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3093,Modifiability,plugin,plugin,3093,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3138,Modifiability,plugin,plugin,3138,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3183,Modifiability,plugin,plugin,3183,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3229,Modifiability,plugin,plugin,3229,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3273,Modifiability,plugin,plugin,3273,"plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3330,Modifiability,plugin,plugins,3330,"plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3355,Modifiability,plugin,plugin,3355,"e a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3449,Modifiability,plugin,plugin,3449," name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directo",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3494,Modifiability,plugin,plugins,3494," is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3759,Modifiability,plugin,plugins,3759," Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, t",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3888,Modifiability,plugin,plugins,3888,"t starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,;",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3913,Modifiability,plugin,plugin,3913," AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3994,Modifiability,plugin,plugins,3994,"ds that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import my",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4213,Modifiability,plugin,plugin,4213,"w-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. T",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4340,Modifiability,plugin,plugin,4340," directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4403,Modifiability,plugin,plugin,4403,"documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin()",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4444,Modifiability,plugin,plugin,4444,"documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin()",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4604,Modifiability,config,configure,4604,"AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any o",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4631,Modifiability,plugin,plugins,4631,"AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any o",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4680,Modifiability,plugin,plugin,4680,"ns.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4726,Modifiability,plugin,plugin,4726,"s/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). Th",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4775,Modifiability,plugin,plugin,4775,"s/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). Th",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4844,Modifiability,plugin,plugin,4844,"ins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines t",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4974,Modifiability,plugin,plugin,4974,"tegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additio",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5219,Modifiability,plugin,plugin,5219,"resh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __a",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5254,Modifiability,plugin,plugin,5254,"files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modu",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5405,Modifiability,plugin,plugin,5405,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5462,Modifiability,plugin,plugin,5462,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5688,Modifiability,plugin,plugin,5688,"ile makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for sam",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5725,Modifiability,plugin,plugin,5725,"ile makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for sam",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5851,Modifiability,plugin,plugin,5851,"y must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5937,Modifiability,plugin,plugin,5937,"y must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5974,Modifiability,plugin,plugin,5974," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, crea",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:6052,Modifiability,plugin,plugin,6052," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, crea",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:6088,Modifiability,plugin,plugin,6088," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, crea",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:6294,Modifiability,plugin,plugin,6294,"; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the pl",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:7042,Modifiability,plugin,plugin,7042,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:7063,Modifiability,plugin,plugin,7063,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:7310,Modifiability,plugin,plugin,7310,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2051,Performance,load,loaded,2051,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplu",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:2222,Performance,load,loading,2222,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:4988,Performance,load,loaded,4988,"tegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additio",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:7158,Performance,load,loading,7158,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:7298,Performance,load,loading,7298,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5538,Security,access,accessed,5538,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3637,Testability,test,tests,3637," In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.da",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:3679,Testability,test,test,3679," All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py fi",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5133,Testability,test,testfunction,5133,"tory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).;",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:6123,Testability,test,tests,6123," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, crea",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:1564,Usability,learn,learn,1564,"dules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In ",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5297,Usability,simpl,simple,5297,"you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins-1.html:5325,Usability,simpl,simpler,5325,"you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b4/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3296,Availability,avail,available,3296,"plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5087,Availability,avail,available,5087,"e and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C+",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:7873,Deployability,update,updated,7873,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5031,Energy Efficiency,energy,energy,5031,"tegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additio",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5515,Energy Efficiency,energy,energy,5515,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5556,Energy Efficiency,energy,energy,5556,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:1159,Integrability,wrap,wrapped,1159,"s: Adding New Functionality to PSI4¶. Modular Approach to Development¶; The redesign of PSI4 into a single-executable changed the way that; code development is done. The standalone nature of modules in previous; versions of Psi made their development very easy, as new functionality; could be implemented almost as a standalone executable, which could easily; be ported into the Psi code when completed. The new design specifies that; these modules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5944,Integrability,depend,depends,5944,"y must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:1857,Modifiability,plugin,plugin,1857," be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2036,Modifiability,plugin,plugins,2036,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplu",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2108,Modifiability,plugin,plugins,2108,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2170,Modifiability,plugin,plugins,2170,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2193,Modifiability,config,configure,2193,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2233,Modifiability,plugin,plugins,2233,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2299,Modifiability,plugin,plugins,2299,"to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consul",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2397,Modifiability,plugin,plugin,2397," it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. Fo",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2558,Modifiability,plugin,plugin,2558,"ed to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2643,Modifiability,plugin,plugin,2643,"le initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no sy",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3048,Modifiability,plugin,plugin,3048,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3093,Modifiability,plugin,plugin,3093,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3138,Modifiability,plugin,plugin,3138,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3183,Modifiability,plugin,plugin,3183,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3229,Modifiability,plugin,plugin,3229,"gins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3273,Modifiability,plugin,plugin,3273,"plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3330,Modifiability,plugin,plugins,3330,"plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3355,Modifiability,plugin,plugin,3355,"e a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3449,Modifiability,plugin,plugin,3449," name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directo",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3494,Modifiability,plugin,plugins,3494," is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3759,Modifiability,plugin,plugins,3759," Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, t",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3888,Modifiability,plugin,plugins,3888,"t starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,;",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3913,Modifiability,plugin,plugin,3913," AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3994,Modifiability,plugin,plugins,3994,"ds that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import my",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4213,Modifiability,plugin,plugin,4213,"w-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. T",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4340,Modifiability,plugin,plugin,4340," directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4403,Modifiability,plugin,plugin,4403,"documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin()",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4444,Modifiability,plugin,plugin,4444,"documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin()",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4604,Modifiability,config,configure,4604,"AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any o",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4631,Modifiability,plugin,plugins,4631,"AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any o",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4680,Modifiability,plugin,plugin,4680,"ns.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4726,Modifiability,plugin,plugin,4726,"s/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). Th",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4775,Modifiability,plugin,plugin,4775,"s/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). Th",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4844,Modifiability,plugin,plugin,4844,"ins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines t",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4974,Modifiability,plugin,plugin,4974,"tegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additio",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5219,Modifiability,plugin,plugin,5219,"resh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __a",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5254,Modifiability,plugin,plugin,5254,"files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modu",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5405,Modifiability,plugin,plugin,5405,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5462,Modifiability,plugin,plugin,5462,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5688,Modifiability,plugin,plugin,5688,"ile makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for sam",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5725,Modifiability,plugin,plugin,5725,"ile makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for sam",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5851,Modifiability,plugin,plugin,5851,"y must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5937,Modifiability,plugin,plugin,5937,"y must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5974,Modifiability,plugin,plugin,5974," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, crea",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:6052,Modifiability,plugin,plugin,6052," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, crea",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:6088,Modifiability,plugin,plugin,6088," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, crea",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:6294,Modifiability,plugin,plugin,6294,"; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the pl",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:7042,Modifiability,plugin,plugin,7042,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:7063,Modifiability,plugin,plugin,7063,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:7310,Modifiability,plugin,plugin,7310,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2051,Performance,load,loaded,2051,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplu",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:2222,Performance,load,loading,2222,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>>",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:4988,Performance,load,loaded,4988,"tegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additio",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:7158,Performance,load,loading,7158,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:7298,Performance,load,loading,7298,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5538,Security,access,accessed,5538,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3637,Testability,test,tests,3637," In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.da",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:3679,Testability,test,test,3679," All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py fi",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5133,Testability,test,testfunction,5133,"tory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).;",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:6123,Testability,test,tests,6123," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, crea",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:1564,Usability,learn,learn,1564,"dules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In ",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5297,Usability,simpl,simple,5297,"you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/plugins.html:5325,Usability,simpl,simpler,5325,"you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b4/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins.html
https://psicode.org/psi4manual/4.0b4/proc_py-1.html:4071,Deployability,update,updated,4071," without a module in; OptionsState.; # include if necessary as globals; PsiMod.set_global_option('BASIS', guessbasis); PsiMod.set_global_option('DF_BASIS_SCF', guessbasisdf). # include if necessary as locals; PsiMod.set_local_option('TRANSQT2', 'WFN', 'MP2'); PsiMod.set_local_option('CCSORT', 'WFN', 'MP2'); PsiMod.set_local_option('MP2', 'WFN', 'MP2'). If the regular scf module is to be run, run it through; scf_helper() so that cast-up can be used. Also, add the; option to bypass it by pre-running scf, then running the module with this; bypass_scf kwarg. Also, if the full two-electron integrals are; necessary for the post-scf, compute them if only the df integrals were run; previously.; # include if scf module is to be run. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # include if TEI are needed beyond scf. # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; PsiMod.transqt2(); PsiMod.ccsort(); PsiMod.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Previous topic; LibOptions: globals, locals, has_changed and all that; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py-1.html
https://psicode.org/psi4manual/4.0b4/proc_py-1.html:665,Energy Efficiency,energy,energy,665,"﻿. Adding Methods to Driver — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». Adding Methods to Driver¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_",MatchSource.WIKI,psi4manual/4.0b4/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py-1.html
https://psicode.org/psi4manual/4.0b4/proc_py-1.html:1002,Energy Efficiency,energy,energy,1002,"﻿. Adding Methods to Driver — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». Adding Methods to Driver¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_",MatchSource.WIKI,psi4manual/4.0b4/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py-1.html
https://psicode.org/psi4manual/4.0b4/proc_py-1.html:3658,Energy Efficiency,energy,energy,3658," without a module in; OptionsState.; # include if necessary as globals; PsiMod.set_global_option('BASIS', guessbasis); PsiMod.set_global_option('DF_BASIS_SCF', guessbasisdf). # include if necessary as locals; PsiMod.set_local_option('TRANSQT2', 'WFN', 'MP2'); PsiMod.set_local_option('CCSORT', 'WFN', 'MP2'); PsiMod.set_local_option('MP2', 'WFN', 'MP2'). If the regular scf module is to be run, run it through; scf_helper() so that cast-up can be used. Also, add the; option to bypass it by pre-running scf, then running the module with this; bypass_scf kwarg. Also, if the full two-electron integrals are; necessary for the post-scf, compute them if only the df integrals were run; previously.; # include if scf module is to be run. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # include if TEI are needed beyond scf. # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; PsiMod.transqt2(); PsiMod.ccsort(); PsiMod.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Previous topic; LibOptions: globals, locals, has_changed and all that; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py-1.html
https://psicode.org/psi4manual/4.0b4/proc_py-1.html:2871,Integrability,rout,routine,2871,"ave an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_OS_SCALE'],; ). If options need to be set, set them anywhere here. Options should be set; locally to a module, except for those without a module in; OptionsState.; # include if necessary as globals; PsiMod.set_global_option('BASIS', guessbasis); PsiMod.set_global_option('DF_BASIS_SCF', guessbasisdf). # include if necessary as locals; PsiMod.set_local_option('TRANSQT2', 'WFN', 'MP2'); PsiMod.set_local_option('CCSORT', 'WFN', 'MP2'); PsiMod.set_local_option('MP2', 'WFN', 'MP2'). If the regular scf module is to be run, run it through; scf_helper() so that cast-up can be used. Also, add the; option to bypass it by pre-running scf, then running the module with this; bypass_scf kwarg. Also, if the full two-electron integrals are; necessary for the post-scf, compute them if only the df integrals were run; previously.; # include if scf module is to be run. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # include if TEI are needed beyond scf. # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; PsiMod.transqt2(); PsiMod.ccsort(); PsiMod.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Previous topic; LibOptions: globals, locals, has_changed and all that; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. i",MatchSource.WIKI,psi4manual/4.0b4/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py-1.html
https://psicode.org/psi4manual/4.0b4/proc_py-1.html:912,Modifiability,variab,variable,912,"﻿. Adding Methods to Driver — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». Adding Methods to Driver¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_",MatchSource.WIKI,psi4manual/4.0b4/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py-1.html
https://psicode.org/psi4manual/4.0b4/proc_py-1.html:807,Testability,test,test,807,"﻿. Adding Methods to Driver — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». Adding Methods to Driver¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_",MatchSource.WIKI,psi4manual/4.0b4/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py-1.html
https://psicode.org/psi4manual/4.0b4/proc_py.html:4071,Deployability,update,updated,4071," without a module in; OptionsState.; # include if necessary as globals; PsiMod.set_global_option('BASIS', guessbasis); PsiMod.set_global_option('DF_BASIS_SCF', guessbasisdf). # include if necessary as locals; PsiMod.set_local_option('TRANSQT2', 'WFN', 'MP2'); PsiMod.set_local_option('CCSORT', 'WFN', 'MP2'); PsiMod.set_local_option('MP2', 'WFN', 'MP2'). If the regular scf module is to be run, run it through; scf_helper() so that cast-up can be used. Also, add the; option to bypass it by pre-running scf, then running the module with this; bypass_scf kwarg. Also, if the full two-electron integrals are; necessary for the post-scf, compute them if only the df integrals were run; previously.; # include if scf module is to be run. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # include if TEI are needed beyond scf. # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; PsiMod.transqt2(); PsiMod.ccsort(); PsiMod.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Previous topic; LibOptions: globals, locals, has_changed and all that; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py.html
https://psicode.org/psi4manual/4.0b4/proc_py.html:665,Energy Efficiency,energy,energy,665,"﻿. Adding Methods to Driver — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». Adding Methods to Driver¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_",MatchSource.WIKI,psi4manual/4.0b4/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py.html
https://psicode.org/psi4manual/4.0b4/proc_py.html:1002,Energy Efficiency,energy,energy,1002,"﻿. Adding Methods to Driver — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». Adding Methods to Driver¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_",MatchSource.WIKI,psi4manual/4.0b4/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py.html
https://psicode.org/psi4manual/4.0b4/proc_py.html:3658,Energy Efficiency,energy,energy,3658," without a module in; OptionsState.; # include if necessary as globals; PsiMod.set_global_option('BASIS', guessbasis); PsiMod.set_global_option('DF_BASIS_SCF', guessbasisdf). # include if necessary as locals; PsiMod.set_local_option('TRANSQT2', 'WFN', 'MP2'); PsiMod.set_local_option('CCSORT', 'WFN', 'MP2'); PsiMod.set_local_option('MP2', 'WFN', 'MP2'). If the regular scf module is to be run, run it through; scf_helper() so that cast-up can be used. Also, add the; option to bypass it by pre-running scf, then running the module with this; bypass_scf kwarg. Also, if the full two-electron integrals are; necessary for the post-scf, compute them if only the df integrals were run; previously.; # include if scf module is to be run. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # include if TEI are needed beyond scf. # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; PsiMod.transqt2(); PsiMod.ccsort(); PsiMod.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Previous topic; LibOptions: globals, locals, has_changed and all that; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py.html
https://psicode.org/psi4manual/4.0b4/proc_py.html:2871,Integrability,rout,routine,2871,"ave an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_OS_SCALE'],; ). If options need to be set, set them anywhere here. Options should be set; locally to a module, except for those without a module in; OptionsState.; # include if necessary as globals; PsiMod.set_global_option('BASIS', guessbasis); PsiMod.set_global_option('DF_BASIS_SCF', guessbasisdf). # include if necessary as locals; PsiMod.set_local_option('TRANSQT2', 'WFN', 'MP2'); PsiMod.set_local_option('CCSORT', 'WFN', 'MP2'); PsiMod.set_local_option('MP2', 'WFN', 'MP2'). If the regular scf module is to be run, run it through; scf_helper() so that cast-up can be used. Also, add the; option to bypass it by pre-running scf, then running the module with this; bypass_scf kwarg. Also, if the full two-electron integrals are; necessary for the post-scf, compute them if only the df integrals were run; previously.; # include if scf module is to be run. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # include if TEI are needed beyond scf. # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; PsiMod.transqt2(); PsiMod.ccsort(); PsiMod.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Previous topic; LibOptions: globals, locals, has_changed and all that; Next topic; Python Driver; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. i",MatchSource.WIKI,psi4manual/4.0b4/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py.html
https://psicode.org/psi4manual/4.0b4/proc_py.html:912,Modifiability,variab,variable,912,"﻿. Adding Methods to Driver — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». Adding Methods to Driver¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_",MatchSource.WIKI,psi4manual/4.0b4/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py.html
https://psicode.org/psi4manual/4.0b4/proc_py.html:807,Testability,test,test,807,"﻿. Adding Methods to Driver — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». Adding Methods to Driver¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_",MatchSource.WIKI,psi4manual/4.0b4/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/proc_py.html
https://psicode.org/psi4manual/4.0b4/programming-1.html:733,Deployability,update,updated,733,"﻿. Programming: Using the Core Libraries — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Programming: Using the Core Libraries¶. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver; PsiMod Options Commands. Adding Methods to Driver. Previous topic; PEP1: Proposing PsiPEP for PSI4; Next topic; LibOptions: globals, locals, has_changed and all that; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/programming-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/programming-1.html
https://psicode.org/psi4manual/4.0b4/programming.html:733,Deployability,update,updated,733,"﻿. Programming: Using the Core Libraries — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Programming: Using the Core Libraries¶. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver; PsiMod Options Commands. Adding Methods to Driver. Previous topic; PEP1: Proposing PsiPEP for PSI4; Next topic; LibOptions: globals, locals, has_changed and all that; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/programming.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/programming.html
https://psicode.org/psi4manual/4.0b4/prop-1.html:1636,Deployability,update,updated,1636,"﻿. Property — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). df-mp2; MP2 with density fitting. eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/prop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/prop-1.html
https://psicode.org/psi4manual/4.0b4/prop.html:1636,Deployability,update,updated,1636,"﻿. Property — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). df-mp2; MP2 with density fitting. eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/prop.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:51813,Availability,fault,faulty,51813,"on>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (opt",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:52976,Availability,toler,tolerance,52976," Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real an",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:55558,Availability,checkpoint,checkpoint,55558,"; | fix_com(...); | fix_com( (Molecule)arg1, (bool)arg2) -> None :; | Whether to fix the Cartesian position, or to translate to the C.O.M.; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:55674,Availability,checkpoint,checkpoint,55674,"rientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fr",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:58681,Availability,checkpoint,checkpoint,58681,"_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_atoms( (Molecule)arg1, (str)arg2, (str)arg3) -> None :; | Sets basis set arg2 to all atoms; | ; | set_basis_by_label(...); | set_basis_by_label( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with label (e.g., H4) arg2; | ; | set_basis_by_number(...); | set_basis_by_number( (Molecule)arg1, (int)arg2, (str)arg3, (str)arg4) -> None",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:61335,Availability,toler,tolerance,61335,"ets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | --------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:107890,Availability,error,error,107890,"ints, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns err",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:108475,Availability,error,error,108475," output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope b",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:108598,Availability,avail,available,108598,"nergy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)a",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:108900,Availability,error,error,108900,"ption_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Ret",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:109173,Availability,avail,available,109173,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:115437,Availability,avail,available,115437,"2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradient to the values stored in the N by 3 Matrix argument.; ; set_local_option(...); set_local_option( (str)arg1, (str)arg2, (str)arg3) -> bool :; Sets a string option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi.; ; wavefunction(...); wavefunction() -> Wavefunction :; Returns the current wavefunction object from the most recent com",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:105792,Deployability,configurat,configuration,105792," -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1)",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:116967,Deployability,update,updated,116967,"r)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi.; ; wavefunction(...); wavefunction() -> Wavefunction :; Returns the current wavefunction object from the most recent computation. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:31667,Energy Efficiency,energy,energy,31667,"| ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:31682,Energy Efficiency,energy,energy,31682,"..); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:41666,Energy Efficiency,power,power,41666,"-> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (floa",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:41680,Energy Efficiency,power,power,41680,"ocstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | set(...); | set( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) ->",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:51469,Energy Efficiency,charge,charge,51469,".__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:51979,Energy Efficiency,charge,charge,51979,"ost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_ma",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:52760,Energy Efficiency,charge,charge,52760,"a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | ext",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:53142,Energy Efficiency,charge,charge,53142,"molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 f",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:53157,Energy Efficiency,charge,charge,53157," function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | Returns copy of arg1 with arg2",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:53211,Energy Efficiency,charge,charge,53211," function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | Returns copy of arg1 with arg2",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:56211,Energy Efficiency,charge,charge,56211,"up name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cart",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:56817,Energy Efficiency,energy,energy,56817," bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in input units; | ; | print_out_in_angstrom(...); | print_out_in_angstrom( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | ru",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:58218,Energy Efficiency,energy,energy,58218,"Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:58289,Energy Efficiency,energy,energy,58289,"Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:60471,Energy Efficiency,charge,charge,60471," (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with label (e.g., H4) arg2; | ; | set_basis_by_number(...); | set_basis_by_number( (Molecule)arg1, (int)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to atom number (1-indexed, incl. dummies) arg2; | ; | set_basis_by_symbol(...); | set_basis_by_symbol( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with symbol (e.g., H) arg2; | ; | set_geometry(...); | set_geometry( (Molecule)arg1, (Matrix)arg2) -> None :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1,",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:78131,Energy Efficiency,energy,energy,78131,"| ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:78146,Energy Efficiency,energy,energy,78146,"..); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:81534,Energy Efficiency,allocate,allocate,81534,"nit__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunc",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:81551,Energy Efficiency,allocate,allocate,81551,"ated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1)",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:94870,Energy Efficiency,energy,energy,94870,"ocstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:94885,Energy Efficiency,energy,energy,94885,"| ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:104747,Energy Efficiency,energy,energy,104747,"nt)arg9) -> None :; docstring; ; IDAMAX(...); IDAMAX( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> int :; docstring; ; adc(...); adc() -> float :; Runs the ADC propagator code, for excited states.; ; add_user_basis_file(...); add_user_basis_file( (str)arg1) -> None :; Adds a custom basis set file, provided by the user.; ; benchmark_blas1(...); benchmark_blas1( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas2(...); benchmark_blas2( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas3(...); benchmark_blas3( (int)arg1, (float)arg2, (int)arg3) -> None :; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:105334,Energy Efficiency,energy,energy,105334,":; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnT",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:106085,Energy Efficiency,adapt,adapted,106085,"equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fo",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:106231,Energy Efficiency,energy,energy,106231,"ns CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:106376,Energy Efficiency,energy,energy,106376,"nergy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:106716,Energy Efficiency,energy,energy,106716,"acts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :;",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:106894,Energy Efficiency,energy,energy,106894,"fmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:107279,Energy Efficiency,energy,energy,107279,"ation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Retu",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:107419,Energy Efficiency,energy,energy,107419,"om energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:107583,Energy Efficiency,energy,energy,107583," ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; R",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:110334,Energy Efficiency,adapt,adapted,110334," for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user.; ; infsapt(...); infsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the infinite-order variant of the symmetry adapted perturbation theory code.; ; libfock(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ(",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:113684,Energy Efficiency,adapt,adapted,113684,"pled cluster code.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:105654,Integrability,contract,contracts,105654,"atrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a f",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:1543,Modifiability,inherit,inherited,1543,"sSetParser; CdSalcList; Checkpoint; CorrelationFactor; FittedSlaterCorrelationFactor; DFChargeFitter; Dimension; Dispersion; Environment; ExternalPotential; FittingMetric; Functional; GridProp; IO; IOManager; IntVector; Matrix; MatrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | npri",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:1723,Modifiability,inherit,inherited,1723,"atrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | pr",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:3446,Modifiability,inherit,inherited,3446," | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | add(...); | add( (BasisSet)arg1, (BasisSet)arg2) -> BasisSet :; | Adds two basis sets together.; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be in",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:3626,Modifiability,inherit,inherited,3626,"l_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | add(...); | add( (BasisSet)arg1, (BasisSet)arg2) -> BasisSet :; | Adds two basis sets together.; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:4382,Modifiability,inherit,inherited,4382," here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attri",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:4562,Modifiability,inherit,inherited,4562,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:5460,Modifiability,inherit,inherited,5460,"rom Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:5640,Modifiability,inherit,inherited,5640,"om Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:6949,Modifiability,inherit,inherited,6949,"ata and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:7129,Modifiability,inherit,inherited,7129,"> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and ot",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:7899,Modifiability,inherit,inherited,7899," here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:8079,Modifiability,inherit,inherited,8079,"eakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | -----------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:9227,Modifiability,inherit,inherited,9227,"utes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:9407,Modifiability,inherit,inherited,9407,"der:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | --------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:10160,Modifiability,inherit,inherited,10160," 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:10389,Modifiability,inherit,inherited,10389,"--------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:10524,Modifiability,inherit,inherited,10524,"__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:13203,Modifiability,inherit,inherited,13203,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)ar",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:13591,Modifiability,inherit,inherited,13591," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstrin",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:14884,Modifiability,inherit,inherited,14884,"ype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the literature reference.; | ; | citation(...); | ci",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:15064,Modifiability,inherit,inherited,15064,"; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the literature reference.; | ; | citation(...); | citation( (Dispersion)arg1) -> str :; | docstring; | ; | compute_energy(...); | compute_energy( (Dispersion)arg1, (Molecule)arg2) -> float :; | docstring; | ; | compute_gradient(...); | compute_gradient( (Dispersion)arg1, (Molecule)arg2) -> Matrix :; | docstring; ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:17861,Modifiability,inherit,inherited,17861,"Dispersion)arg1) -> None :; | docstring; | ; | s6(...); | s6( (Dispersion)arg1) -> float :; | docstring; | ; | s8(...); | s8( (Dispersion)arg1) -> float :; | docstring; | ; | set_bibtex(...); | set_bibtex( (Dispersion)arg1, (str)arg2) -> None :; | Set the BibTeX key for the literature reference.; | ; | set_citation(...); | set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | sr6(...); | sr6( (Dispersion)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:18041,Modifiability,inherit,inherited,18041,"set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | sr6(...); | sr6( (Dispersion)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:18834,Modifiability,inherit,inherited,18834,"his class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:19014,Modifiability,inherit,inherited,19014,"---------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:20370,Modifiability,inherit,inherited,20370,"st.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:20550,Modifiability,inherit,inherited,20550,"ion>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Dat",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:21253,Modifiability,inherit,inherited,21253,"ta and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (Fitti",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:21499,Modifiability,inherit,inherited,21499," __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (Fit",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:21679,Modifiability,inherit,inherited,21679,"n method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inve",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:23439,Modifiability,inherit,inherited,23439,"orm_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:23619,Modifiability,inherit,inherited,23619,"; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)arg1) -> bool :; | docstring; | ; | is_lrc(...); | is_lrc( (Functional)arg1) -> bool :; | docstring; | ; | is_meta(...); | is_meta( (Functional)arg1) -> bool :; | docstring; | ; | lsda_cutoff(...); | lsda_cutoff( (Functional)arg1) -> float :; | docstring; | ;",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:26415,Modifiability,inherit,inherited,26415," | ; | set_gga(...); | set_gga( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_lsda_cutoff(...); | set_lsda_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_meta(...); | set_meta( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_meta_cutoff(...); | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:26595,Modifiability,inherit,inherited,26595,"; | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes i",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:27349,Modifiability,inherit,inherited,27349," __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)a",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:27529,Modifiability,inherit,inherited,27529,"ict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_beta_mo(...); | add_beta_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | build_grid_overages(...); | build_grid_overages( (GridProp)arg1, (float)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:29630,Modifiability,inherit,inherited,29630," docstring; | ; | compute(...); | compute( (GridProp)arg1) -> None :; | docstring; | ; | get_l(...); | get_l( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | get_n(...); | get_n( (GridProp)arg1, (int)arg2) -> int :; | docstring; | ; | get_o(...); | get_o( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:29810,Modifiability,inherit,inherited,29810,"op)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:30540,Modifiability,inherit,inherited,30540,"----------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:33220,Modifiability,inherit,inherited,33220,"t(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:33400,Modifiability,inherit,inherited,33400,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | set_pid(...); | set_pid( (IO)arg1, (str)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | toccle",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:35253,Modifiability,inherit,inherited,35253,"(IO)arg1, (int)arg2) -> None :; | docstring; | ; | set_pid(...); | set_pid( (IO)arg1, (str)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | tocclean( (IO)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:35433,Modifiability,inherit,inherited,35433,"g3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (int)arg2) -> str :; | docstring; | ; | mark_file_for_retention(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:37323,Modifiability,inherit,inherited,37323,"tion(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | psiclean(...); | psiclean( (IOManager)arg1) -> None :; | docstring; | ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | ni",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:37503,Modifiability,inherit,inherited,37503," ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:38667,Modifiability,inherit,inherited,38667,"d from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:38847,Modifiability,inherit,inherited,38847,"Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Matrix)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | accumulate_product(...); | accumulate_product( (Matrix)arg1, (Matrix)arg2, (Matri",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:44094,Modifiability,inherit,inherited,44094,")arg2) -> None :; | docstring; | ; | subtract(...); | subtract( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | sum_of_squares(...); | sum_of_squares( (Matrix)arg1) -> float :; | docstring; | ; | symmetry(...); | symmetry( (Matrix)arg1) -> int :; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | -------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:44274,Modifiability,inherit,inherited,44274,"; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:45351,Modifiability,inherit,inherited,45351,"----------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:45531,Modifiability,inherit,inherited,45531,"actory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper)arg1, (float)arg2) -> Matrix :; | docstring; | ; | ao_eri(...); | ao_eri( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_f12(...); | ao_f12( (MintsHelper)arg1, (CorrelationFactor)arg2) -> Matrix :; | docstring; | ; | ao_f12_double_commutator(...);",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:50143,Modifiability,inherit,inherited,50143,"ring; | ; | play(...); | play( (MintsHelper)arg1) -> None :; | docstring; | ; | so_angular_momentum(...); | so_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_dipole(...); | so_dipole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inhe",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:50323,Modifiability,inherit,inherited,50323,"tring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Bo",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:50993,Modifiability,inherit,inherited,50993,"--------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:51173,Modifiability,inherit,inherited,51173,"---------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:55308,Modifiability,variab,variable,55308,"_point_group(...); | find_point_group( (Molecule)arg1, (float)arg2) -> PointGroup :; | Finds computational molecular point group, user can override this with the symmetry keyword; | ; | fix_com(...); | fix_com( (Molecule)arg1, (bool)arg2) -> None :; | Whether to fix the Cartesian position, or to translate to the C.O.M.; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplic",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:55807,Modifiability,variab,variable,55807,"(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion en",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:60986,Modifiability,variab,variable,60986,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:61024,Modifiability,variab,variables,61024,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:61616,Modifiability,variab,variable,61616,"ined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:62506,Modifiability,inherit,inherited,62506,"in the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matr",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:62686,Modifiability,inherit,inherited,62686,"able values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:63442,Modifiability,inherit,inherited,63442,"butes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:63622,Modifiability,inherit,inherited,63622,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:64283,Modifiability,inherit,inherited,64283,"function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:64463,Modifiability,inherit,inherited,64463,"------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inh",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:65395,Modifiability,inherit,inherited,65395,"-------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __in",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:65575,Modifiability,inherit,inherited,65575,"_new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Wavefunction)arg4) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimens",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:67428,Modifiability,inherit,inherited,67428,"nnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimension :; | docstring; | ; | evals(...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and othe",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:67608,Modifiability,inherit,inherited,67608,"...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:68585,Modifiability,inherit,inherited,68585,"---------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | -----------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:68765,Modifiability,inherit,inherited,68765,"thon.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:69600,Modifiability,inherit,inherited,69600,"be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:69780,Modifiability,inherit,inherited,69780,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:70603,Modifiability,inherit,inherited,70603,"------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (P",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:70783,Modifiability,inherit,inherited,70783,"---------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes define",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:71854,Modifiability,inherit,inherited,71854,"-----------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiRe",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:72034,Modifiability,inherit,inherited,72034,"seudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__()",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:72851,Modifiability,inherit,inherited,72851,"-----------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:73080,Modifiability,inherit,inherited,73080,"tes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:73215,Modifiability,inherit,inherited,73215,"bject with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:75894,Modifiability,inherit,inherited,75894,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an ex",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:76282,Modifiability,inherit,inherited,76282," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...);",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:77004,Modifiability,inherit,inherited,77004,"---------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:79684,Modifiability,inherit,inherited,79684,"t(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:79864,Modifiability,inherit,inherited,79864,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:80699,Modifiability,inherit,inherited,80699," | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> N",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:80879,Modifiability,inherit,inherited,80879,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunct",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:85712,Modifiability,inherit,inherited,85712,"ctional)arg1, (float)arg2) -> None :; | docstring; | ; | test_functional(...); | test_functional( (SuperFunctional)arg1, (Vector)arg2, (Vector)arg3, (Vector)arg4, (Vector)arg5, (Vector)arg6, (Vector)arg7, (Vector)arg8) -> None :; | docstring; | ; | value(...); | value( (SuperFunctional)arg1, (str)arg2) -> Vector :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:85892,Modifiability,inherit,inherited,85892,"r :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_x(...); | c2_x( (SymmetryOperation)arg1) -> None :; | docstring; | ; | c2_y(...); | c2_y( (SymmetryOperation)arg1) -> None :; | docstring; | ; | i(...); | i( (SymmetryOperation)arg1) -> None :; | docstring; | ; | operate(...); | operate( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; |",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:87960,Modifiability,inherit,inherited,87960,"ration :; | docstring; | ; | rotate_n(...); | rotate_n( (SymmetryOperation)arg1, (int)arg2) -> None :; | docstring; | ; | rotate_theta(...); | rotate_theta( (SymmetryOperation)arg1, (float)arg2) -> None :; | docstring; | ; | sigma_xy(...); | sigma_xy( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:88140,Modifiability,inherit,inherited,88140,"tryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(.",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:89843,Modifiability,inherit,inherited,89843," __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | Returns the arg2-th element of arg1.; | ;",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:90023,Modifiability,inherit,inherited,90023,"float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | Returns the arg2-th element of arg1.; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1, (float)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:92223,Modifiability,inherit,inherited,92223,"__( (object)arg1, (Vector3)arg2) -> object; | ; | __neg__(...); | __neg__( (Vector3)arg1) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __str__(...); | __str__( (Vector3)arg1) -> str :; | Returns a string representation of arg1, suitable for printing.; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | Returns cross product of arg1 and arg2; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns distance between two points represented by arg1 and arg2; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:92403,Modifiability,inherit,inherited,92403,"ing.; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | Returns cross product of arg1 and arg2; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns distance between two points represented by arg1 and arg2; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data a",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:93178,Modifiability,inherit,inherited,93178,"----------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <u",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:93358,Modifiability,inherit,inherited,93358,"f__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | do",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:96663,Modifiability,inherit,inherited,96663,"> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:96843,Modifiability,inherit,inherited,96843,"> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; |",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:97856,Modifiability,extend,extend,97856,"her attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vecto",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:97871,Modifiability,extend,extend,97871,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:98171,Modifiability,inherit,inherited,98171,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:98351,Modifiability,inherit,inherited,98351,"l; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (int)arg5, (int)arg6, (float)arg7, (Matrix)arg8, (int)arg9, (Vector)arg10, (int)arg11, (float)arg12, (Vector)arg13, (int)arg14) -> None :; docstring; ; DGEEV(...); DGEEV( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (Matrix)arg5, (int)arg",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:105792,Modifiability,config,configuration,105792," -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1)",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:106085,Modifiability,adapt,adapted,106085,"equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fo",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:109074,Modifiability,variab,variables,109074,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:109163,Modifiability,variab,variables,109163,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:110334,Modifiability,adapt,adapted,110334," for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user.; ; infsapt(...); infsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the infinite-order variant of the symmetry adapted perturbation theory code.; ; libfock(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ(",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:111601,Modifiability,plugin,plugin,111601,"in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the so",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:111614,Modifiability,plugin,plugin,111614,"..); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:112481,Modifiability,variab,variables,112481,"imization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() -> float :; Runs the multireference coupled cluster code.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an optio",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:113684,Modifiability,adapt,adapted,113684,"pled cluster code.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:115874,Modifiability,variab,variable,115874,"only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi.; ; wavefunction(...); wavefunction() -> Wavefunction :; Returns the current wavefunction object from the most recent computation. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigatio",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:41246,Performance,load,load,41246,"Matrix)arg3]) -> Matrix; | ; | cholesky_factorize(...); | cholesky_factorize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> i",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:41259,Performance,load,load,41259,"rize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bo",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:111316,Performance,optimiz,optimized,111316,"der variant of the symmetry adapted perturbation theory code.; ; libfock(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:111392,Performance,optimiz,optimizer,111392,"libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like not",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:111474,Performance,optimiz,optimization,111474,"oat :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints ",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:11180,Security,hash,hash,11180,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:73871,Security,hash,hash,73871,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:19749,Usability,clear,clear,19749,"defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new o",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod-1.html:19763,Usability,clear,clear,19763,"----------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | M",MatchSource.WIKI,psi4manual/4.0b4/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html
https://psicode.org/psi4manual/4.0b4/psimod.html:51813,Availability,fault,faulty,51813,"on>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (opt",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:52976,Availability,toler,tolerance,52976," Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real an",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:55558,Availability,checkpoint,checkpoint,55558,"; | fix_com(...); | fix_com( (Molecule)arg1, (bool)arg2) -> None :; | Whether to fix the Cartesian position, or to translate to the C.O.M.; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:55674,Availability,checkpoint,checkpoint,55674,"rientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fr",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:58681,Availability,checkpoint,checkpoint,58681,"_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_atoms( (Molecule)arg1, (str)arg2, (str)arg3) -> None :; | Sets basis set arg2 to all atoms; | ; | set_basis_by_label(...); | set_basis_by_label( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with label (e.g., H4) arg2; | ; | set_basis_by_number(...); | set_basis_by_number( (Molecule)arg1, (int)arg2, (str)arg3, (str)arg4) -> None",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:61335,Availability,toler,tolerance,61335,"ets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | --------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:107890,Availability,error,error,107890,"ints, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns err",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:108475,Availability,error,error,108475," output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope b",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:108598,Availability,avail,available,108598,"nergy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)a",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:108900,Availability,error,error,108900,"ption_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Ret",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:109173,Availability,avail,available,109173,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:115437,Availability,avail,available,115437,"2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradient to the values stored in the N by 3 Matrix argument.; ; set_local_option(...); set_local_option( (str)arg1, (str)arg2, (str)arg3) -> bool :; Sets a string option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi.; ; wavefunction(...); wavefunction() -> Wavefunction :; Returns the current wavefunction object from the most recent com",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:105792,Deployability,configurat,configuration,105792," -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1)",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:116967,Deployability,update,updated,116967,"r)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi.; ; wavefunction(...); wavefunction() -> Wavefunction :; Returns the current wavefunction object from the most recent computation. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:31667,Energy Efficiency,energy,energy,31667,"| ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:31682,Energy Efficiency,energy,energy,31682,"..); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:41666,Energy Efficiency,power,power,41666,"-> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (floa",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:41680,Energy Efficiency,power,power,41680,"ocstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | set(...); | set( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) ->",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:51469,Energy Efficiency,charge,charge,51469,".__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:51979,Energy Efficiency,charge,charge,51979,"ost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_ma",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:52760,Energy Efficiency,charge,charge,52760,"a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | ext",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:53142,Energy Efficiency,charge,charge,53142,"molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 f",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:53157,Energy Efficiency,charge,charge,53157," function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | Returns copy of arg1 with arg2",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:53211,Energy Efficiency,charge,charge,53211," function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | Tests to see if an atom is at the position arg2 with a given tolerance arg3; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | Computes center of mass of molecule (does not translate molecule); | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | Gets charge of atom; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | Returns a new Molecule identical to arg1; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be inactive; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | Returns copy of arg1 with arg2",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:56211,Energy Efficiency,charge,charge,56211,"up name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cart",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:56817,Energy Efficiency,energy,energy,56817," bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion energy; | ; | point_group(...); | point_group( (Molecule)arg1) -> PointGroup :; | Returns the current point group object; | ; | print_in_input_format(...); | print_in_input_format( (Molecule)arg1) -> None :; | Prints the molecule as Cartesian or ZMatrix entries, just as inputted.; | ; | print_out(...); | print_out( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in input units; | ; | print_out_in_angstrom(...); | print_out_in_angstrom( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | ru",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:58218,Energy Efficiency,energy,energy,58218,"Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:58289,Energy Efficiency,energy,energy,58289,"Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Angstroms; | ; | print_out_in_bohr(...); | print_out_in_bohr( (Molecule)arg1) -> None :; | Prints the molecule in Cartesians in Bohr; | ; | reinterpret_coordentry(...); | reinterpret_coordentry( (Molecule)arg1, (bool)arg2) -> None :; | Do reinterpret coordinate entries during update_geometry().; | ; | reset_point_group(...); | reset_point_group( (Molecule)arg1, (str)arg2) -> None :; | Overrides symmetry from outside the molecule string; | ; | run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None); | Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); | to compute the -D correction of level *dashlvl* using parameters for; | the functional *func*. The dictionary *dashparam* can be used to supply; | a full set of dispersion parameters in the absense of *func* or to supply; | individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; | gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; | unspecified. The dftd3 executable must be independently compiled and found in ; | :envvar:`PATH`.; | ; | save_string_xyz(...); | save_string_xyz( (Molecule)arg1) -> str :; | Saves the string of an XYZ file to arg2; | ; | save_to_checkpoint(...); | save_to_checkpoint( (Molecule)arg1, (Checkpoint)arg2, (str)arg3) -> None :; | Saves molecule information to checkpoint file arg2 with prefix arg3; | ; | save_xyz(...); | save_xyz( (Molecule)arg1, (str)arg2) -> None :; | Saves an XYZ file to arg2; | ; | schoenflies_symbol(...); | schoenflies_symbol( (Molecule)arg1) -> str :; | Returns the Schoenflies symbol; | ; | set_active_fragment(...); | set_active_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Real; | ; | set_active_fragments(...); | set_active_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Real; | ; | set_basis_all_atoms(...); | set_basis_all_",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:60471,Energy Efficiency,charge,charge,60471," (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with label (e.g., H4) arg2; | ; | set_basis_by_number(...); | set_basis_by_number( (Molecule)arg1, (int)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to atom number (1-indexed, incl. dummies) arg2; | ; | set_basis_by_symbol(...); | set_basis_by_symbol( (Molecule)arg1, (str)arg2, (str)arg3, (str)arg4) -> None :; | Sets basis set arg3 to all atoms with symbol (e.g., H) arg2; | ; | set_geometry(...); | set_geometry( (Molecule)arg1, (Matrix)arg2) -> None :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1,",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:78131,Energy Efficiency,energy,energy,78131,"| ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:78146,Energy Efficiency,energy,energy,78146,"..); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:81534,Energy Efficiency,allocate,allocate,81534,"nit__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunc",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:81551,Energy Efficiency,allocate,allocate,81551,"ated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_os_alpha(...); | c_os_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_ss_alpha(...); | c_ss_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1)",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:94870,Energy Efficiency,energy,energy,94870,"ocstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavef",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:94885,Energy Efficiency,energy,energy,94885,"| ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | doccpi(...); | doccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frzcpi(...); | frzcpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | frzvpi(...); | frzvpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:104747,Energy Efficiency,energy,energy,104747,"nt)arg9) -> None :; docstring; ; IDAMAX(...); IDAMAX( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> int :; docstring; ; adc(...); adc() -> float :; Runs the ADC propagator code, for excited states.; ; add_user_basis_file(...); add_user_basis_file( (str)arg1) -> None :; Adds a custom basis set file, provided by the user.; ; benchmark_blas1(...); benchmark_blas1( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas2(...); benchmark_blas2( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_blas3(...); benchmark_blas3( (int)arg1, (float)arg2, (int)arg3) -> None :; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:105334,Energy Efficiency,energy,energy,105334,":; docstring; ; benchmark_disk(...); benchmark_disk( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_integrals(...); benchmark_integrals( (int)arg1, (float)arg2) -> None :; docstring; ; benchmark_math(...); benchmark_math( (float)arg1) -> None :; docstring; ; ccdensity(...); ccdensity() -> float :; Runs the code to compute coupled cluster density matrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnT",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:106085,Energy Efficiency,adapt,adapted,106085,"equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fo",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:106231,Energy Efficiency,energy,energy,106231,"ns CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:106376,Energy Efficiency,energy,energy,106376,"nergy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:106716,Energy Efficiency,energy,energy,106716,"acts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :;",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:106894,Energy Efficiency,energy,energy,106894,"fmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:107279,Energy Efficiency,energy,energy,107279,"ation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Retu",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:107419,Energy Efficiency,energy,energy,107419,"om energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:107583,Energy Efficiency,energy,energy,107583," ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized.; ; get_global_option_list(...); get_global_option_list() -> list :; Returns a list of all global options.; ; get_gradient(...); get_gradient() -> Matrix :; Returns the most recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; R",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:110334,Energy Efficiency,adapt,adapted,110334," for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user.; ; infsapt(...); infsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the infinite-order variant of the symmetry adapted perturbation theory code.; ; libfock(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ(",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:113684,Energy Efficiency,adapt,adapted,113684,"pled cluster code.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:105654,Integrability,contract,contracts,105654,"atrices.; ; ccenergy(...); ccenergy() -> float :; Runs the coupled cluster energy code.; ; cceom(...); cceom() -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a f",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:1543,Modifiability,inherit,inherited,1543,"sSetParser; CdSalcList; Checkpoint; CorrelationFactor; FittedSlaterCorrelationFactor; DFChargeFitter; Dimension; Dispersion; Environment; ExternalPotential; FittingMetric; Functional; GridProp; IO; IOManager; IntVector; Matrix; MatrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | npri",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:1723,Modifiability,inherit,inherited,1723,"atrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | has_puream(...); | has_puream( (BasisSet)arg1) -> bool :; | docstring; | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | pr",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:3446,Modifiability,inherit,inherited,3446," | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | add(...); | add( (BasisSet)arg1, (BasisSet)arg2) -> BasisSet :; | Adds two basis sets together.; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be in",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:3626,Modifiability,inherit,inherited,3626,"l_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | add(...); | add( (BasisSet)arg1, (BasisSet)arg2) -> BasisSet :; | Adds two basis sets together.; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:4382,Modifiability,inherit,inherited,4382," here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attri",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:4562,Modifiability,inherit,inherited,4562,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:5460,Modifiability,inherit,inherited,5460,"rom Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:5640,Modifiability,inherit,inherited,5640,"om Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:6949,Modifiability,inherit,inherited,6949,"ata and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:7129,Modifiability,inherit,inherited,7129,"> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and ot",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:7899,Modifiability,inherit,inherited,7899," here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:8079,Modifiability,inherit,inherited,8079,"eakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CorrelationFactor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (Vector)arg2, (Vector)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | -----------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:9227,Modifiability,inherit,inherited,9227,"utes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:9407,Modifiability,inherit,inherited,9407,"der:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | --------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:10160,Modifiability,inherit,inherited,10160," 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:10389,Modifiability,inherit,inherited,10389,"--------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:10524,Modifiability,inherit,inherited,10524,"__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:13203,Modifiability,inherit,inherited,13203,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)ar",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:13591,Modifiability,inherit,inherited,13591," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstrin",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:14884,Modifiability,inherit,inherited,14884,"ype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the literature reference.; | ; | citation(...); | ci",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:15064,Modifiability,inherit,inherited,15064,"; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the literature reference.; | ; | citation(...); | citation( (Dispersion)arg1) -> str :; | docstring; | ; | compute_energy(...); | compute_energy( (Dispersion)arg1, (Molecule)arg2) -> float :; | docstring; | ; | compute_gradient(...); | compute_gradient( (Dispersion)arg1, (Molecule)arg2) -> Matrix :; | docstring; ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:17861,Modifiability,inherit,inherited,17861,"Dispersion)arg1) -> None :; | docstring; | ; | s6(...); | s6( (Dispersion)arg1) -> float :; | docstring; | ; | s8(...); | s8( (Dispersion)arg1) -> float :; | docstring; | ; | set_bibtex(...); | set_bibtex( (Dispersion)arg1, (str)arg2) -> None :; | Set the BibTeX key for the literature reference.; | ; | set_citation(...); | set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | sr6(...); | sr6( (Dispersion)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:18041,Modifiability,inherit,inherited,18041,"set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | sr6(...); | sr6( (Dispersion)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:18834,Modifiability,inherit,inherited,18834,"his class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:19014,Modifiability,inherit,inherited,19014,"---------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:20370,Modifiability,inherit,inherited,20370,"st.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:20550,Modifiability,inherit,inherited,20550,"ion>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Dat",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:21253,Modifiability,inherit,inherited,21253,"ta and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (Fitti",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:21499,Modifiability,inherit,inherited,21499," __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (Fit",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:21679,Modifiability,inherit,inherited,21679,"n method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inve",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:23439,Modifiability,inherit,inherited,23439,"orm_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:23619,Modifiability,inherit,inherited,23619,"; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)arg1) -> bool :; | docstring; | ; | is_lrc(...); | is_lrc( (Functional)arg1) -> bool :; | docstring; | ; | is_meta(...); | is_meta( (Functional)arg1) -> bool :; | docstring; | ; | lsda_cutoff(...); | lsda_cutoff( (Functional)arg1) -> float :; | docstring; | ;",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:26415,Modifiability,inherit,inherited,26415," | ; | set_gga(...); | set_gga( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_lsda_cutoff(...); | set_lsda_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_meta(...); | set_meta( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_meta_cutoff(...); | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:26595,Modifiability,inherit,inherited,26595,"; | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes i",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:27349,Modifiability,inherit,inherited,27349," __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)a",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:27529,Modifiability,inherit,inherited,27529,"ict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_beta_mo(...); | add_beta_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | build_grid_overages(...); | build_grid_overages( (GridProp)arg1, (float)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:29630,Modifiability,inherit,inherited,29630," docstring; | ; | compute(...); | compute( (GridProp)arg1) -> None :; | docstring; | ; | get_l(...); | get_l( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | get_n(...); | get_n( (GridProp)arg1, (int)arg2) -> int :; | docstring; | ; | get_o(...); | get_o( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:29810,Modifiability,inherit,inherited,29810,"op)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:30540,Modifiability,inherit,inherited,30540,"----------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:33220,Modifiability,inherit,inherited,33220,"t(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:33400,Modifiability,inherit,inherited,33400,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | set_pid(...); | set_pid( (IO)arg1, (str)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | toccle",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:35253,Modifiability,inherit,inherited,35253,"(IO)arg1, (int)arg2) -> None :; | docstring; | ; | set_pid(...); | set_pid( (IO)arg1, (str)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | tocclean( (IO)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:35433,Modifiability,inherit,inherited,35433,"g3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (int)arg2) -> str :; | docstring; | ; | mark_file_for_retention(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:37323,Modifiability,inherit,inherited,37323,"tion(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | psiclean(...); | psiclean( (IOManager)arg1) -> None :; | docstring; | ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | ni",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:37503,Modifiability,inherit,inherited,37503," ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:38667,Modifiability,inherit,inherited,38667,"d from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:38847,Modifiability,inherit,inherited,38847,"Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Matrix)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | accumulate_product(...); | accumulate_product( (Matrix)arg1, (Matrix)arg2, (Matri",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:44094,Modifiability,inherit,inherited,44094,")arg2) -> None :; | docstring; | ; | subtract(...); | subtract( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | sum_of_squares(...); | sum_of_squares( (Matrix)arg1) -> float :; | docstring; | ; | symmetry(...); | symmetry( (Matrix)arg1) -> int :; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | -------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:44274,Modifiability,inherit,inherited,44274,"; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:45351,Modifiability,inherit,inherited,45351,"----------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:45531,Modifiability,inherit,inherited,45531,"actory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper)arg1, (float)arg2) -> Matrix :; | docstring; | ; | ao_eri(...); | ao_eri( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_f12(...); | ao_f12( (MintsHelper)arg1, (CorrelationFactor)arg2) -> Matrix :; | docstring; | ; | ao_f12_double_commutator(...);",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:50143,Modifiability,inherit,inherited,50143,"ring; | ; | play(...); | play( (MintsHelper)arg1) -> None :; | docstring; | ; | so_angular_momentum(...); | so_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_dipole(...); | so_dipole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inhe",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:50323,Modifiability,inherit,inherited,50323,"tring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Bo",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:50993,Modifiability,inherit,inherited,50993,"--------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:51173,Modifiability,inherit,inherited,51173,"---------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:55308,Modifiability,variab,variable,55308,"_point_group(...); | find_point_group( (Molecule)arg1, (float)arg2) -> PointGroup :; | Finds computational molecular point group, user can override this with the symmetry keyword; | ; | fix_com(...); | fix_com( (Molecule)arg1, (bool)arg2) -> None :; | Whether to fix the Cartesian position, or to translate to the C.O.M.; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplic",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:55807,Modifiability,variab,variable,55807,"(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | init_with_checkpoint(...); | init_with_checkpoint( (Molecule)arg1, (Checkpoint)arg2) -> None :; | Populate arg1 member data with information from checkpoint file arg2; | ; | init_with_io(...); | init_with_io( (Molecule)arg1, (IO)arg2) -> None :; | Creates a new checkpoint file with information from arg2; | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | name(...); | name( (Molecule)arg1) -> str :; | Gets molecule name; | ; | natom(...); | natom( (Molecule)arg1) -> int :; | Number of real atoms; | ; | nfragments(...); | nfragments( (Molecule)arg1) -> int :; | Gets the number of fragments in the molecule; | ; | nuclear_repulsion_energy(...); | nuclear_repulsion_energy( (Molecule)arg1) -> float :; | Computes nuclear repulsion en",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:60986,Modifiability,variab,variable,60986,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:61024,Modifiability,variab,variables,61024,"e :; | Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr); | ; | set_ghost_fragment(...); | set_ghost_fragment( (Molecule)arg1, (int)arg2) -> None :; | Sets the specified fragment arg2 to be Ghost; | ; | set_ghost_fragments(...); | set_ghost_fragments( (Molecule)arg1, (list)arg2) -> None :; | Sets the specified list arg2 of fragments to be Ghost; | ; | set_molecular_charge(...); | set_molecular_charge( (Molecule)arg1, (int)arg2) -> None :; | Sets the molecular charge; | ; | set_multiplicity(...); | set_multiplicity( (Molecule)arg1, (int)arg2) -> None :; | Sets the multiplicity (defined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:61616,Modifiability,variab,variable,61616,"ined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:62506,Modifiability,inherit,inherited,62506,"in the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matr",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:62686,Modifiability,inherit,inherited,62686,"able values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:63442,Modifiability,inherit,inherited,63442,"butes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:63622,Modifiability,inherit,inherited,63622,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:64283,Modifiability,inherit,inherited,64283,"function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:64463,Modifiability,inherit,inherited,64463,"------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inh",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:65395,Modifiability,inherit,inherited,65395,"-------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __in",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:65575,Modifiability,inherit,inherited,65575,"_new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Wavefunction)arg4) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimens",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:67428,Modifiability,inherit,inherited,67428,"nnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimension :; | docstring; | ; | evals(...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and othe",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:67608,Modifiability,inherit,inherited,67608,"...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:68585,Modifiability,inherit,inherited,68585,"---------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | -----------------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:68765,Modifiability,inherit,inherited,68765,"thon.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:69600,Modifiability,inherit,inherited,69600,"be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:69780,Modifiability,inherit,inherited,69780,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:70603,Modifiability,inherit,inherited,70603,"------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (P",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:70783,Modifiability,inherit,inherited,70783,"---------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes define",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:71854,Modifiability,inherit,inherited,71854,"-----------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiRe",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:72034,Modifiability,inherit,inherited,72034,"seudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__()",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:72851,Modifiability,inherit,inherited,72851,"-----------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:73080,Modifiability,inherit,inherited,73080,"tes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:73215,Modifiability,inherit,inherited,73215,"bject with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:75894,Modifiability,inherit,inherited,75894,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an ex",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:76282,Modifiability,inherit,inherited,76282," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...);",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:77004,Modifiability,inherit,inherited,77004,"---------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:79684,Modifiability,inherit,inherited,79684,"t(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:79864,Modifiability,inherit,inherited,79864,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:80699,Modifiability,inherit,inherited,80699," | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> N",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:80879,Modifiability,inherit,inherited,80879,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunct",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:85712,Modifiability,inherit,inherited,85712,"ctional)arg1, (float)arg2) -> None :; | docstring; | ; | test_functional(...); | test_functional( (SuperFunctional)arg1, (Vector)arg2, (Vector)arg3, (Vector)arg4, (Vector)arg5, (Vector)arg6, (Vector)arg7, (Vector)arg8) -> None :; | docstring; | ; | value(...); | value( (SuperFunctional)arg1, (str)arg2) -> Vector :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:85892,Modifiability,inherit,inherited,85892,"r :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_x(...); | c2_x( (SymmetryOperation)arg1) -> None :; | docstring; | ; | c2_y(...); | c2_y( (SymmetryOperation)arg1) -> None :; | docstring; | ; | i(...); | i( (SymmetryOperation)arg1) -> None :; | docstring; | ; | operate(...); | operate( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; |",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:87960,Modifiability,inherit,inherited,87960,"ration :; | docstring; | ; | rotate_n(...); | rotate_n( (SymmetryOperation)arg1, (int)arg2) -> None :; | docstring; | ; | rotate_theta(...); | rotate_theta( (SymmetryOperation)arg1, (float)arg2) -> None :; | docstring; | ; | sigma_xy(...); | sigma_xy( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:88140,Modifiability,inherit,inherited,88140,"tryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(.",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:89843,Modifiability,inherit,inherited,89843," __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | Returns the arg2-th element of arg1.; | ;",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:90023,Modifiability,inherit,inherited,90023,"float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | Returns the arg2-th element of arg1.; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1, (float)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:92223,Modifiability,inherit,inherited,92223,"__( (object)arg1, (Vector3)arg2) -> object; | ; | __neg__(...); | __neg__( (Vector3)arg1) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __str__(...); | __str__( (Vector3)arg1) -> str :; | Returns a string representation of arg1, suitable for printing.; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | Returns cross product of arg1 and arg2; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns distance between two points represented by arg1 and arg2; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:92403,Modifiability,inherit,inherited,92403,"ing.; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | Returns cross product of arg1 and arg2; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns distance between two points represented by arg1 and arg2; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data a",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:93178,Modifiability,inherit,inherited,93178,"----------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <u",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:93358,Modifiability,inherit,inherited,93358,"f__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | do",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:96663,Modifiability,inherit,inherited,96663,"> Molecule :; | docstring; | ; | nalpha(...); | nalpha( (Wavefunction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:96843,Modifiability,inherit,inherited,96843,"> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; |",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:97856,Modifiability,extend,extend,97856,"her attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vecto",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:97871,Modifiability,extend,extend,97871,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:98171,Modifiability,inherit,inherited,98171,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:98351,Modifiability,inherit,inherited,98351,"l; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (int)arg5, (int)arg6, (float)arg7, (Matrix)arg8, (int)arg9, (Vector)arg10, (int)arg11, (float)arg12, (Vector)arg13, (int)arg14) -> None :; docstring; ; DGEEV(...); DGEEV( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (Matrix)arg5, (int)arg",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:105792,Modifiability,config,configuration,105792," -> float :; Runs the equation of motion coupled cluster code, for excited states.; ; cchbar(...); cchbar() -> float :; Runs the code to generate the similariry transformed Hamiltonian.; ; cclambda(...); cclambda() -> float :; Runs the coupled cluster lambda equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1)",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:106085,Modifiability,adapt,adapted,106085,"equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fo",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:109074,Modifiability,variab,variables,109074,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:109163,Modifiability,variab,variables,109163,"t recently computed gradient, as a N by 3 Matrix object.; ; get_input_directory(...); get_input_directory() -> str :; Returns the location of the input file.; ; get_local_option(...); get_local_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name and a particular module, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is wri",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:110334,Modifiability,adapt,adapted,110334," for whether the option has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched in the scope of the specified module, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user.; ; has_option_changed(...); has_option_changed( (str)arg1, (str)arg2) -> bool :; Returns boolean for whether the option has been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user.; ; infsapt(...); infsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the infinite-order variant of the symmetry adapted perturbation theory code.; ; libfock(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ(",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:111601,Modifiability,plugin,plugin,111601,"in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the so",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:111614,Modifiability,plugin,plugin,111614,"..); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:112481,Modifiability,variab,variables,112481,"imization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() -> float :; Runs the multireference coupled cluster code.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an optio",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:113684,Modifiability,adapt,adapted,113684,"pled cluster code.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:115874,Modifiability,variab,variable,115874,"only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi.; ; wavefunction(...); wavefunction() -> Wavefunction :; Returns the current wavefunction object from the most recent computation. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigatio",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:41246,Performance,load,load,41246,"Matrix)arg3]) -> Matrix; | ; | cholesky_factorize(...); | cholesky_factorize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> i",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:41259,Performance,load,load,41259,"rize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bo",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:111316,Performance,optimiz,optimized,111316,"der variant of the symmetry adapted perturbation theory code.; ; libfock(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:111392,Performance,optimiz,optimizer,111392,"libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like not",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:111474,Performance,optimiz,optimization,111474,"oat :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints ",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:11180,Security,hash,hash,11180,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:73871,Security,hash,hash,73871,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:19749,Usability,clear,clear,19749,"defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new o",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimod.html:19763,Usability,clear,clear,19763,"----------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | M",MatchSource.WIKI,psi4manual/4.0b4/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:4852,Availability,avail,available,4852,"f the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires that four arrays be specified; for this purpose. Frozen doubly occupied orbitals (FROZEN_DOCC) are doubly; occupied in each reference determinant and are not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in; al",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2084,Deployability,configurat,configuration,2084,"C effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2704,Deployability,configurat,configuration,2704,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2797,Deployability,configurat,configuration,2797,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:7437,Deployability,update,updated,7437,"OZEN_DOCC) are doubly; occupied in each reference determinant and are not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in; all reference determinants and are excluded from the correlated wave; function. The model space is selected by considering all possible occupations; of the electrons among the orbitals in the active space that result; in determinants with the correct symmetry (WFN_SYM); and the correct value specified by the keyword; CORR_MULTP. Note that this does not consider the multiplicity; of the wavefunction. Thus, in order to obtain the wavefunction; with a set of reference determinants for; an open-shell system you should request a CORR_MULTP of; 1 within the PSIMRCC module, and select the root of the effective; Hamiltonian that corresponds to the state of interest. In addition,; the WFN_SYM keyword needs to be specified otherwise the; wavefunction belonging to the all-symmetric irrep will be selected. In; addition, it should be noted that for an open-shell singlet based; on two determinants the eigenvector is; [], which corresponds; to a wavefunction of the following form:. See Appendix PSIMRCC for a complete list of PSIMRCC options. Table Of Contents. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Previous topic; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:759,Energy Efficiency,power,powerful,759,"﻿. PSIMRCC Implementation of Mk-MRCC Theory — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». PSIMRCC Implementation of Mk-MRCC Theory¶; Code author: Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, . where are the reference determinants,; are reference-specific excitation operators, and; are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:1330,Energy Efficiency,energy,energy,1330,"SI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, . where are the reference determinants,; are reference-specific excitation operators, and; are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approx",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2636,Energy Efficiency,energy,energy,2636,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:3873,Energy Efficiency,energy,energy,3873,"MRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are availa",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:4076,Energy Efficiency,energy,energy,4076,"obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:4655,Energy Efficiency,energy,energy,4655,"the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires th",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:1278,Integrability,contract,contracted,1278," Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, . where are the reference determinants,; are reference-specific excitation operators, and; are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the cod",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2084,Modifiability,config,configuration,2084,"C effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2704,Modifiability,config,configuration,2704,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2797,Modifiability,config,configuration,2797,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2428,Performance,perform,perform,2428,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2444,Performance,optimiz,optimization,2444,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:2596,Performance,optimiz,optimized,2596,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc-1.html:3323,Performance,perform,performing,3323,"ll be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc-1.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:4852,Availability,avail,available,4852,"f the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires that four arrays be specified; for this purpose. Frozen doubly occupied orbitals (FROZEN_DOCC) are doubly; occupied in each reference determinant and are not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in; al",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2084,Deployability,configurat,configuration,2084,"C effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2704,Deployability,configurat,configuration,2704,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2797,Deployability,configurat,configuration,2797,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:7437,Deployability,update,updated,7437,"OZEN_DOCC) are doubly; occupied in each reference determinant and are not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in; all reference determinants and are excluded from the correlated wave; function. The model space is selected by considering all possible occupations; of the electrons among the orbitals in the active space that result; in determinants with the correct symmetry (WFN_SYM); and the correct value specified by the keyword; CORR_MULTP. Note that this does not consider the multiplicity; of the wavefunction. Thus, in order to obtain the wavefunction; with a set of reference determinants for; an open-shell system you should request a CORR_MULTP of; 1 within the PSIMRCC module, and select the root of the effective; Hamiltonian that corresponds to the state of interest. In addition,; the WFN_SYM keyword needs to be specified otherwise the; wavefunction belonging to the all-symmetric irrep will be selected. In; addition, it should be noted that for an open-shell singlet based; on two determinants the eigenvector is; [], which corresponds; to a wavefunction of the following form:. See Appendix PSIMRCC for a complete list of PSIMRCC options. Table Of Contents. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Previous topic; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:759,Energy Efficiency,power,powerful,759,"﻿. PSIMRCC Implementation of Mk-MRCC Theory — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». PSIMRCC Implementation of Mk-MRCC Theory¶; Code author: Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, . where are the reference determinants,; are reference-specific excitation operators, and; are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:1330,Energy Efficiency,energy,energy,1330,"SI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, . where are the reference determinants,; are reference-specific excitation operators, and; are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approx",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2636,Energy Efficiency,energy,energy,2636,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:3873,Energy Efficiency,energy,energy,3873,"MRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are availa",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:4076,Energy Efficiency,energy,energy,4076,"obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:4655,Energy Efficiency,energy,energy,4655,"the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires th",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:1278,Integrability,contract,contracted,1278," Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, . where are the reference determinants,; are reference-specific excitation operators, and; are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the cod",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2084,Modifiability,config,configuration,2084,"C effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,. where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2704,Modifiability,config,configuration,2704,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2797,Modifiability,config,configuration,2797,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2428,Performance,perform,perform,2428,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2444,Performance,optimiz,optimization,2444,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:2596,Performance,optimiz,optimized,2596,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psimrcc.html:3323,Performance,perform,performing,3323,"ll be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc ",MatchSource.WIKI,psi4manual/4.0b4/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimrcc.html
https://psicode.org/psi4manual/4.0b4/psipep-1.html:631,Deployability,update,updated,631,"﻿. PsiPEP: Plans and Practices to Organize PSI4 — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». PsiPEP: Plans and Practices to Organize PSI4¶. PEP1: Proposing PsiPEP for PSI4. Previous topic; Documentation; Next topic; PEP1: Proposing PsiPEP for PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 06, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psipep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psipep-1.html
https://psicode.org/psi4manual/4.0b4/psipep.html:631,Deployability,update,updated,631,"﻿. PsiPEP: Plans and Practices to Organize PSI4 — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». PsiPEP: Plans and Practices to Organize PSI4¶. PEP1: Proposing PsiPEP for PSI4. Previous topic; Documentation; Next topic; PEP1: Proposing PsiPEP for PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 06, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psipep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psipep.html
https://psicode.org/psi4manual/4.0b4/psithonfunc-1.html:1268,Deployability,update,updated,1268,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Spectroscopic Constants for Diatomics; Function Intercalls. Previous topic; Interface to Molden; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithonfunc-1.html
https://psicode.org/psi4manual/4.0b4/psithonfunc-1.html:581,Energy Efficiency,efficient,efficient,581,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Spectroscopic Constants for Diatomics; Function Intercalls. Previous topic; Interface to Molden; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithonfunc-1.html
https://psicode.org/psi4manual/4.0b4/psithonfunc-1.html:249,Performance,perform,performed,249,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Spectroscopic Constants for Diatomics; Function Intercalls. Previous topic; Interface to Molden; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithonfunc-1.html
https://psicode.org/psi4manual/4.0b4/psithonfunc.html:1268,Deployability,update,updated,1268,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Spectroscopic Constants for Diatomics; Function Intercalls. Previous topic; Interface to Molden; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithonfunc.html
https://psicode.org/psi4manual/4.0b4/psithonfunc.html:581,Energy Efficiency,efficient,efficient,581,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Spectroscopic Constants for Diatomics; Function Intercalls. Previous topic; Interface to Molden; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithonfunc.html
https://psicode.org/psi4manual/4.0b4/psithonfunc.html:249,Performance,perform,performed,249,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Spectroscopic Constants for Diatomics; Function Intercalls. Previous topic; Interface to Molden; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithonfunc.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:1335,Availability,avail,available,1335,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:1739,Availability,avail,available,1739," the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:15023,Availability,reliab,reliable,15023,"For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.90",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:21849,Availability,avail,available,21849,"etrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Va",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:21960,Availability,avail,available,21960," in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computati",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:22108,Availability,avail,available,22108,". basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:22744,Availability,avail,available,22744,"s detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:22927,Availability,avail,available,22927,"ny computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23919,Availability,avail,available,23919,"of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:5288,Deployability,patch,patch,5288,"hon syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the following; geometry specification, taken from the mints6 input:; molecule alanine {; N -1.527107413251 0.745960643462 0.766603000356; C -0.075844098953 0.811790225041 0.711418672248; C 0.503195220163 -0.247849447550 -0.215671574613; O -0.351261319421 -0.748978309671 -1.089590304723; O 1.639498336738 -0.571249748886 -0.174705953194; H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which i",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:5335,Deployability,patch,patch,5335,"ython syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the following; geometry specification, taken from the mints6 input:; molecule alanine {; N -1.527107413251 0.745960643462 0.766603000356; C -0.075844098953 0.811790225041 0.711418672248; C 0.503195220163 -0.247849447550 -0.215671574613; O -0.351261319421 -0.748978309671 -1.089590304723; O 1.639498336738 -0.571249748886 -0.174705953194; H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to pro",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:6017,Deployability,patch,patch,6017," H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above in",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:27289,Deployability,integrat,integrated,27289,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function,; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers.",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:28512,Deployability,update,updated,28512,") with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function,; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; A PSI4 Tutorial; Next topic; Basis Sets; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:2127,Energy Efficiency,meter,meters,2127," if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:2514,Energy Efficiency,joule,joule,2514,"8]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 #",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:2654,Energy Efficiency,joule,joule,2654,"he physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Spec",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:6672,Energy Efficiency,energy,energy,6672,"01996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers cha",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:6744,Energy Efficiency,energy,energy,6744,". aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:7219,Energy Efficiency,energy,energy,7219,"l group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:7285,Energy Efficiency,energy,energy,7285,"ne Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a lin",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:7657,Energy Efficiency,charge,charge,7657," set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the secon",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:7767,Energy Efficiency,charge,charge,7767," set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the secon",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:8802,Energy Efficiency,charge,charge,8802,"nd multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for c",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:11980,Energy Efficiency,charge,charge,11980,"; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or. molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Sec. Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  . For example, water ( symmetry) has 3 doubly occupied ; orbitals, as well as 1 each of and symmetry; the; corresponding DOCC array is therefore:; DOCC = [3, 0, 1, 1]. Although PSI4 will detect the symmetry automatically, and use the largest; possible Abelian subgrou",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:14871,Energy Efficiency,energy,energy,14871,"tain types of finite difference computations, such as numerical vibrational; frequencies, might lower the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as SOCC, are automatically remapped; to the lower symmetry. For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molec",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:15396,Energy Efficiency,adapt,adapted,15396,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:15781,Energy Efficiency,energy,energy,15781,"ion as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf fir",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:16228,Energy Efficiency,charge,charge,16228,"s¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.e",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:16314,Energy Efficiency,charge,charge,16314,"poise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:16478,Energy Efficiency,charge,charge,16478,"I4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Ap",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:16520,Energy Efficiency,charge,charges,16520,"I4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Ap",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:17219,Energy Efficiency,energy,energy,17219,"s case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis =",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:17279,Energy Efficiency,energy,energy,17279,"gment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:18921,Energy Efficiency,energy,energy,18921,"set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snipp",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:19246,Energy Efficiency,energy,energy,19246,"pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:19500,Energy Efficiency,energy,energy,19500,"s the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likew",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:22842,Energy Efficiency,power,power,22842,"ny computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23138,Energy Efficiency,energy,energy,23138,"to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23221,Energy Efficiency,energy,energy,23221,"enient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23310,Energy Efficiency,energy,energy,23310,"es the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF f",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23394,Energy Efficiency,energy,energy,23394,"es the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF f",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23508,Energy Efficiency,energy,energy,23508,"(and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you g",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23874,Energy Efficiency,energy,energy,23874,"of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23902,Energy Efficiency,energy,energy,23902,"of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:24824,Energy Efficiency,energy,energy,24824,"rough the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Pyth",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25235,Energy Efficiency,energy,energy,25235,"t_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25501,Energy Efficiency,energy,energy,25501," that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25997,Energy Efficiency,energy,energy,25997,"quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatti",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:26254,Energy Efficiency,energy,energy,26254,"2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:26636,Energy Efficiency,energy,energy,26636,"e that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the option",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:6077,Integrability,depend,depends,6077," H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above in",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:14027,Integrability,depend,dependent,14027,"eyword can be used when inputting the molecule; (see Sec. Molecule and Geometry Specification). In most cases the standard; Schönflies symbol (one of c1, c2, ci, cs, d2,; c2h, c2v, d2h will suffice.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with symmetry in , the; axis can be chosen as either the , the , or the ; these can; be specified by requesing the symmetry as c2vx, c2vy, or c2vz, respectively.; Likewise the c2x, c2y, c2z, c2hx, c2hy, and c2hz; labels are valid. For symmetry the labels csx, csy, and; csz request the , , and planes be used as the mirror plane,; respectively. If no unique axis is specified, PSI4 will choose an appropriate; subgroup.; Certain types of finite difference computations, such as numerical vibrational; frequencies, might lower the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as SOCC, are automatically remapped; to the lower symmetry. For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these sta",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:18059,Integrability,wrap,wraps,18059,"nd sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs cou",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:24994,Integrability,wrap,wraps,24994,"on driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:27289,Integrability,integrat,integrated,27289,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function,; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers.",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:1064,Modifiability,variab,variables,1064,"ion. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversio",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:1322,Modifiability,variab,variable,1322,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:1570,Modifiability,variab,variables,1570,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hart",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:3611,Modifiability,variab,variables,3611,"}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix C",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:3697,Modifiability,flexible,flexible,3697,"ts (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the follo",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:3798,Modifiability,variab,variables,3798,"ts (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the follo",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:3864,Modifiability,variab,variables,3864," psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the following; geometry specification, taken from the mints6 input:; molecule alanine {; N -1.527107413251 0.745960643462 0.766603000356",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:15396,Modifiability,adapt,adapted,15396,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23443,Modifiability,variab,variable,23443,"es the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF f",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23677,Modifiability,variab,variables,23677,"e; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over t",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23687,Modifiability,variab,variables,23687,"e; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over t",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:24061,Modifiability,variab,variables,24061,"lecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_se",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:24221,Modifiability,variab,variables,24221,"ree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25077,Modifiability,variab,variable,25077,"on driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25200,Modifiability,variab,variable,25200,"t_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25747,Modifiability,variab,variable,25747,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25813,Modifiability,variab,variables,25813,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:235,Performance,perform,performed,235,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:376,Performance,perform,performed,376,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:988,Performance,perform,performing,988,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:1551,Performance,load,loaded,1551,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hart",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:1601,Performance,load,loaded,1601,"test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) con",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:6787,Performance,perform,performed,6787,"0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry;",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:6839,Performance,perform,performed,6839,"0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry;",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:9762,Performance,perform,performed,9762,"clear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whose name(s) contain “benzene”, but we’re not sure of the exact IUPAC; name, the following input can be used:; molecule benzene {; pubchem:benzene*; }. Appending the “*” prevents an exact match from being found and, at the time; of writing, the following results are displayed in the output file:; Chemical ID IUPAC Name; 241 benzene; 7371 benzenesulfonic acid; 91526 benzenesulfonate; 244 phenylmethanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 ben",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:11621,Performance,optimiz,optimized,11621,"methanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 benzenesulfonamide; 636822 1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene; 7369 benzenesulfonyl chloride; 12932 N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or. molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Sec. Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:16713,Performance,perform,perform,16713,"place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:17370,Performance,perform,perform,17370,"agment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:19053,Performance,perform,performs,19053,"hon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:19166,Performance,perform,performed,19166,"pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:19299,Performance,perform,performed,19299,"pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:19944,Performance,perform,performs,19944," set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:21933,Performance,perform,perform,21933," in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computati",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23797,Performance,perform,performing,23797,"of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:26651,Performance,perform,performed,26651,"e that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the option",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:27246,Performance,perform,performed,27246,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function,; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers.",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:8045,Safety,detect,detected,8045,"yword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; co",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:12893,Safety,detect,detect,12893," used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  . For example, water ( symmetry) has 3 doubly occupied ; orbitals, as well as 1 each of and symmetry; the; corresponding DOCC array is therefore:; DOCC = [3, 0, 1, 1]. Although PSI4 will detect the symmetry automatically, and use the largest; possible Abelian subgroup, the user might want to run in a lower point group.; To do this the symmetry keyword can be used when inputting the molecule; (see Sec. Molecule and Geometry Specification). In most cases the standard; Schönflies symbol (one of c1, c2, ci, cs, d2,; c2h, c2v, d2h will suffice.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with symmetry in , the; axis can be chosen as either the , the , or the ; these can; be specified by requesing the symmetry as c2vx, c2vy, or c2vz, respectively.; Likewise the c2x, c2y, c2z, c2hx, c2hy, and c2hz; labels are valid. For symmetry the labels csx, csy, and; csz request the , , and planes be used as the mirror plane,; respectively. If no unique axis is specified, PSI4 will choose an appropriate; subgroup.; Certain types of finite difference computations, such as numerical vibrational; freque",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:20880,Safety,detect,detect,20880," this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are a",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23731,Security,access,accessed,23731,"ailable to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ""",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25728,Security,access,access,25728,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:605,Testability,test,test,605,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:695,Testability,test,test,695,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:325,Usability,simpl,simpler,325,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:8452,Usability,simpl,simplified,8452," above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] datab",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:9075,Usability,intuit,intuitive,9075,"tations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to t",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:9179,Usability,intuit,intuitive,9179," are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whos",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:15540,Usability,simpl,simple,15540," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having de",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:15572,Usability,simpl,simply,15572," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having de",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:16488,Usability,simpl,simply,16488,"I4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Ap",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:16696,Usability,simpl,simple,16696,"place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:24276,Usability,clear,cleared,24276,"ree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As",MatchSource.WIKI,psi4manual/4.0b4/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:1335,Availability,avail,available,1335,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:1739,Availability,avail,available,1739," the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:15023,Availability,reliab,reliable,15023,"For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.90",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:21849,Availability,avail,available,21849,"etrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Va",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:21960,Availability,avail,available,21960," in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computati",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:22108,Availability,avail,available,22108,". basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:22744,Availability,avail,available,22744,"s detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:22927,Availability,avail,available,22927,"ny computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23919,Availability,avail,available,23919,"of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:5288,Deployability,patch,patch,5288,"hon syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the following; geometry specification, taken from the mints6 input:; molecule alanine {; N -1.527107413251 0.745960643462 0.766603000356; C -0.075844098953 0.811790225041 0.711418672248; C 0.503195220163 -0.247849447550 -0.215671574613; O -0.351261319421 -0.748978309671 -1.089590304723; O 1.639498336738 -0.571249748886 -0.174705953194; H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which i",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:5335,Deployability,patch,patch,5335,"ython syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the following; geometry specification, taken from the mints6 input:; molecule alanine {; N -1.527107413251 0.745960643462 0.766603000356; C -0.075844098953 0.811790225041 0.711418672248; C 0.503195220163 -0.247849447550 -0.215671574613; O -0.351261319421 -0.748978309671 -1.089590304723; O 1.639498336738 -0.571249748886 -0.174705953194; H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to pro",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:6017,Deployability,patch,patch,6017," H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above in",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:27289,Deployability,integrat,integrated,27289,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function,; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers.",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:28512,Deployability,update,updated,28512,") with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function,; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; A PSI4 Tutorial; Next topic; Basis Sets; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:2127,Energy Efficiency,meter,meters,2127," if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:2514,Energy Efficiency,joule,joule,2514,"8]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 #",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:2654,Energy Efficiency,joule,joule,2654,"he physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Spec",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:6672,Energy Efficiency,energy,energy,6672,"01996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers cha",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:6744,Energy Efficiency,energy,energy,6744,". aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:7219,Energy Efficiency,energy,energy,7219,"l group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:7285,Energy Efficiency,energy,energy,7285,"ne Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a lin",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:7657,Energy Efficiency,charge,charge,7657," set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the secon",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:7767,Energy Efficiency,charge,charge,7767," set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the secon",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:8802,Energy Efficiency,charge,charge,8802,"nd multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for c",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:11980,Energy Efficiency,charge,charge,11980,"; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or. molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Sec. Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  . For example, water ( symmetry) has 3 doubly occupied ; orbitals, as well as 1 each of and symmetry; the; corresponding DOCC array is therefore:; DOCC = [3, 0, 1, 1]. Although PSI4 will detect the symmetry automatically, and use the largest; possible Abelian subgrou",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:14871,Energy Efficiency,energy,energy,14871,"tain types of finite difference computations, such as numerical vibrational; frequencies, might lower the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as SOCC, are automatically remapped; to the lower symmetry. For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molec",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:15396,Energy Efficiency,adapt,adapted,15396,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:15781,Energy Efficiency,energy,energy,15781,"ion as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf fir",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:16228,Energy Efficiency,charge,charge,16228,"s¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.e",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:16314,Energy Efficiency,charge,charge,16314,"poise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:16478,Energy Efficiency,charge,charge,16478,"I4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Ap",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:16520,Energy Efficiency,charge,charges,16520,"I4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Ap",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:17219,Energy Efficiency,energy,energy,17219,"s case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis =",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:17279,Energy Efficiency,energy,energy,17279,"gment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:18921,Energy Efficiency,energy,energy,18921,"set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snipp",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:19246,Energy Efficiency,energy,energy,19246,"pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:19500,Energy Efficiency,energy,energy,19500,"s the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likew",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:22842,Energy Efficiency,power,power,22842,"ny computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23138,Energy Efficiency,energy,energy,23138,"to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23221,Energy Efficiency,energy,energy,23221,"enient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23310,Energy Efficiency,energy,energy,23310,"es the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF f",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23394,Energy Efficiency,energy,energy,23394,"es the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF f",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23508,Energy Efficiency,energy,energy,23508,"(and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you g",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23874,Energy Efficiency,energy,energy,23874,"of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23902,Energy Efficiency,energy,energy,23902,"of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:24824,Energy Efficiency,energy,energy,24824,"rough the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Pyth",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:25235,Energy Efficiency,energy,energy,25235,"t_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:25501,Energy Efficiency,energy,energy,25501," that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:25997,Energy Efficiency,energy,energy,25997,"quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatti",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:26254,Energy Efficiency,energy,energy,26254,"2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:26636,Energy Efficiency,energy,energy,26636,"e that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the option",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:6077,Integrability,depend,depends,6077," H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808. aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above in",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:14027,Integrability,depend,dependent,14027,"eyword can be used when inputting the molecule; (see Sec. Molecule and Geometry Specification). In most cases the standard; Schönflies symbol (one of c1, c2, ci, cs, d2,; c2h, c2v, d2h will suffice.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with symmetry in , the; axis can be chosen as either the , the , or the ; these can; be specified by requesing the symmetry as c2vx, c2vy, or c2vz, respectively.; Likewise the c2x, c2y, c2z, c2hx, c2hy, and c2hz; labels are valid. For symmetry the labels csx, csy, and; csz request the , , and planes be used as the mirror plane,; respectively. If no unique axis is specified, PSI4 will choose an appropriate; subgroup.; Certain types of finite difference computations, such as numerical vibrational; frequencies, might lower the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as SOCC, are automatically remapped; to the lower symmetry. For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these sta",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:18059,Integrability,wrap,wraps,18059,"nd sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs cou",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:24994,Integrability,wrap,wraps,24994,"on driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:27289,Integrability,integrat,integrated,27289,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function,; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers.",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:1064,Modifiability,variab,variables,1064,"ion. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversio",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:1322,Modifiability,variab,variable,1322,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:1570,Modifiability,variab,variables,1570,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hart",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:3611,Modifiability,variab,variables,3611,"}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix C",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:3697,Modifiability,flexible,flexible,3697,"ts (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the follo",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:3798,Modifiability,variab,variables,3798,"ts (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the follo",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:3864,Modifiability,variab,variables,3864," psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 and; mints6 sample input files. For example, consider the following; geometry specification, taken from the mints6 input:; molecule alanine {; N -1.527107413251 0.745960643462 0.766603000356",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:15396,Modifiability,adapt,adapted,15396,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23443,Modifiability,variab,variable,23443,"es the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF f",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23677,Modifiability,variab,variables,23677,"e; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over t",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23687,Modifiability,variab,variables,23687,"e; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over t",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:24061,Modifiability,variab,variables,24061,"lecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_se",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:24221,Modifiability,variab,variables,24221,"ree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:25077,Modifiability,variab,variable,25077,"on driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:25200,Modifiability,variab,variable,25200,"t_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:25747,Modifiability,variab,variable,25747,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:25813,Modifiability,variab,variables,25813,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:235,Performance,perform,performed,235,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:376,Performance,perform,performed,376,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:988,Performance,perform,performing,988,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:1551,Performance,load,loaded,1551,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hart",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:1601,Performance,load,loaded,1601,"test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) con",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:6787,Performance,perform,performed,6787,"0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry;",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:6839,Performance,perform,performed,6839,"0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry;",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:9762,Performance,perform,performed,9762,"clear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whose name(s) contain “benzene”, but we’re not sure of the exact IUPAC; name, the following input can be used:; molecule benzene {; pubchem:benzene*; }. Appending the “*” prevents an exact match from being found and, at the time; of writing, the following results are displayed in the output file:; Chemical ID IUPAC Name; 241 benzene; 7371 benzenesulfonic acid; 91526 benzenesulfonate; 244 phenylmethanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 ben",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:11621,Performance,optimiz,optimized,11621,"methanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 benzenesulfonamide; 636822 1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene; 7369 benzenesulfonyl chloride; 12932 N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or. molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Sec. Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:16713,Performance,perform,perform,16713,"place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:17370,Performance,perform,perform,17370,"agment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:19053,Performance,perform,performs,19053,"hon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:19166,Performance,perform,performed,19166,"pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:19299,Performance,perform,performed,19299,"pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:19944,Performance,perform,performs,19944," set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. ",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:21933,Performance,perform,perform,21933," in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. Scratch Files and the ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computati",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23797,Performance,perform,performing,23797,"of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:26651,Performance,perform,performed,26651,"e that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the option",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:27246,Performance,perform,performed,27246,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function,; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers.",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:8045,Safety,detect,detected,8045,"yword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; co",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:12893,Safety,detect,detect,12893," used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  . For example, water ( symmetry) has 3 doubly occupied ; orbitals, as well as 1 each of and symmetry; the; corresponding DOCC array is therefore:; DOCC = [3, 0, 1, 1]. Although PSI4 will detect the symmetry automatically, and use the largest; possible Abelian subgroup, the user might want to run in a lower point group.; To do this the symmetry keyword can be used when inputting the molecule; (see Sec. Molecule and Geometry Specification). In most cases the standard; Schönflies symbol (one of c1, c2, ci, cs, d2,; c2h, c2v, d2h will suffice.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with symmetry in , the; axis can be chosen as either the , the , or the ; these can; be specified by requesing the symmetry as c2vx, c2vy, or c2vz, respectively.; Likewise the c2x, c2y, c2z, c2hx, c2hy, and c2hz; labels are valid. For symmetry the labels csx, csy, and; csz request the , , and planes be used as the mirror plane,; respectively. If no unique axis is specified, PSI4 will choose an appropriate; subgroup.; Certain types of finite difference computations, such as numerical vibrational; freque",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:20880,Safety,detect,detect,20880," this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are a",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:23731,Security,access,accessed,23731,"ailable to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ""",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:25728,Security,access,access,25728,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:605,Testability,test,test,605,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:695,Testability,test,test,695,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:325,Usability,simpl,simpler,325,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:8452,Usability,simpl,simplified,8452," above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] datab",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:9075,Usability,intuit,intuitive,9075,"tations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to t",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:9179,Usability,intuit,intuitive,9179," are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whos",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:15540,Usability,simpl,simple,15540," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having de",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:15572,Usability,simpl,simply,15572," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having de",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:16488,Usability,simpl,simply,16488,"I4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Ap",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:16696,Usability,simpl,simple,16696,"place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/psithoninput.html:24276,Usability,clear,cleared,24276,"ree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As",MatchSource.WIKI,psi4manual/4.0b4/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput.html
https://psicode.org/psi4manual/4.0b4/py-modindex.html:1105,Deployability,update,updated,1105,"﻿. Python Module Index — PSI4 [beta4] documentation. Navigation. index. modules    . toc    ; PSI4 [beta4] » . Python Module Index. a | ; b | ; c | ; d | ; f | ; g | ; h | ; i | ; j | ; m | ; n | ; o | ; p | ; q | ; r | ; s | ; t | ; u | ; w.  . a. ACENES. aliases.  . b. BAKERJCC93. BAKERJCC96. BASIC. basislist. basislistdunning. basislistother. BENCH12.  . c. CORE.  . d. dashparam. diatomic. driver.  . f. frac. functional.  . g. gaussian_n.  . h. HBC6. HSG. HTBH.  . i. input.  . j. JSCH.  . m. molutil.  . n. NBC10. NCB31. NHTBH.  . o. optproc.  . p. physconst. proc. procutil. psiexceptions. pubchem.  . q. qcdb.    ; qcdb.__init__.    ; qcdb.dbproc.    ; qcdb.exceptions.    ; qcdb.libmintscoordentry.    ; qcdb.libmintsmolecule.    ; qcdb.molecule.    ; qcdb.periodictable.    ; qcdb.physconst.    ; qcdb.psiutil.    ; qcdb.vecutil. qmmm.  . r. RGC10. RSE42.  . s. S22. S22by5. S66.  . t. text.  . u. util.  . w. wrappers. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/py-modindex.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/py-modindex.html
https://psicode.org/psi4manual/4.0b4/py-modindex.html:922,Integrability,wrap,wrappers,922,"﻿. Python Module Index — PSI4 [beta4] documentation. Navigation. index. modules    . toc    ; PSI4 [beta4] » . Python Module Index. a | ; b | ; c | ; d | ; f | ; g | ; h | ; i | ; j | ; m | ; n | ; o | ; p | ; q | ; r | ; s | ; t | ; u | ; w.  . a. ACENES. aliases.  . b. BAKERJCC93. BAKERJCC96. BASIC. basislist. basislistdunning. basislistother. BENCH12.  . c. CORE.  . d. dashparam. diatomic. driver.  . f. frac. functional.  . g. gaussian_n.  . h. HBC6. HSG. HTBH.  . i. input.  . j. JSCH.  . m. molutil.  . n. NBC10. NCB31. NHTBH.  . o. optproc.  . p. physconst. proc. procutil. psiexceptions. pubchem.  . q. qcdb.    ; qcdb.__init__.    ; qcdb.dbproc.    ; qcdb.exceptions.    ; qcdb.libmintscoordentry.    ; qcdb.libmintsmolecule.    ; qcdb.molecule.    ; qcdb.periodictable.    ; qcdb.physconst.    ; qcdb.psiutil.    ; qcdb.vecutil. qmmm.  . r. RGC10. RSE42.  . s. S22. S22by5. S66.  . t. text.  . u. util.  . w. wrappers. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/py-modindex.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/py-modindex.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:461,Availability,avail,available,461,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:759,Availability,avail,available,759,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:3842,Deployability,update,updated,3842,"e('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:938,Energy Efficiency,energy,energy,938,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:979,Energy Efficiency,energy,energy,979,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:1248,Energy Efficiency,energy,energy,1248,"to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:1308,Energy Efficiency,energy,energy,1308,"scribed below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiM",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:1742,Energy Efficiency,energy,energy,1742,"MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2745,Energy Efficiency,energy,energy,2745,"antities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previo",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2800,Energy Efficiency,energy,energy,2800,"t_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2857,Energy Efficiency,energy,energy,2857,"ON ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2913,Energy Efficiency,energy,energy,2913,"ble('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2976,Energy Efficiency,energy,energy,2976,"e('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:3040,Energy Efficiency,energy,energy,3040,"e('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:3103,Energy Efficiency,energy,energy,3103,"e('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:3351,Energy Efficiency,energy,energy,3351,"e('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:3487,Energy Efficiency,energy,energy,3487,"e('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:478,Modifiability,variab,variables,478,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:859,Modifiability,variab,variables,859,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:1565,Modifiability,variab,variable,1565,"es.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banne",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2282,Modifiability,variab,variable,2282," print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. A",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2442,Modifiability,variab,variable,2442,"n/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2420,Performance,optimiz,optimizer,2420,"n/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:2487,Performance,optimiz,optimizations,2487,"s):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-De",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html:391,Security,access,accessed,391,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:461,Availability,avail,available,461,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:759,Availability,avail,available,759,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:3842,Deployability,update,updated,3842,"e('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:938,Energy Efficiency,energy,energy,938,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:979,Energy Efficiency,energy,energy,979,"﻿. Defining a Method Alias — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:1248,Energy Efficiency,energy,energy,1248,"to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:1308,Energy Efficiency,energy,energy,1308,"scribed below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiM",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:1742,Energy Efficiency,energy,energy,1742,"MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += ",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:2745,Energy Efficiency,energy,energy,2745,"antities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previo",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
https://psicode.org/psi4manual/4.0b4/quickaddalias.html:2800,Energy Efficiency,energy,energy,2800,"t_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple",MatchSource.WIKI,psi4manual/4.0b4/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddalias.html
